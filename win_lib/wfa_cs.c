 
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors ($B!H(BAuthorized Licensees$B!I(B)..AN  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee$B!G(Bs proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below..AN  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee$B!G(Bs product to their customers with or
 *  without such third party$B!G(Bs private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications..AN  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein..AN 
 *.AN 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *.AN 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *.AN 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A.AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */

/* 
 *   File: wfa_cs.c -- configuration and setup
 *   This file contains all implementation for the dut setup and control 
 *   functions, such as network interfaces, ip address and wireless specific
 *   setup with its supplicant.
 *
 *   The current implementation is to show how these functions
 *   should be defined in order to support the Agent Control/Test Manager 
 *   control commands. To simplify the current work and avoid any GPL licenses,
 *   the functions mostly invoke shell commands by calling linux system call,
 *   system("<commands>"). 
 *
 *   It depends on the differnt device and platform, vendors can choice their
 *   own ways to interact its systems, supplicants and process these commands
 *   such as using the native APIs.
 *
 *   Revision History:
 *        2008/03/12 --  02.41 Bug #16, incorrect file descriptor used. Change 
 *                       the "tmpfile" to "tmpfd" and a few places. Make a macro
 *                       WFA_STAUT_IF in file "inc/wfa_cs.h" for WLAN interface
 *                       name in the function "wfaDeviceListIF()
 *                      
 *                       Not A Bug. Put back to the function from 
 *                       wfaSetEncryption1() to wfaSetEncryption() for 
 *                       supporting WEP. Porting could select which should be 
 *                       used according to WEP support or not.
 *        2009/06/18 -- WPA2 Test plan v1.8 Automation functionalities added by Chandra
 *        2009/09/30 -- WINv03.00.00. Support TGn Release, including WPA2 and WMM [QH].
 *                        
 *        
 */ 
#include <stdio.h>
//#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#ifdef _WINDOWS
#include <winsock.h>
#else
#ifdef _CYGWIN
#include <cygwin/types.h>
#include <cygwin/socket.h>
#else
#include <linux/types.h>
#include <linux/socket.h>
#endif
#include <arpa/inet.h>
#include <sys/socket.h>
#include <poll.h>
#endif
#include "wfa_debug.h"
#include "wfa_ver.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_ca.h"
#include "wfa_tlv.h"
#include "wfa_sock.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_rsp.h"
#include "wfa_miscs.h"
#ifdef WFA_WMM_EXT
#ifdef WFA_WMM_PS_EXT
#include "wfa_wmmps.h"
extern int wfaTGSetPrio(int sockfd, int tgClass);
#endif
#endif

#if 0 /* take this out */
#include <iwlib.h>
#include <wireless.h>
/*
 * atheros wireless interface madwifi driver include files
 * You may remove them if using other device interface
 */
#include "xtn/compat.h"
#include "xtn/_ieee80211.h"
#include "xtn/ieee80211_crypto.h"
#include "xtn/ieee80211.h"
#include "xtn/ieee80211_ioctl.h"
#include "xtn/if_athioctl.h"
#endif
#define FW(x,y) FindWindowEx(x, NULL, y, L"")

#define CERTIFICATES_PATH    "/etc/wpa_supplicant"

/* Some device may only support UDP ECHO, activate this line */
//#define WFA_PING_UDP_ECHO_ONLY 1

extern unsigned short wfa_defined_debug;
extern char       gnetIf[WFA_BUFF_64];        /* specify the interface to use */


extern int geSupplicant; /* supplicant type */
extern char gStaSSID[WFA_SSID_NAME_LEN]; // for Marvell supplicant
extern int tgWMMTestEnable;              // used at function SET_WMM to instruct this in a WMM test mode which will help RECV function performance. Will be removed after the function got enhanced.

/* Since the two definitions are used all over the CA function */
char gCmdStr[WFA_CMD_STR_SZ];
dutCmdResponse_t gGenericResp;
/* Global variable for Channel width to support Intel MCS rate command*/
WORD g11nChnlWidth;
#ifdef _WINDOWS
int vend;
extern char WFA_CLI_VERSION[];
extern char intfname[];
extern char intfNetName[];

char *aINTERFACE = &intfname[0];
char *aINTERFACE_NAME=&intfNetName[0];
#endif

#ifdef WFA_WMM_EXT
extern char e2eResults[];
//extern char *e2eResults;
FILE *e2efp = NULL;
#endif

char *capstr[] = {"Disable", "Enable"};

char WFA_CLI_CMD_DIR[64] = "C:\\Sigma\\Intel\\CLIs\\";

int wfaExecuteCLI(char *CLI);
int CiscoEAPConfigGenerateLowerPart(FILE *file,char *encrType,char *secuType);
int CiscoEAPConfigGenerateUpperPart(FILE *file, char *ssid);
int CiscoConfigGenerateLowerPart(FILE *file);
int CiscoConfigGenerateUpperPart(FILE *file);


/*
 * agtCmdProcGetVersion(): response "ca_get_version" command to controller
 *  input:  cmd --- not used
 *          valLen -- not used
 *  output: parms -- a buffer to store the version info response.
 */
int agtCmdProcGetVersion(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *getverResp = &gGenericResp;

    DPRINT_INFO(WFA_OUT, "entering agtCmdProcGetVersion ...\n");

    getverResp->status = STATUS_COMPLETE;
    strncpy(getverResp->cmdru.version, WFA_SYSTEM_VER, WFA_VERSION_LEN-1);

    wfaEncodeTLV(WFA_GET_VERSION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getverResp, respBuf);

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    return TRUE;
}

/*
 * wfaStaAssociate():
 *    The function is to force the station wireless I/F to re/associate 
 *    with the AP.
 */
int wfaStaAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *assoc = (dutCommand_t *)caCmdBuf;
   char *ifname = assoc->intf;
   char *ssid = assoc->cmdsu.ssid;
   dutCmdResponse_t *staAssocResp = &gGenericResp;
   FILE *tmpfd;
   char string[64];

   DPRINT_INFO(WFA_OUT, "entering wfaStaAssociate ...\n");
#if defined(_CYGWIN) || defined(_WINDOWS) 

   if (geSupplicant == eWindowsZeroConfig)
   {
//	   sprintf(gCmdStr, "wifi_config -limit %s -enable", gnetIf);
	   //system(gCmdStr);
	   //sprintf(gCmdStr, "wifi_config -limit %s -connect %s", gnetIf,ssid);
	   
	   sprintf(gCmdStr, "netsh wlan connect name=%s ssid=%s", ssid,ssid);
	   //printf("Executing %s\n",gCmdStr);
	   system(gCmdStr);
   }
   if (geSupplicant == eWpaSupplicant)
   {
	   sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	   system(gCmdStr);
	   printf("Executing %s\n",gCmdStr);

	   sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
	   system(gCmdStr);
	   printf("Executing %s\n",gCmdStr);

	   // for re-association
	   //sprintf(gCmdStr, "wpa_cli -i\\Device\\NPF_%s reassociate", gnetIf);
	   //printf("Executing %s\n",gCmdStr);
	   //system(gCmdStr);
   }
 if (geSupplicant == eCiscoSecureClient)
   {
	   sprintf(gCmdStr, "sc stop \"Cisco Secure Services Client\"");
	   system(gCmdStr);
	   printf("Executing %s\n",gCmdStr);

	   Sleep(5000);
	   sprintf(gCmdStr, "sc start \"Cisco Secure Services Client\"");
	   system(gCmdStr);
	   printf("Executing %s\n",gCmdStr);

	   // for re-association
	   //sprintf(gCmdStr, "wpa_cli -i\\Device\\NPF_%s reassociate", gnetIf);
	   //printf("Executing %s\n",gCmdStr);
	   //system(gCmdStr);
   }
 
   if (geSupplicant == eMarvell)
   {
	// Store the SSID value for checking the associated ssid
	   strcpy(gStaSSID,ssid);

	   // restart the supplicant


   		sprintf(gCmdStr, "Taskkill /T /F /IM Mrv8000x.exe");
		system(gCmdStr);
		printf("Executing %s\n",gCmdStr);
		Sleep(1000);

		sprintf(gCmdStr, " start \"Marvell\" /D \"c:\\Program\ Files\\Marvell\ CB82\" Mrv8000x.exe");
		system(gCmdStr);
		printf("Executing %s\n",gCmdStr);
		Sleep(3000);

		// call MarvellConnect.exe with ssid

	   sprintf(gCmdStr, "MarvellConnect.exe m");
	   system(gCmdStr);
	   printf("Executing %s\n",gCmdStr);
	   Sleep(2000);


	   // check with auto it that the associated ssid is same
	   // if samesend the response ok
	   sprintf(gCmdStr, "WfaMarvell.exe c:\\windows\\temp\\Marvell.txt");
	   system(gCmdStr);
	   printf("Executing %s\n",gCmdStr);
	   Sleep(2000);
	   tmpfd = fopen("c:\\windows\\temp\\Marvell.txt", "r+");
	   if(tmpfd == NULL)
	   {
		  staAssocResp->status = STATUS_ERROR;
		  wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
		  *respLen = WFA_TLV_HDR_LEN + 4;	   

		  DPRINT_ERR(WFA_ERR, "file open failed\n");
		  return FALSE;
	   }

	// file exist, verify the connected status
		for(;;)
		{
			if(fscanf(tmpfd, "%s", string) == EOF)
			{
				staAssocResp->status = STATUS_ERROR; 
				wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
				*respLen = WFA_TLV_HDR_LEN + 4;	   

				DPRINT_ERR(WFA_ERR, "file open failed\n");
				return FALSE;
			}
			printf("\nIn Association - string : %s",string);

			if(strncmp(string, "STATUS", 6) == 0)
			{
				char *str;
				printf("\nIn Association STATUS string : %s",string);

				str = strtok(string, "=");
				str = strtok(NULL, "=");
				printf("\nIn Association - str : %s",str);
				if(str != NULL)
				{
					// string compare for Connected
					// if okay, return complete.
					if(strncmp(str, "Connected", 9) == 0)
						break;
					else
					{
						staAssocResp->status = STATUS_ERROR; 
						wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
						*respLen = WFA_TLV_HDR_LEN + 4;	   

						DPRINT_ERR(WFA_ERR, "Assocition satus %s\n",str);
						return FALSE;
					}
				}
				else
				{
					staAssocResp->status = STATUS_ERROR; 
					wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
					*respLen = WFA_TLV_HDR_LEN + 4;	   

					DPRINT_ERR(WFA_ERR, "Assocition failed\n");
					return FALSE;
				}
			}
		}
	}
	

	// if the default profile then, try to change the profile through auto it
	// else 
		// send error
	//
   

#else 
   /* use 'ifconfig' command to bring down the interface (linux specific) */
   sprintf(gCmdStr, "ifconfig %s down", ifname);
   system(gCmdStr);

   /* use 'ifconfig' command to bring up the interface (linux specific) */
   sprintf(gCmdStr, "ifconfig %s up", ifname);

   /* 
    *  use 'wpa_cli' command to force a 802.11 re/associate 
    *  (wpa_supplicant specific) 
    */
   system(gCmdStr);
   sprintf(gCmdStr, "wpa_cli -i%s reassociate", ifname);
   system(gCmdStr);
#endif

   /*
    * Then report back to control PC for completion.
    * This does not have failed/error status. The result only tells
    * a completion.
    */
   staAssocResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE; 
}

/*
 * wfaStaIsConnected():
 *    The function is to check whether the station's wireless I/F has 
 *    already connected to an AP.
 */
int wfaStaIsConnected(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *connStat = (dutCommand_t *)caCmdBuf;
   FILE *tmpfile = NULL;
   char result[32],filename[256];
   dutCmdResponse_t *staConnectResp = &gGenericResp;
   char *ifname = connStat->intf;
   char string[64],Interfacename[64];
   int i;

   DPRINT_INFO(WFA_OUT, "Entering isConnected ...\n"); 
#if defined(_CYGWIN) || defined(_WINDOWS)
#ifdef _CYGWIN
   sprintf(gCmdStr, "wifi_config -limit %s -query status> /tmp/.isConnected", ifname);
   strcpy(filename,"/tmp/.isConnected");
#else
   sprintf(gCmdStr, "del c:\\windows\\temp\\iscon.txt");
   system(gCmdStr);
   if(geSupplicant == eWindowsZeroConfig)
   {
	   //sprintf(gCmdStr, "wifi_config -limit %s -query status> c:\\windows\\temp\\iscon.txt", gnetIf);
	   strcpy(filename,"c:\\windows\\temp\\iscon.txt");

		tmpfile = fopen("c:\\wfa\\WfaEndpoint\\Interface.txt", "r");
		if(tmpfile == NULL)
		{
			printf("\n Error opening the interface file \n");
		}
		else
		{
			for(;;)
			{
				if(fgets(string, 256, tmpfile) == NULL)
					break; 
			}
			fclose(tmpfile);

			if(strncmp(string, "IFNAME", 6) == 0)
			  {
				 char *str;
				 str = strtok(string, "\"");
				 str = strtok(NULL, "\"");
				 if(str != NULL)
				 {
					 strcpy(&Interfacename[0],str);
				 }

			  }
		}
		sprintf(gCmdStr, "del /F c:\\WFA\\temp.txt",string);
       	//printf("Executing %s\n",gCmdStr);

		sprintf(gCmdStr, "netsh wlan show  interface name=\"%s\" > c:\\WFA\\temp.txt",&Interfacename[0]);
       	//printf("Executing %s\n",gCmdStr);
	   	system(gCmdStr);

		sprintf(gCmdStr, "FOR /F \"tokens=2 delims=: \" %s IN ('findstr State c:\\WFA\\temp.txt') DO @echo %s > c:\\windows\\temp\\iscon.txt","%i","%i");
       	//printf("Executing %s\n",gCmdStr);
		system(gCmdStr);

   }
   else if(geSupplicant == eWpaSupplicant)
   {
	   //sprintf(gCmdStr, "wpa_cli -i\\Device\\NPF_%s status > c:\\windows\\temp\\iscon.txt", gnetIf);
	   sprintf(gCmdStr, "wpa_cli status > c:\\windows\\temp\\iscon.txt", gnetIf);
	   strcpy(filename,"c:\\windows\\temp\\iscon.txt");
   }
   else if(geSupplicant == eCiscoSecureClient)
   {
	   sprintf(gCmdStr, "FOR /F \"tokens=19 delims== \" %s IN ('find \"received adapterState\" \"c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\logs\\CurrentLog.txt\"') DO @echo %s > c:\\windows\\temp\\iscon.txt","%i","%i");
//				FOR /F "tokens=19 delims== " %i IN ('find "received adapterState" "c:\Documents and Settings\All Users\Application Data\Cisco\Cisco Secure Services Client\logs\CurrentLog.txt"') DO @echo %i %j

//	   sprintf(gCmdStr, "wpa_cli -i\\Device\\NPF_%s status > c:\\windows\\temp\\iscon.txt", gnetIf);
	   strcpy(filename,"c:\\windows\\temp\\iscon.txt");
   }
   else if(geSupplicant == eMarvell)
   {
	   sprintf(gCmdStr, "WfaMarvell.exe c:\\windows\\temp\\iscon.txt");
	   strcpy(filename,"c:\\windows\\temp\\iscon.txt");
   }
#endif
   printf("Executing %s\n",gCmdStr);
   system(gCmdStr);

#else 
   /*
    * use 'wpa_cli' command to check the interface status
    * none, scanning or complete (wpa_supplicant specific)
    */ 
   sprintf(gCmdStr, "wpa_cli -i%s status | grep ^wpa_state= | cut -f2- -d= > /tmp/.isConnected", ifname);
   system(gCmdStr);
   strcpy(filename,"/tmp/.isConnected");
    
#endif
   /*
    * the status is saved in a file.  Open the file and check it.
    */

   tmpfile = fopen(filename, "r+");
   if(tmpfile == NULL)
   {
      staConnectResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, 4, (BYTE *)staConnectResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
   }


   if(geSupplicant == eWindowsZeroConfig)
   {
	   fscanf(tmpfile, "%s", result); 
	   if(strncmp(result, "connected", 9) == 0)
		   staConnectResp->cmdru.connected = 1;
	   else
		   staConnectResp->cmdru.connected = 0;
//		   staConnectResp->cmdru.connected = 1;
   } 
   else if (geSupplicant == eWpaSupplicant)
   {
	     for(;;)
		   {
			  if(fscanf(tmpfile, "%s", string) == EOF)
			  {
				 staConnectResp->cmdru.connected = 0;
				 break; 
			  }

			  if(strncmp(string, "wpa_state", 9) == 0)
			  {
				 char *str;
				 str = strtok(string, "=");
				 str = strtok(NULL, "=");
				 if(str != NULL)
				 {
					 printf("\nThe Is connected status = %s cmp rslt= %d.\n",str,strncmp(str, "COMPLETE", 8));
					 if(strncmp(str, "COMPLETE", 8) == 0)
						 staConnectResp->cmdru.connected = 1;
					 else
						 staConnectResp->cmdru.connected = 0;
					break;
				 }

			  }
		 }
			
   }

   else if (geSupplicant == eCiscoSecureClient)
   {
	     for(;;)
		   {
			  if(fscanf(tmpfile, "%s", string) == EOF)
			  {
				 staConnectResp->cmdru.connected = 0;
				 break; 
			  }

			  if(strncmp(string, "connected", 9) == 0)
			  {
				  staConnectResp->cmdru.connected = 1;
				  break;
			  }
			  else
				  staConnectResp->cmdru.connected = 0;
		  }
   }
   else if (geSupplicant == eMarvell)
   {
		char temp_ssid[64];
		BYTE status = 0;
		char *str;
		for(;;)
		{
			if(fscanf(tmpfile, "%s", string) == EOF)
			{
				break; 
			}

			printf("\nThe string read %s",string);
			if(strncmp(string, "SSID", 4) == 0)
			{
				printf("\nThe string SSID %s",string);
				str = strtok(string, "=");
				str = strtok(NULL, "=");
				strcpy(temp_ssid,str);
				printf("\nThe temp_ssid %s",temp_ssid);
			}
			else if(strncmp(string, "STATUS", 6) == 0)
			{
				printf("\nThe string SSID %s",string);
				str = strtok(string, "=");
				str = strtok(NULL, "=");
				printf("\nThe status  %s",str);
				if(strncmp(str, "Connected", 9) == 0)
					status = 1;
			}
		}

		printf("\nThe temp_ssid  %s",temp_ssid);
		printf("\nThe gStaSSID  %s",gStaSSID);

		if( (status == 1) && (strcmp(temp_ssid,gStaSSID) == 0) )
			staConnectResp->cmdru.connected = 1;
		else
			staConnectResp->cmdru.connected = 0;
   }


   /*
    * Report back the status: Complete or Failed.
    */
   staConnectResp->status = STATUS_COMPLETE;
   
   wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)staConnectResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   if(tmpfile)
   	fclose(tmpfile);
   return TRUE;
}

/*
 * wfaStaGetIpConfig():
 * This function is to retriev the ip info including
 *     1. dhcp enable
 *     2. ip address
 *     3. mask 
 *     4. primary-dns
 *     5. secondary-dns
 *
 *     The current implementation is to use a script to find these information
 *     and store them in a file. 
 */
int wfaStaGetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int i = 0;
    dutCmdResponse_t *ipconfigResp = &gGenericResp; 
    caStaGetIpConfigResp_t *ifinfo = &ipconfigResp->cmdru.getIfconfig;
#if !defined(_CYGWIN) && !defined(_WINDOWS)
    int slen, ret;
    char *str;
#endif

    dutCommand_t *getIpConf = (dutCommand_t *)caCmdBuf;
    char *ifname = getIpConf->intf;
    FILE *tmpfd;
    char string[256],Interfacename[64];
    char *str;

    strcpy(ifinfo->dns[0], "0");
    strcpy(ifinfo->dns[1], "0");
#if !defined(_CYGWIN) && !defined(_WINDOWS)
    /*
     * check a script file (the current implementation specific)
     */
    ret = access("/usr/local/sbin/getipconfig.sh", F_OK);
    if(ret == -1)
    {
       ipconfigResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);   
       *respLen = WFA_TLV_HDR_LEN + 4;

       DPRINT_ERR(WFA_ERR, "file not exist\n");
       return FALSE; 

    }

    
    /*
     * Run the script file "getipconfig.sh" to check the ip status 
     * (current implementation  specific). 
     * note: "getipconfig.sh" is only defined for the current implementation
     */
    sprintf(gCmdStr, "getipconfig.sh /tmp/ipconfig.txt %s\n", ifname); 

    system(gCmdStr);

    /* open the output result and scan/retrieve the info */
    tmpfd = fopen("/tmp/ipconfig.txt", "r+");

    if(tmpfd == NULL)
    {
      ipconfigResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
    }

    for(;;)
    {
        if(fgets(string, 256, tmpfd) == NULL)
           break; 

        /* check dhcp enabled */
        if(strncmp(string, "dhcpcli", 7) ==0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, "=");
            if(str != NULL)
               ifinfo->isDhcp = 1;
            else
               ifinfo->isDhcp = 0;
        }

        /* find out the ip address */
        if(strncmp(string, "ipaddr", 6) == 0)
        {
            str = strtok(string, "=");
            str = strtok(NULL, " ");
            if(str != NULL)
            {
               strncpy(ifinfo->ipaddr, str, 15);
               ifinfo->ipaddr[15]='\0';
            }
            else
               strncpy(ifinfo->ipaddr, "none", 15);
        }

        /* check the mask */
        if(strncmp(string, "mask", 4) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;

            str = strtok_r(string, "=", &ttp);
            if(*ttp != '\0')
            {
               strcpy(ifinfo->mask, ttp);
               slen = strlen(ifinfo->mask);
               ifinfo->mask[slen-1] = '\0';
            }
            else
               strcpy(ifinfo->mask, "none");
        }

        /* find out the dns server ip address */
        if(strncmp(string, "nameserv", 8) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;
            
            str = strtok_r(string, " ", &ttp);
            if(str != NULL && i < 2)
            {
               strcpy(ifinfo->dns[i], ttp);
               slen = strlen(ifinfo->dns[i]);
               ifinfo->dns[i][slen-1] = '\0';
            }
            else
               strcpy(ifinfo->dns[i], "none");

            i++;
        }
     }
#else
#ifdef _WINDOWS
//     sprintf(gCmdStr, "wifi_config -limit %s -all > c:\\windows\\temp\\getcon.txt", gnetIf);

     tmpfd = fopen("c:\\wfa\\WfaEndpoint\\Interface.txt", "r");
    if(tmpfd == NULL)
    {
      ipconfigResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, " Interface.txt file open failed\n");
      return FALSE;
    }
	else
	{
	    for(;;)
	    {
	        if(fgets(string, 256, tmpfd) == NULL)
	           break; 
		}
		fclose(tmpfd);

			if(strncmp(string, "IFNAME", 6) == 0)
			  {
				 char *str;
				 str = strtok(string, "\"");
				 str = strtok(NULL, "\"");
				 if(str != NULL)
				 {
					 strcpy(&Interfacename[0],str);
				 }

			  }

	}

	if(getIpConf->cmdsu.ipTypeV4V6 == 2)
	{
	 sprintf(gCmdStr, "netsh interface ipv6 show addresses interface=\"%s\"  > c:\\windows\\temp\\getcon.txt",&Interfacename[0]);
	}
	else
	{
	 sprintf(gCmdStr, "netsh interface ip show addresses name=\"%s\"  > c:\\windows\\temp\\getcon.txt",&Interfacename[0]);
	}



	 printf("Executing %s\n",gCmdStr);
	 system(gCmdStr);
     tmpfd = fopen("c:\\windows\\temp\\getcon.txt", "r+");
#else
    sprintf(gCmdStr, "wifi_config -limit %s -all", ifname);
    tmpfd = popen(gCmdStr, "r");
#endif
    if(tmpfd == NULL)
    {
      ipconfigResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
    }
    for(;;)
    {
        if(fgets(string, 256, tmpfd) == NULL)
           break; 

		str = strtok(string, " ");

        /* check dhcp enabled */
        if(strncmp(str, "DHCP", 4) ==0)
        {
            str = strtok(NULL, " ");
            str = strtok(NULL, " ");
			if(strncmp(str, "Yes", 3) ==0)
				ifinfo->isDhcp = 1;
            else
               ifinfo->isDhcp = 0;
        }

        /* find out the ip address */
        if(strncmp(str, "IP", 2) ==0)
        {
            str = strtok(NULL, " ");
            str = strtok(NULL, " ");
			memset(ifinfo->ipaddr,'\0',16);
            if(str != NULL)
            {
			   printf("\nThe IP length %dEnd\n",strlen(str));
			   printf("\nThe IP  %sEnd\n",str);

               strncpy(ifinfo->ipaddr, str, 15);
               ifinfo->ipaddr[strlen(str)-1]='\0';
            }
            else
               strncpy(ifinfo->ipaddr, "none", 15);
        }
		/* ip v6 addresss */
		if(strncmp(str, "Address", 7) ==0)
        {
			ifinfo->ipTypeV6 = 1;
            str = strtok(NULL, " ");
            //str = strtok(NULL, " ");
			memset(ifinfo->ipV6addr,'\0',48);
            if(str != NULL)
            {
			   printf("\nThe IP length %dEnd\n",strlen(str));
			   printf("\nThe IP  %sEnd\n",str);

			   strncpy(ifinfo->ipV6addr, str, strlen(str));
               ifinfo->ipaddr[strlen(str)-1]='\0';
            }
            else
               strncpy(ifinfo->ipaddr, "none", 15);
			break;
        }


        /* check the mask */
        if(strncmp(str, "Subnet", 6) ==0)
        {
            str = strtok(NULL, " ");
            str = strtok(NULL, " ");
            if(str != NULL)
            {
               strcpy(ifinfo->mask, str);
            }
            else
               strcpy(ifinfo->mask, "none");
        }
        /* 
		//find out the dns server ip address 
        if(strncmp(string, "nameserv", 8) == 0)
        {
            char ttstr[16];
            char *ttp = ttstr;
            
            str = strtok_r(string, " ", &ttp);
            if(str != NULL && i < 2)
            {
               strcpy(ifinfo->dns[i], ttp);
               slen = strlen(ifinfo->dns[i]);
               ifinfo->dns[i][slen-1] = '\0';
            }
            else
               strcpy(ifinfo->dns[i], "none");

            i++;
        }
*/

    }
#ifndef _WINDOWS
    pclose(tmpfd);
#else
	fclose(tmpfd);
#endif
#endif

     /*
      * Report back the results
      */
     ipconfigResp->status = STATUS_COMPLETE;
     wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);   

     *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

#if 1
     DPRINT_INFO(WFA_OUT, "%i %i %s %s %s %s %i\n", ipconfigResp->status, 
        ifinfo->isDhcp, ifinfo->ipaddr, ifinfo->mask, 
            ifinfo->dns[0], ifinfo->dns[1], *respLen);
#endif

     fclose(tmpfd);
     return TRUE;
}

/*
 * wfaStaSetIpConfig():
 *   The function is to set the ip configuration to a wireless I/F.
 *   1. IP address
 *   2. Mac address
 *   3. default gateway
 *   4. dns nameserver (pri and sec).  
 */
int wfaStaSetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *setIpConf = (dutCommand_t *)caCmdBuf;
   caStaSetIpConfig_t *ipconfig = &setIpConf->cmdsu.ipconfig;
   dutCmdResponse_t *staSetIpResp = &gGenericResp;
   

#if !defined(_CYGWIN) && !defined(_WINDOWS)
   /*
    * Use command 'ifconfig' to configure the interface ip address, mask.
    * (Linux specific).
    */
   DPRINT_INFO(WFA_OUT, "entering wfaStaSetIpConfig ...\n");
   sprintf(gCmdStr, "/sbin/ifconfig %s %s netmask %s > /dev/null 2>&1 ", ipconfig->intf, ipconfig->ipaddr, ipconfig->mask);
   printf("cmd 1 is %s\n",gCmdStr);
   system(gCmdStr);

   /* use command 'route add' to set set gatewway (linux specific) */ 
   if(ipconfig->defGateway[0] != '\0')
   {
      sprintf(gCmdStr, "/sbin/route add default gw %s > /dev/null 2>&1", ipconfig->defGateway);
      system(gCmdStr);
   }

   /* set dns (linux specific) */
   sprintf(gCmdStr, "cp /etc/resolv.conf /tmp/resolv.conf.bk");
   system(gCmdStr);
   sprintf(gCmdStr, "echo nameserv %s > /etc/resolv.conf", ipconfig->pri_dns);
   system(gCmdStr);
   sprintf(gCmdStr, "echo nameserv %s >> /etc/resolv.conf", ipconfig->sec_dns);
   system(gCmdStr);
#else
	  char ipaddr[256],string[256],Interfacename[64];
      FILE *tmpfd;
	  int i;
     DPRINT_INFO(WFA_OUT, "entering wfaStaSetIpConfig ...\n");
	 Sleep(2000);
	/* 
	sprintf(gCmdStr, "wifi_config -limit %s -getip > c:\\windows\\temp\\getip.txt", gnetIf);
	 printf("Executing %s\n",gCmdStr);
	 system(gCmdStr);
     tmpfd = fopen("c:\\windows\\temp\\getip.txt", "r+");
     if(tmpfd == NULL)
     {
       staSetIpResp->status = STATUS_ERROR;
	   wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);   
       *respLen = WFA_TLV_HDR_LEN + 4;

       DPRINT_ERR(WFA_ERR, "file open failed\n");
       return FALSE;
     }
     if(fgets(string, 256, tmpfd) != NULL)
            sscanf(string,"%s",ipaddr); 
	 printf("\r\n IP is %s\n",ipaddr);
	 fclose(tmpfd);
	 */
    tmpfd = fopen("c:\\wfa\\WfaEndpoint\\Interface.txt", "r");
    if(tmpfd == NULL)
    {
		printf("\n Error opening the interface file \n");
    }
	else
	{
	    for(;;)
	    {
	        if(fgets(string, 256, tmpfd) == NULL)
	           break; 
		}
		fclose(tmpfd);

			if(strncmp(string, "IFNAME", 6) == 0)
			  {
				 char *str;
				 str = strtok(string, "\"");
				 str = strtok(NULL, "\"");
				 if(str != NULL)
				 {
					 strcpy(&Interfacename[0],str);
				 }

			  }

	}
	
	 if(ipconfig->isDhcp == 1)
	 {
		   sprintf(gCmdStr, "netsh interface ip set address name=\"%s\" source=dhcp", &Interfacename[0]);
           //printf("Executing %s\n",gCmdStr);
           system(gCmdStr);
	 }
	 else
	 {
		sprintf(gCmdStr, "netsh interface ip set address name=\"%s\" static %s %s ", &Interfacename[0],ipconfig->ipaddr,ipconfig->mask);
		//printf("Executing %s\n",gCmdStr);
		system(gCmdStr);
		if(ipconfig->pri_dns[0])
		{
			printf("inside netsh \n");
			sprintf(gCmdStr, "netsh interface ip set dns name=\"%s\" static addr=%s", &Interfacename[0],ipconfig->pri_dns);
			//printf("Executing %s\n",gCmdStr);
			system(gCmdStr);
			if(ipconfig->sec_dns)
			{
				sprintf(gCmdStr, "netsh interface ip add dns name=\"%s\" addr=%s", &Interfacename[0],ipconfig->sec_dns);
				//printf("Executing %s\n",gCmdStr);
				system(gCmdStr);
			}
		}
	 }
/*
	 if(strcmp(ipaddr,ipconfig->ipaddr) != 0)
	 {
           //sprintf(gCmdStr, "wifi_config -limit %s -addip -ip %s -mask %s", ipconfig->intf, ipconfig->ipaddr, ipconfig->mask);
		   //sprintf(gCmdStr, "netsh interface ip set address name=%s static addr=%s mask=%s gateway=%s gwmetric=0", ipconfig->intf,ipconfig->ipaddr,ipconfig->mask,ipconfig->defGateway);
		   //sprintf(gCmdStr, "netsh interface ip set address %s static %s %s %s 0", ipconfig->intf,ipconfig->ipaddr,ipconfig->mask,ipconfig->defGateway);
		   sprintf(gCmdStr, "netsh interface ip set address %s static %s %s ", gnetIf,ipconfig->ipaddr,ipconfig->mask);

           printf("Executing %s\n",gCmdStr);
           system(gCmdStr);
		  if(ipconfig->pri_dns[0])
		  {
			printf("inside netsh \n");
			sprintf(gCmdStr, "netsh interface ip set dns %s static addr=%s", gnetIf,ipconfig->pri_dns);
			system(gCmdStr);
   			if(ipconfig->sec_dns)
   			{
   				sprintf(gCmdStr, "netsh interface ip add dns %s addr=%s", gnetIf,ipconfig->sec_dns);
   				system(gCmdStr);
			}
		  }
	 }
	 */
#endif

   /*
    * report status
    */
   staSetIpResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * wfaStaVerifyIpConnection():
 * The function is to verify if the station has IP connection with an AP by
 * send ICMP/pings to the AP.
 */ 
int wfaStaVerifyIpConnection(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *verip = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *verifyIpResp = &gGenericResp;

#ifndef WFA_PING_UDP_ECHO_ONLY
   char strout[64], *pcnt;
   FILE *tmpfile;
   
   DPRINT_INFO(WFA_OUT, "Entering wfaStaVerifyIpConnection ...\n");

   /* set timeout value in case not set */
   if(verip->cmdsu.verifyIp.timeout <= 0)
   {
        verip->cmdsu.verifyIp.timeout = 10;
   }
   
   /* execute the ping command  and pipe the result to a tmp file */
   sprintf(gCmdStr, "ping %s -c 3 -W %u | grep loss | cut -f3 -d, 1>& /tmp/pingout.txt", verip->cmdsu.verifyIp.dipaddr, verip->cmdsu.verifyIp.timeout);
   system(gCmdStr); 

   /* scan/check the output */
   tmpfile = fopen("/tmp/pingout.txt", "r+");
   if(tmpfile == NULL)
   {
      verifyIpResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
   }
   
   verifyIpResp->status = STATUS_COMPLETE;
   if(fscanf(tmpfile, "%s", strout) == EOF)
       verifyIpResp->cmdru.connected = 0;
   else
   {
       pcnt = strtok(strout, "%"); 
       
       /* if the loss rate is 100%, not able to connect */
       if(atoi(pcnt) == 100)
          verifyIpResp->cmdru.connected = 0;
       else
          verifyIpResp->cmdru.connected = 1;
   }

   fclose(tmpfile);
#else
   int btSockfd;
   struct pollfd fds[2];
   int timeout = 2000;
   char anyBuf[64];
   struct sockaddr_in toAddr;
   int done = 1, cnt = 0, ret, nbytes;

   verifyIpResp->status = STATUS_COMPLETE;
   verifyIpResp->cmdru.connected = 0;

   btSockfd = wfaCreateUDPSock("127.0.0.1", WFA_UDP_ECHO_PORT);

   if(btSockfd == -1)
   {
      verifyIpResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;
      return FALSE;;
   }

   toAddr.sin_family = AF_INET;
   toAddr.sin_addr.s_addr = inet_addr(verip->cmdsu.verifyIp.dipaddr);
   toAddr.sin_port = htons(WFA_UDP_ECHO_PORT);

   while(done)
   {
       wfaTrafficSendTo(btSockfd, (char *)anyBuf, 64, (struct sockaddr *)&toAddr);
       cnt++;

       fds[0].fd = btSockfd;
       fds[0].events = POLLIN | POLLOUT; 

       ret = poll(fds, 1, timeout);
       switch(ret)
       {
           case 0:
             /* it is time out, count a packet lost*/
           break;
           case -1:
             /* it is an error */
           default:
           {
              switch(fds[0].revents)
              {
                  case POLLIN:
                  case POLLPRI:
                  case POLLOUT:
                  nbytes = wfaTrafficRecv(btSockfd, (char *)anyBuf, (struct sockaddr *)&toAddr);
                  if(nbytes != 0)
                      verifyIpResp->cmdru.connected = 1;
                      done = 0;
                  break;
                  default:
                  /* errors but not care */
                   ;
              } 
           }
       } 
       if(cnt == 3)
       {
          done = 0;
       }
   }
       
#endif

   wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)verifyIpResp, respBuf);   

   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   
   return TRUE;
}

/*
 * wfaStaGetMacAddress()
 *    This function is to retrieve the MAC address of a wireless I/F.
 */
int wfaStaGetMacAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *getMac = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *getmacResp = &gGenericResp;
    char *str;
    char *ifname = getMac->intf;
	int i;
    FILE *tmpfd;
    char string[128],Interfacename[64];
     char filename[50];

    DPRINT_INFO(WFA_OUT, "Entering wfaStaGetMacAddress ...\n");
#if !defined(_CYGWIN) && !defined(_WINDOWS)
    /*
     * run the script "getipconfig.sh" to find out the mac
     */
    //sprintf(gCmdStr, "getipconfig.sh /tmp/ipconfig.txt %s", ifname); 
    strncpy(filename,"/tmp/ipconfig.txt",20);
    sprintf(gCmdStr, "ifconfig %s > /tmp/ipconfig.txt ", ifname); 
#else
#ifdef _CYGWIN
    strncpy(filename,"/tmp/ipconfig.txt",20);
#else
    strncpy(filename,"c:\\WINDOWS\\TEMP\\ipconfig.txt",40);
#endif

    //sprintf(gCmdStr, "wifi_config -limit %s -mac > %s ", gnetIf,filename); 

		tmpfd = fopen("c:\\wfa\\WfaEndpoint\\Interface.txt", "r");
		if(tmpfile == NULL)
		{
			printf("\n Error opening the interface file \n");
		}
		else
		{
			for(;;)
			{
				if(fgets(string, 256, tmpfd) == NULL)
					break; 
			}
			fclose(tmpfd);

			if(strncmp(string, "IFNAME", 6) == 0)
			  {
				 char *str;
				 str = strtok(string, "\"");
				 str = strtok(NULL, "\"");
				 if(str != NULL)
				 {
					 strcpy(&Interfacename[0],str);
				 }

			  }
		}
		sprintf(gCmdStr, "del /F c:\\WFA\\temp.txt");
       	//printf("Executing %s\n",gCmdStr);

		sprintf(gCmdStr, "netsh wlan show  interface state name=\"%s\" > c:\\WFA\\temp.txt",&Interfacename[0]);
       	//printf("Executing %s\n",gCmdStr);
	   	system(gCmdStr);

		sprintf(gCmdStr, "FOR /F \"tokens=3,4,5,6,7,8 delims=: \" %s IN ('findstr Physical c:\\WFA\\temp.txt') DO @echo %s:%s:%s:%s:%s:%s > c:\\windows\\temp\\ipconfig.txt","%i","%i","%j","%k","%l","%m","%n");
       	//printf("Executing %s\n",gCmdStr);
		system(gCmdStr);

		Sleep(1000);

#endif 

    tmpfd = fopen(filename, "r+");
    if(tmpfd == NULL)
    {
      getmacResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)getmacResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
    }

        if(fgets(string, 256, tmpfd) == NULL)
        {
           getmacResp->status = STATUS_ERROR;
        }
         str = strtok(string, " ");

#ifdef _WINDOWS
        if(str)
        {
			//printf("\nThe MAC address is : %s",str);
			strcpy(getmacResp->cmdru.mac, str);
			getmacResp->status = STATUS_COMPLETE;
		}
		else
		{
			getmacResp->status = STATUS_ERROR;
		}
#else
         while(str && ((strcmp(str,"HWaddr")) != 0))
        {
            str = strtok(NULL, " ");
        }
         
        /* get mac */
        if(str)
            {
          str = strtok(NULL, " ");
          strcpy(getmacResp->cmdru.mac, str);
               getmacResp->status = STATUS_COMPLETE;
    }
 
#endif
 
    wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getmacResp, respBuf);   

    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    fclose(tmpfd);
    return TRUE;
}

/*
 * wfaStaGetStats():
 * The function is to retrieve the statistics of the I/F's layer 2 txFrames, 
 * rxFrames, txMulticast, rxMulticast, fcsErrors/crc, and txRetries.
 * Currently there is not definition how to use these info. 
 */
int wfaStaGetStats(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *statsResp = &gGenericResp;

#if 0  /* this is never used, you can skip this call */
   int s;
   struct ath_stats total;
   const char *ifname = ((dutCommand_t *)caCmdBuf)->intf;
   struct iwreq iwr;
   struct ifreq ifr;
   struct ieee80211req_sta_stats stats;
   const struct ieee80211_nodestats *ns = &stats.is_stats;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaGetStats ...\n");

   /*
    * open a DGRAM socket.
    */
   s = socket(AF_INET, SOCK_DGRAM, 0);
   if (s < 0)
   {
       DPRINT_ERR(WFA_ERR, "socket open");
       statsResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, 4, (BYTE *)statsResp, respBuf);   
       *respLen = WFA_TLV_HDR_LEN + 4;

       return FALSE;
   }

   /*
    * retrieve a HW address by the interface name
    */
   strncpy(ifr.ifr_name, "wifi0", sizeof (ifr.ifr_name));
   if(ioctl(s, SIOCGIFHWADDR, &ifr) < 0)
   {
       DPRINT_ERR(WFA_ERR, "interface not found\n");
       statsResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, 4, (BYTE *)statsResp, respBuf);   
       *respLen = WFA_TLV_HDR_LEN + 4;

       return FALSE;
   }
       
   /* retrive 802.11 hardware stats */ 
   (void) memset(&iwr, 0, sizeof(iwr));
   strncpy(iwr.ifr_name, ifname, sizeof (iwr.ifr_name));
   iwr.u.data.pointer = (void *) &stats;
   iwr.u.data.length = sizeof(stats);
   memcpy(stats.is_u.macaddr, ifr.ifr_hwaddr.sa_data, 8);

   if (ioctl(s, IEEE80211_IOCTL_STA_INFO, &iwr) < 0)
   {
       DPRINT_ERR(WFA_ERR, "unable to get station information");
       statsResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, 4, (BYTE *)statsResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       return FALSE;
   }

   /* retrieve atheros hw stats */
   ifr.ifr_data = (caddr_t) &total;
   if (ioctl(s, SIOCGATHSTATS, &ifr) < 0)
   {
       DPRINT_ERR(WFA_ERR, "error: %s\n", ifr.ifr_name);
       statsResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, 4, (BYTE *)statsResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       return FALSE;
   }

   statsResp->cmdru.ifStats.txFrames =  ns->ns_tx_ucast;
   statsResp->cmdru.ifStats.rxFrames = ns->ns_rx_ucast;
   statsResp->cmdru.ifStats.txMulticast = ns->ns_tx_mcast;
   statsResp->cmdru.ifStats.rxMulticast = ns->ns_rx_mcast;
   statsResp->cmdru.ifStats.txRetries = total.ast_tx_xretries;
   statsResp->cmdru.ifStats.fcsErrors = total.ast_rx_crcerr; 

#endif

   statsResp->status = STATUS_ERROR;
   wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)statsResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


   return TRUE;
}

/*
 * wfaSetEncryption():
 *   The function is to set the wireless interface with WEP or none.
 *
 *   Since WEP is optional test, current function is only used for 
 *   resetting the Security to NONE/Plaintext (OPEN). To test WEP, 
 *   this function should be replaced by the next one (wfaSetEncryption1())
 *
 *   Input parameters: 
 *     1. I/F
 *     2. ssid
 *     3. encpType - wep or none
 *     Optional:
 *     4. key1
 *     5. key2
 *     6. key3
 *     7. key4
 *     8. activeKey Index
 */

int wfaSetEncryption1(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   FILE *file;
#if !defined(_CYGWIN) && !defined(_WINDOWS)  
   
   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set SSID
    */    
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setEncryp->intf, setEncryp->ssid);
   system(gCmdStr);

   /*
    * Tell the supplicant for infrastructure mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setEncryp->intf);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setEncryp->intf);
   system(gCmdStr);
#else
   sprintf(gCmdStr, "wifi_config -limit %s -enable", gnetIf);
   system(gCmdStr);
#ifdef _CYGWIN
file = fopen("/tmp/tmp.xml", "w+");
#else
file = fopen("c:\\windows\\temp\\tmp.xml", "w+");
#endif
  /* we create a file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
    sprintf(gCmdStr,"<?xml version=\"1.0\"?>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<name>%s</name>\n",setEncryp->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<name>%s</name>\n",setEncryp->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionType>ESS</connectionType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<authEncryption>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<authentication>open</authentication>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<encryption>none</encryption>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t <useOneX>false</useOneX>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t</authEncryption>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</WLANProfile>\n");
    fputs(gCmdStr, file);
    /*sprintf(gCmdStr,"\t\t\t<sharedKey>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t<keyType>networkKey</keyType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t<protected>false</protected>\n");
    fputs(gCmdStr, file);*/
  }
  fclose(file);
#ifdef _CYGWIN
   sprintf(gCmdStr, "wifi_config -limit %s -add %s", setEncryp->intf,"c:\\\\cygwin\\\\tmp\\\\tmp.xml");
#else
   sprintf(gCmdStr, "wifi_config -limit %s -add %s", gnetIf,"c:\\\\windows\\\\temp\\\\tmp.xml");
#endif
   printf("Executing %s\n",gCmdStr);
   system(gCmdStr);
#endif
   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 *  Since WEP is optional, this function could be used to replace
 *  wfaSetEncryption() if necessary. 
 */
int wfaSetEncryptionZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   FILE *file;

   sprintf(gCmdStr, "wifi_config -limit %s -enable", gnetIf);
   system(gCmdStr);
#ifdef _CYGWIN
file = fopen("/tmp/tmp.xml", "w+");
#else
file = fopen("c:\\windows\\temp\\tmp.xml", "w+");
#endif
  /* we create a file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
    sprintf(gCmdStr,"<?xml version=\"1.0\"?>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<name>%s</name>\n",setEncryp->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<name>%s</name>\n",setEncryp->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionType>ESS</connectionType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<authEncryption>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<authentication>open</authentication>\n");
    fputs(gCmdStr, file);
   if(setEncryp->encpType == 1)
    sprintf(gCmdStr,"\t\t\t<encryption>WEP</encryption>\n");
   else
    sprintf(gCmdStr,"\t\t\t<encryption>none</encryption>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t <useOneX>false</useOneX>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t</authEncryption>\n");
    fputs(gCmdStr, file);
   if(setEncryp->encpType == 1)
   {
    sprintf(gCmdStr,"\t\t\t\t<sharedKey>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t<keyType>networkKey</keyType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t<protected>false</protected>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t<keyMaterial>%s</keyMaterial>\n",setEncryp->keys[0]);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t</sharedKey>\n");
    fputs(gCmdStr, file);
   }
    sprintf(gCmdStr,"\t\t</security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</WLANProfile>\n");
    fputs(gCmdStr, file);
    /*sprintf(gCmdStr,"\t\t\t<sharedKey>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t<keyType>networkKey</keyType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t<protected>false</protected>\n");
    fputs(gCmdStr, file);*/
  }
  fclose(file);
#ifdef _CYGWIN
   sprintf(gCmdStr, "wifi_config -limit %s -add %s", setEncryp->intf,"c:\\\\cygwin\\\\tmp\\\\tmp.xml");
#else
sprintf(gCmdStr, "wifi_config -limit %s -add %s", gnetIf,"c:\\\\windows\\\\temp\\\\tmp.xml");
#endif
   printf("Executing %s\n",gCmdStr);
   system(gCmdStr);

   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}


int wfaSetEncryptionCiscoSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   FILE *file;
	int ret;
   DPRINT_INFO(WFA_OUT, "Entering wfaSetEncryptionCiscoSupplicant ...\n");

    // stop the service
   	sprintf(gCmdStr, "sc stop \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

	Sleep(5000);
   file = fopen("c:\\windows\\temp\\tmp.xml", "w+");

//   file = fopen("c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\userConfiguration.xml", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
	  CiscoConfigGenerateUpperPart(file);

	/*
    sprintf(gCmdStr,\"<configuration minor_version=\"1\" development_version=\"3\" major_version=\"5" >\n");
    fputs(gCmdStr, file);

    sprintf(gCmdStr,"<UserConfiguration major_version=\"5\" minor_version=\"1\" development_version=\"1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<networks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<group>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<groupName>Local networks</groupName>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<allowUserToSeeScanlist>true</allowUserToSeeScanlist>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<wifiNetwork>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"<displayName>%s</displayName>\n",setEncryp->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<connectionTimeout>40</connectionTimeout>\n");
    fputs(gCmdStr, file);
	
    sprintf(gCmdStr,"<ssid>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<name>%s</name>\n",setEncryp->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</ssid>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<associationTimeout>3</associationTimeout>\n");
    fputs(gCmdStr, file);

	if(setEncryp->encpType == ENCRYPT_WEP)
	{
		sprintf(gCmdStr,"<sharedKeyNetwork>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<userConnection>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<wep>\n");
		fputs(gCmdStr, file);
		printf(" The WEP key Length = %i",strlen(setEncryp->keys[0]));
		printf(" \nThe WEP key  = %s",setEncryp->keys[0]);

		if(strlen(setEncryp->keys[0]) == 10)
		{
			sprintf(gCmdStr,"<keyIs40Bits>\n");
			fputs(gCmdStr, file);
		}
		else
		{
			sprintf(gCmdStr,"<keyIs128Bits>\n");
			fputs(gCmdStr, file);			
		}
		sprintf(gCmdStr,"<keyFromProfile>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<hex encryptContent=\"true\" persistentHandle=\"true\">\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<EncryptedData xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Type=\"http://www.w3.org/2001/04/xmlenc#Content\">\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<CipherData>\n");
		fputs(gCmdStr, file);
		if(strlen(setEncryp->keys[0]) == 10)
		{
			if(strncmp(setEncryp->keys[0], "1234abcdef", 10) == 0 )
			{
				if (strncmp(setEncryp->ssid, "WEP", 3) == 0)
				{
					sprintf(gCmdStr,"<CipherValue>lXzhJYsRhm11bNaOxb2kctjfjFyfMrrQdPKsaKgyK6GMo+um4AjfC9yNFPiyIz5MAotGkofVLE542LIFsqGR9j3s4S+rLaKHFUQ83BXcJZ0zs7+W8e8EfZcais0aKpCeBkHxXjNhWR9UwDmXd73dl+7h9N+ZeKXNfK64l5cq4wwSKO5mwUbDbKoZJot2wbYFSiCvYdxeki7vamP9LF9PIA==</CipherValue>\n");
				}
			}
		}
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</CipherData>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</EncryptedData>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</hex>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</keyFromProfile>\n");
		fputs(gCmdStr, file);
		if(strlen(setEncryp->keys[0]) == 10)
		{
			sprintf(gCmdStr,"</keyIs40Bits>\n");
			fputs(gCmdStr, file);
		}
		else
		{
			sprintf(gCmdStr,"</keyIs128Bits>\n");
			fputs(gCmdStr, file);			
		}
		sprintf(gCmdStr,"<ieee80211Authentication>open</ieee80211Authentication>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</wep>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</userConnection>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</sharedKeyNetwork>\n");
		fputs(gCmdStr, file);
	}
	else
	{
		sprintf(gCmdStr,"<openNetwork>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<userConnection/>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</openNetwork>\n");
		fputs(gCmdStr, file);
	}

    sprintf(gCmdStr,"</wifiNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</group>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</networks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</UserConfiguration>\n");
    fputs(gCmdStr, file);*/

    sprintf(gCmdStr,"\t<networks>\n",gnetIf);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<globalNetworks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<wifiNetwork>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t<displayName>%s</displayName>\n",setEncryp->ssid);
    fputs(gCmdStr, file);    
    sprintf(gCmdStr,"\t\t\t\t<connectionTimeout>40</connectionTimeout>\n");
    fputs(gCmdStr, file);                     
    sprintf(gCmdStr,"\t\t\t\t<ssid>\n");
    fputs(gCmdStr, file);                 
	sprintf(gCmdStr,"\t\t\t\t\t<name>%s</name>\n",setEncryp->ssid);
    fputs(gCmdStr, file);                  
    sprintf(gCmdStr,"\t\t\t\t</ssid>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t\t\t<associationTimeout>3</associationTimeout>\n");
    fputs(gCmdStr, file);                     
    sprintf(gCmdStr,"\t\t\t\t<CCX>\n");
    fputs(gCmdStr, file);                 
    sprintf(gCmdStr,"\t\t\t\t\t<Diagnostics>\n");
    fputs(gCmdStr, file);                
    sprintf(gCmdStr,"\t\t\t\t\t\t<AuthorizedProfile>false</AuthorizedProfile>\n");
    fputs(gCmdStr, file);                 
    sprintf(gCmdStr,"\t\t\t\t\t\t<Channel>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<EnableClientReporting>false</EnableClientReporting>\n");
    fputs(gCmdStr, file);                         
    sprintf(gCmdStr,"\t\t\t\t\t\t</Channel>\n");
    fputs(gCmdStr, file);                            
    sprintf(gCmdStr,"\t\t\t\t\t</Diagnostics>\n");
    fputs(gCmdStr, file);                             
    sprintf(gCmdStr,"\t\t\t\t\t<RadioMeasurement>\n");
    fputs(gCmdStr, file);                         
    sprintf(gCmdStr,"\t\t\t\t\t\t<disabled/>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t\t\t\t</RadioMeasurement>\n");
    fputs(gCmdStr, file);                    
    sprintf(gCmdStr,"\t\t\t\t</CCX>\n");
    fputs(gCmdStr, file);

	// for WEP
	if(setEncryp->encpType == ENCRYPT_WEP)
	{
		sprintf(gCmdStr,"\t\t\t\t<sharedKeyNetwork>\n");
		fputs(gCmdStr, file); 
		sprintf(gCmdStr,"\t\t\t\t\t<userConnection>\n");
		fputs(gCmdStr, file); 
		sprintf(gCmdStr,"\t\t\t\t\t\t<wep>\n");
		fputs(gCmdStr, file); 


		if(strlen(setEncryp->keys[0]) == 10)
		{
			sprintf(gCmdStr,"\t\t\t\t\t\t\t<keyIs40Bits>\n");
			fputs(gCmdStr, file); 
		}
		else
		{
			sprintf(gCmdStr,"\t\t\t\t\t\t\t<keyIs128Bits>\n");
			fputs(gCmdStr, file); 		
		}

		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<keyFromProfile>\n");
		fputs(gCmdStr, file); 
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<hex encryptContent=\"true\" >%s</hex>\n",setEncryp->keys[0]);
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</keyFromProfile>\n");
		fputs(gCmdStr, file);

		if(strlen(setEncryp->keys[0]) == 10)
		{
			sprintf(gCmdStr,"\t\t\t\t\t\t\t</keyIs40Bits>\n");
			fputs(gCmdStr, file); 
		}
		else
		{
			sprintf(gCmdStr,"\t\t\t\t\t\t\t</keyIs128Bits>\n");
			fputs(gCmdStr, file); 		
		}

		sprintf(gCmdStr,"\t\t\t\t\t\t\t<ieee80211Authentication>open</ieee80211Authentication>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"\t\t\t\t\t\t</wep>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"\t\t\t\t\t</userConnection>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"\t\t\t\t</sharedKeyNetwork>\n");
		fputs(gCmdStr, file); 

	}
	else
	{
	//For Open
		sprintf(gCmdStr,"\t\t\t\t<openNetwork>\n");
		fputs(gCmdStr, file);                     
		sprintf(gCmdStr,"\t\t\t\t\t<userConnection/>\n");
		fputs(gCmdStr, file);        
		sprintf(gCmdStr,"\t\t\t\t</openNetwork>\n");
		fputs(gCmdStr, file);
	}


    sprintf(gCmdStr,"\t\t\t</wifiNetwork>\n");
    fputs(gCmdStr, file);                  
    sprintf(gCmdStr,"\t\t</globalNetworks>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t<group>\n");
    fputs(gCmdStr, file);                  
    sprintf(gCmdStr,"\t\t\t<groupName>Default</groupName>\n");
    fputs(gCmdStr, file);             
    sprintf(gCmdStr,"\t\t\t<allowUserToSeeScanlist>true</allowUserToSeeScanlist>\n");
    fputs(gCmdStr, file);    
    sprintf(gCmdStr,"\t\t</group>\n");
    fputs(gCmdStr, file);              
    sprintf(gCmdStr,"\t</networks>\n");
    fputs(gCmdStr, file);
	
	CiscoConfigGenerateLowerPart(file);

  }
  fclose(file);

  // sign the xml file
  sprintf(gCmdStr, "SignProfile.bat c:\\windows\\temp\\tmp.xml c:\\windows\\temp\\tmp1.xml");
	system(gCmdStr);
	Sleep(1000);
  // copy to the destnationfolder
	sprintf(gCmdStr, "copy /Y c:\\windows\\temp\\tmp1.xml \"c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\configuration.xml\"");
	ret=system(gCmdStr);
   //file = fopen("c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\userConfiguration.xml", "w+");
	Sleep(1000);
	printf("Executing %s\n",gCmdStr);
	printf("Return value is %d\n",ret);
  /* start the service */
	sprintf(gCmdStr, "sc start \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

int wfaSetEncryptionMarvell(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   FILE *file;
   char filename[64];
   
   printf("Inside wfaSetEncryptionMarvell fun...\n");

   // stop the service before adding config file

   	sprintf(gCmdStr, "Taskkill /T /F /IM Mrv8000x.exe");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);
	Sleep(1000);

   // Check the file in C:\WFA\MarvellSupplicant
	strcpy(filename,setEncryp->ssid);
	strcat (filename,".cfg");
	printf("The marvell config file is : %s",filename);

	sprintf(gCmdStr, "c:\\WFA\\MarvellSupplicant\\%s",filename);
	file = fopen(gCmdStr,"r");
	if(file==NULL) 
	{
		printf("Error Opening Marvell config file .\n");
		return 1;
	}
	else 
	{
		fclose(file);

		// Copy the file into c:\program files\Marvell CBxxx
   		sprintf(gCmdStr, "copy /Y c:\\WFA\\MarvellSupplicant\\%s \"c:\\Program\ Files\\Marvell\ CB82\\Data.cfg\"",filename);
		system(gCmdStr);
		printf("Executing %s\n",gCmdStr);
	}
	Sleep(3000);
   // Start the service

	sprintf(gCmdStr, " start \"Marvell\" /D \"c:\\Program\ Files\\Marvell\ CB82\" Mrv8000x.exe");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);
	Sleep(3000);

   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

int wfaSetEncryptionWpaSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   FILE *file;
   int i;
   // stop the service before adding config file
   // Seems not required to stop the service as
   // the config file is loaded once when it starts

#ifdef _CYGWIN
   file = fopen("C:/WFA/WpaSupplicant/wpa_supplicant.conf", "w+");
#else
file = fopen("c:\\WFA\\WpaSupplicant\\wpa_supplicant.conf", "w+");
#endif
  /* we create a file for reading and writing */

  printf("Inside SetEncryptionWpaSupplicant fun...\n");

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
    sprintf(gCmdStr,"ctrl_interface=\\Device\\NPF_%s\n",gnetIf);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"ap_scan=2\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"network={\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\tssid=\"%s\"\n",setEncryp->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\tkey_mgmt=NONE\n");
    fputs(gCmdStr, file);

	// TBD: It works for HEX keys only

	if(setEncryp->encpType == ENCRYPT_WEP)
	{
	  for(i=0; i<4; i++)
	  {
		 if(setEncryp->keys[i][0] != '\0')
		 {
			 sprintf(gCmdStr, "\twep_key%i=%s\n",i,setEncryp->keys[i]);
			 fputs(gCmdStr, file);
		 }
	  }

	  /* set active key */
	  i = setEncryp->activeKeyIdx;
	  if(setEncryp->keys[i][0] != '\0')
	  {
		  sprintf(gCmdStr, "\twep_tx_keyidx=%i\n",setEncryp->activeKeyIdx);
		  fputs(gCmdStr, file);
	  }
	}
	sprintf(gCmdStr,"}\n");
    fputs(gCmdStr, file);
  }
  fclose(file);

	sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

	sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);


   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}
int wfaSetEncryption(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;

#if !defined(_CYGWIN) && !defined(_WINDOWS)
   int i;

   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set SSID
    */    
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setEncryp->intf, setEncryp->ssid);
   system(gCmdStr);

   /*
    * Tell the supplicant for infrastructure mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setEncryp->intf);
   system(gCmdStr);

   /* set keys */
   if(setEncryp->encpType == 1)
   {
      for(i=0; i<4; i++)
      {
         if(setEncryp->keys[i][0] != '\0')
         {
             sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i %s",
                   setEncryp->intf, i, setEncryp->keys[i]);
             system(gCmdStr);
         }
      }

      /* set active key */
      i = setEncryp->activeKeyIdx;
      if(setEncryp->keys[i][0] != '\0')
      {
          sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_tx_keyidx %i",
            setEncryp->intf, setEncryp->activeKeyIdx);
          system(gCmdStr);
      }
   }
   else /* clearly remove the keys -- reported by p.schwann */
   {
      for(i = 0; i < 4; i++)
      {
          sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i \"\"", setEncryp->intf, i);
          system(gCmdStr);
      }
   }

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setEncryp->intf);
   system(gCmdStr);

#else
   switch(geSupplicant)
   {
	   case eWindowsZeroConfig:
		   wfaSetEncryptionZeroConfig(len,caCmdBuf,respLen,respBuf);			
		   break;
	   case eMarvell:
		   wfaSetEncryptionMarvell(len,caCmdBuf,respLen,respBuf);	
		   break;
	   case eWpaSupplicant:
		   wfaSetEncryptionWpaSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eCiscoSecureClient:
		   wfaSetEncryptionCiscoSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eOpen1x:
		   break;
	   default:
		   setEncrypResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;
		   break;
   }

#endif
   return TRUE;
}


/*
 * wfaStaSetEapTLSZeroConfig(): For ZeroConfig
 *   This is to set
 *   1. ssid
 *   2. encrypType - tkip or aes-ccmp
 *   3. keyManagementType - wpa or wpa2
 *   4. trustedRootCA
 *   5. clientCertificate
 *  The path for the certificate thumbprint file is c:\WFA\Sigma\Certificates\<username>.txt
 */
int wfaStaSetEapTLSZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
   char *ifname = setTLS->intf;
   dutCmdResponse_t *setEapTlsResp = &gGenericResp;
   FILE *file;
   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapTLS ...\n");

   sprintf(gCmdStr, "wifi_config -limit %s -enable", gnetIf);
   system(gCmdStr);
#ifdef _CYGWIN
   file = fopen("/tmp/tmp.xml", "w+");
#else
file = fopen("c:\\windows\\temp\\tmp.xml", "w+");
#endif
 /* we create a file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
    sprintf(gCmdStr,"<?xml version=\"1.0\"?>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<name>%s</name>\n",setTLS->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<name>%s</name>\n",setTLS->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<nonBroadcast>false</nonBroadcast>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionType>ESS</connectionType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<authEncryption>\n");
    fputs(gCmdStr, file);

	if((strcmp(setTLS->keyMgmtType, "WPA2") == 0) || (strcmp(setTLS->keyMgmtType, "wpa2") == 0))
	{
    	sprintf(gCmdStr,"\t\t\t\t<authentication>WPA2</authentication>\n");
    	fputs(gCmdStr, file);
    	sprintf(gCmdStr,"\t\t\t\t<encryption>AES</encryption>\n");
    	fputs(gCmdStr, file);

	}
	else if((strcmp(setTLS->keyMgmtType, "WPA") == 0) || (strcmp(setTLS->keyMgmtType, "wpa") == 0))
	{
    	sprintf(gCmdStr,"\t\t\t\t<authentication>WPA</authentication>\n");
    	fputs(gCmdStr, file);
    	sprintf(gCmdStr,"\t\t\t\t<encryption>TKIP</encryption>\n");
    	fputs(gCmdStr, file);

	}

	
//	if((strcmp(setTLS->encrptype, "TKIP") == 0) || (strcmp(setTLS->encrptype, "tkip") == 0))
//	{
  //  	sprintf(gCmdStr,"\t\t\t\t<encryption>TKIP</encryption>\n");
    //	fputs(gCmdStr, file);
//	}
//	else if((strcmp(setTLS->encrptype, "AES-CCMP") == 0) || (strcmp(setTLS->encrptype, "aes-ccmp") == 0))
//	{
//    	sprintf(gCmdStr,"\t\t\t\t<encryption>AES</encryption>\n");
  //  	fputs(gCmdStr, file);
//	}

    sprintf(gCmdStr,"\t\t\t\t<useOneX>true</useOneX>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t</authEncryption>\n");
    fputs(gCmdStr, file);

    sprintf(gCmdStr,"\t\t\t<OneX xmlns=\"http://www.microsoft.com/networking/OneX/v1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t<EAPConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t<EapHostConfig xmlns=\"http://www.microsoft.com/provisioning/EapHostConfig\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t<EapMethod>\n");
    fputs(gCmdStr, file);

    sprintf(gCmdStr,"\t\t\t\t\t\t\t<Type xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">13</Type>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<VendorId xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</VendorId>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<VendorType xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</VendorType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<AuthorId xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</AuthorId>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t</EapMethod>\n");
    fputs(gCmdStr, file);

#ifdef _CYGWIN
	file = fopen("c:\\WFA\\Sigma\\Certificates\\%s.txt", "r");
#else
	//sprintf(gCmdStr,"c:\\WFA\\Sigma\\Certificates\\%s.txt",setTLS->clientCertificate);
	//certFile = fopen(gCmdStr,"r");
#endif
//	fgets(string, 256, certFile);
//	fclose(tmpfd);
//    sprintf(gCmdStr,"\t\t\t\t\t\t<ConfigBlob>020000002A0000001500000014000000%s000001000000</ConfigBlob>\n",string);

//    sprintf(gCmdStr,"\t\t\t\t\t\t<ConfigBlob>020000002A0000001500000014000000742C3192E607E424EB4549542BE1BBC53E6174E2000001000000</ConfigBlob>\n");
  // WORKING ON VISTA.. FOR wpa2 - tls  
    sprintf(gCmdStr,"\t\t\t\t\t\t<ConfigBlob>020000002A00000007000000000000000000000000000000000000000000000000000000000000000000</ConfigBlob>\n");
	fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t</EapHostConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t</EAPConfig>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t</OneX>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</WLANProfile>\n");
    fputs(gCmdStr, file);

  }
  fclose(file);
#ifdef _CYGWIN
   sprintf(gCmdStr, "wifi_config -limit %s -add %s", setTLS->intf,"c:\\\\cygwin\\\\tmp\\\\tmp.xml");
#else
   sprintf(gCmdStr, "wifi_config -limit %s -add %s", gnetIf,"c:\\\\windows\\\\temp\\\\tmp.xml");
#endif
   printf("Executing %s\n",gCmdStr);
   system(gCmdStr);


   setEapTlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

int wfaStaSetEapTLSCiscoSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
   char *ifname = setTLS->intf;
   dutCmdResponse_t *setEapTlsResp = &gGenericResp;
   FILE *file;
   	int ret;
   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapTLSCiscoSupplicant ...\n");

    // stop the service
   	sprintf(gCmdStr, "sc stop \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

	file = fopen("c:\\windows\\temp\\tmp.xml", "w+");
   //file = fopen("c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\userConfiguration.xml", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {    
/*
    sprintf(gCmdStr,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<UserConfiguration major_version=\"5\" minor_version=\"1\" development_version=\"1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<networks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<group>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<groupName>Local networks</groupName>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<allowUserToSeeScanlist>true</allowUserToSeeScanlist>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<wifiNetwork>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"<displayName>%s</displayName>\n",setTLS->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<connectionTimeout>40</connectionTimeout>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<ssid>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<name>%s</name>\n",setTLS->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</ssid>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<associationTimeout>3</associationTimeout>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<authenticationNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<userAuthentication>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<collectionBehavior>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<withCertificate>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<cacheCertificateFromUser>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<forever/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</cacheCertificateFromUser>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<allowedCertSourceFromUser>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<smartCardOrOsCertificate/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<cachePinForSmartcard>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<never/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</cachePinForSmartcard>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</allowedCertSourceFromUser>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</withCertificate>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</collectionBehavior>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<authenticationMethod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<eapTls>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<doNotValidateServerCertificate/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<unprotectedIdentityPattern encryptContent=\"true\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<EncryptedData xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Type=\"http://www.w3.org/2001/04/xmlenc#Content\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<CipherData>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<CipherValue>J+Lk109O2trE3e47aTdT1GE9z5l4OUARwyAbW6FWoqc=</CipherValue>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</CipherData>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</EncryptedData>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</unprotectedIdentityPattern>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<enableFastReconnect>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<alwaysAttempt/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</enableFastReconnect>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<certificateSource>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<certificateFromUser/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</certificateSource>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</eapTls>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</authenticationMethod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</userAuthentication>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<setting802.1x>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<authPeriod>30</authPeriod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<heldPeriod>60</heldPeriod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<startPeriod>30</startPeriod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<maxStart>3</maxStart>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</setting802.1x>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<associationMode>\n");
    fputs(gCmdStr, file);
	if(strncmp(setTLS->keyMgmtType, "wpa2", 4) == 0)
	{
		sprintf(gCmdStr,"<wpa2>\n");
		fputs(gCmdStr, file);
	}
	else if (strncmp(setTLS->keyMgmtType, "wpa", 3) == 0)
	{
		sprintf(gCmdStr,"<wpa>\n");
		fputs(gCmdStr, file);
	}
	if((strcmp(setTLS->encrptype, "TKIP") == 0) || (strcmp(setTLS->encrptype, "tkip") == 0))
	{
		sprintf(gCmdStr,"<encryption>TKIP</encryption>\n");
		fputs(gCmdStr, file);
	}
	else if((strcmp(setTLS->encrptype, "AES-CCMP") == 0) || (strcmp(setTLS->encrptype, "aes-ccmp") == 0))
	{
		sprintf(gCmdStr,"<encryption>AES</encryption>\n");
		fputs(gCmdStr, file);
	}
	if(strncmp(setTLS->keyMgmtType, "wpa2", 4) == 0)
	{
		sprintf(gCmdStr,"</wpa2>\n");
		fputs(gCmdStr, file);
	}
	else if (strncmp(setTLS->keyMgmtType, "wpa", 3) == 0)
	{
		sprintf(gCmdStr,"</wpa>\n");
		fputs(gCmdStr, file);
	}
    sprintf(gCmdStr,"</associationMode>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</authenticationNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</wifiNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</group>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</networks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</UserConfiguration>\n");
    fputs(gCmdStr, file);

	
	*/
	CiscoConfigGenerateUpperPart(file);
	CiscoEAPConfigGenerateUpperPart(file,&(setTLS->ssid[0]));

    sprintf(gCmdStr,"\t\t\t\t\t\t<authenticationMethod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<eapTls>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<doNotValidateServerCertificate/>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<unprotectedIdentityPattern encryptContent=\"true\" >[username]</unprotectedIdentityPattern>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<enableFastReconnect>\n");
    fputs(gCmdStr, file);     
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<alwaysAttempt/>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</enableFastReconnect>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<certificateSource>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<certificateFromUser/>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</certificateSource>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t</eapTls>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t</authenticationMethod>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t<collectionBehavior>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t<withCertificate>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<cacheCertificateFromUser>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<forever/>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</cacheCertificateFromUser>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<allowedCertSourceFromUser>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<smartCardOrOsCertificate/>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<cachePinForSmartcard>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t<never/>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t</cachePinForSmartcard>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</allowedCertSourceFromUser>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t</withCertificate>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t</collectionBehavior>\n");
    fputs(gCmdStr, file);

	CiscoEAPConfigGenerateLowerPart(file,setTLS->encrptype,setTLS->keyMgmtType);
	CiscoConfigGenerateLowerPart(file);
  }
  fclose(file);

  // sign the xml file
  sprintf(gCmdStr, "SignProfile.bat c:\\windows\\temp\\tmp.xml c:\\windows\\temp\\tmp1.xml");
	system(gCmdStr);
	Sleep(1000);
  // copy to the destnationfolder
	sprintf(gCmdStr, "copy /Y c:\\windows\\temp\\tmp1.xml \"c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\configuration.xml\"");
	ret=system(gCmdStr);
	Sleep(1000);
		printf("Executing %s\n",gCmdStr);
	printf("Return value is %d\n",ret);
  /* start the service */


	sprintf(gCmdStr, "sc start \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);


   setEapTlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE; 
}




int wfaStaSetEapTLSWpaSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
   char *ifname = setTLS->intf;
   dutCmdResponse_t *setEapTlsResp = &gGenericResp;
   FILE *file;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapTLSWpaSupplicant ...\n");



   file = fopen("c:\\WFA\\WpaSupplicant\\wpa_supplicant.conf", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {    
	  sprintf(gCmdStr,"ctrl_interface=\\Device\\NPF_%s\n",gnetIf);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"ap_scan=2\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"network={\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tssid=\"%s\"\n",setTLS->ssid);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tkey_mgmt=WPA-EAP\n");
	  fputs(gCmdStr, file);

	  if(strncmp(setTLS->keyMgmtType, "wpa2", 4) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA2\n");
		  fputs(gCmdStr, file);
	//	  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		//  fputs(gCmdStr, file);
	  } else if (strncmp(setTLS->keyMgmtType, "wpa", 3) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA\n");
		  fputs(gCmdStr, file);
//		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
//		  fputs(gCmdStr, file);
	  }

	  if((strncmp(setTLS->encrptype, "TKIP",4) == 0) || (strncmp(setTLS->encrptype, "tkip",4) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
		  fputs(gCmdStr, file);
	  }
	  else if((strncmp(setTLS->encrptype, "AES-CCMP",8) == 0) || (strncmp(setTLS->encrptype, "aes-ccmp",8) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		  fputs(gCmdStr, file);
	  }

	  sprintf(gCmdStr,"\teap=TLS\n");
	  fputs(gCmdStr, file);

// For WAP2 Test Plan 

	  sprintf(gCmdStr,"\tca_cert=\"%s.pem\"\n",setTLS->trustedRootCA);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tidentity=\"wifi-user\"\n");
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tprivate_key=\"%s.pem\"\n",setTLS->clientCertificate);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tclient_cert=\"%s.pem\"\n",setTLS->clientCertificate);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"}\n");
  	  fputs(gCmdStr, file);
  }
  fclose(file);

  /* start the service and stop the service */

	sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

	sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

  printf("Executing %s\n",gCmdStr);
   system(gCmdStr);

   setEapTlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE; 
}


/*
 * wfaStaSetEapTLS():
 *   This is to set
 *   1. ssid
 *   2. encrypType - tkip or aes-ccmp
 *   3. keyManagementType - wpa or wpa2
 *   4. trustedRootCA
 *   5. clientCertificate
 */
int wfaStaSetEapTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
   char *ifname = setTLS->intf;
   dutCmdResponse_t *setEapTlsResp = &gGenericResp;
   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapTLS ...\n");
#if !defined(_CYGWIN) && !defined(_WINDOWS)
   /*
    * need to store the trustedROOTCA and clientCertificate into a file first.
    */
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   system(gCmdStr);

   /* ssid */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setTLS->ssid);
   system(gCmdStr);

   /* key management */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   system(gCmdStr);

   /* protocol WPA */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap TLS", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s\"'", ifname, setTLS->trustedRootCA);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"wifi-user@wifilabs.local\"'", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 private_key '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTLS->clientCertificate);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 private_key_passwd '\"wifi\"'", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   system(gCmdStr);

   setEapTlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

#else 
   switch(geSupplicant)
   {
	   case eWindowsZeroConfig:
		   wfaStaSetEapTLSZeroConfig(len,caCmdBuf,respLen,respBuf);			
		   break;
	   case eMarvell:
		   break;
	   case eWpaSupplicant:
		   wfaStaSetEapTLSWpaSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eCiscoSecureClient:
		   wfaStaSetEapTLSCiscoSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eOpen1x:
		   break;
	   default:
		   setEapTlsResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;
		   break;
   }

#endif
   return TRUE;
}

int wfaStaSetPSKCiscoSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
   dutCmdResponse_t *setPskResp = &gGenericResp;
	int ret;
   FILE *file;   
   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetPSKCiscoSupplicant ...\n");

   // stop the service
   	sprintf(gCmdStr, "sc stop \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

	Sleep(5000);
	file = fopen("c:\\windows\\temp\\tmp.xml", "w+");

   //file = fopen("c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\userConfiguration.xml", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {    
	CiscoConfigGenerateUpperPart(file);
/*	
    sprintf(gCmdStr,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    fputs(gCmdStr, file);

    sprintf(gCmdStr,"<UserConfiguration major_version=\"5\" minor_version=\"1\" development_version=\"1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<networks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<group>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<groupName>Local networks</groupName>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<allowUserToSeeScanlist>true</allowUserToSeeScanlist>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<wifiNetwork>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"<displayName>%s</displayName>\n",setPSK->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<connectionTimeout>40</connectionTimeout>\n");
    fputs(gCmdStr, file);
	
    sprintf(gCmdStr,"<ssid>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<name>%s</name>\n",setPSK->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</ssid>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<associationTimeout>3</associationTimeout>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<sharedKeyNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<userConnection>\n");
    fputs(gCmdStr, file);
	if(strncmp(setPSK->keyMgmtType, "wpa2", 4) == 0)
	{
		sprintf(gCmdStr,"<wpa2>\n");
		fputs(gCmdStr, file);
	}
	else if (strncmp(setPSK->keyMgmtType, "wpa", 3) == 0)
	{
		sprintf(gCmdStr,"<wpa>\n");
		fputs(gCmdStr, file);
	}
    sprintf(gCmdStr,"<keyFromProfile>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<ascii encryptContent=\"true\" persistentHandle=\"true\">\n");
    fputs(gCmdStr, file);	
    sprintf(gCmdStr,"<EncryptedData xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Type=\"http://www.w3.org/2001/04/xmlenc#Content\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<CipherData>\n");
    fputs(gCmdStr, file);
	// cipher changes for each ssid+key combination
	// Hardcodinig according to test plan currently
	printf(" \nthe Passphrase : %s",setPSK->passphrase);

	if(strncmp(setPSK->passphrase, "12345678", 8) == 0 )
	{
		if (strncmp(setPSK->ssid, "WPA2", 4) == 0)
		{
			sprintf(gCmdStr,"<CipherValue>fbiAbLFtPMBwpWJLP6tUs+yNdKUdELj783nf+V99lcXJwyfUuDutrYLfJjb3eyMrcWz0rdKeStz6DzADAezDhUL0DiN6dSVZFABQJw8gG1y3qqFWFoh8RAmguA9ce4xP</CipherValue>\n");
		}
		else if(strncmp(setPSK->ssid, "Roaming", 7) == 0)
		{
			sprintf(gCmdStr,"<CipherValue>Nxpv0XrgyZ2k6V3pXnA+sN3k628V+lHBvOyHSHpOByVX1EF7NyqqV2BiIisUnIycf4pvwZt7cjPoyHZOe5Kv+cNdaDpeOrOtrjyoYtndCudraP7lM95p+s49LJa9Khhx6nBr1ZhpH7uGF6/V//ql1w==</CipherValue>\n");
		}
		else if(strncmp(setPSK->ssid, "Multicast", 9) == 0)
		{
			sprintf(gCmdStr,"<CipherValue>JPo6L8wqmhMuBrxHmJH76Fw6qcWLmlPxkO0ouwgkiWq5ws8wQWpnFWtXtTYw2FxBa8jZjmXyMMZGmxWgA8HQ4xX0IoxcevYHBitw6b4Q1mY1QbSRWYE7UFRkQFt8HwAfNNEMDEnG93bJSa+XjX7X6w==</CipherValue>\n");
		}
		else if(strncmp(setPSK->ssid, "Negative", 8) == 0)
		{
			sprintf(gCmdStr,"<CipherValue>BnPPEEsaa6iTb21IeR/Jw2EpSw0mjl5ITXSstbng/dUZKIKJNvr8pfjWAJczzFEtE8hMXkOjD3l2ws/z64Z9cHZHgxvB+3Egg28Y0222Xxfl8Y4HWp15KBBQKXY3WxeNczNAU0dgyWnhhZq/9tmAWg==</CipherValue>\n");
		}

	}
	else if(strncmp(setPSK->passphrase, "1234abcdef", 10) == 0 )
	{

		if(strncmp(setPSK->ssid, "WEP", 3) == 0)
		{
			sprintf(gCmdStr,"<CipherValue>MQFmSt81WGBXpUqk3T7tVUJUZpDrV3fWaOFLSs6dyoe8zLECBaFQg8u5rHNp42WQMxWQp74ecK1WAi5h4tm41w94yHyOeyTJtf79o6y05lZ0mzXvj65GgwzoVbkQfBMmQCnhlXkj2mF1hz+bbyLDpQ==</CipherValue>\n");
		}
	}
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</CipherData>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</EncryptedData>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</ascii>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</keyFromProfile>\n");
    fputs(gCmdStr, file);

//	if((strcmp(setPSK->encpType, "TKIP") == 0) || (strcmp(setPSK->encpType, "tkip") == 0))
	if(setPSK->encpType == ENCRYPT_TKIP )
	{
		sprintf(gCmdStr,"<encryption>TKIP</encryption>\n");
		fputs(gCmdStr, file);
	}
	
	else if(setPSK->encpType == ENCRYPT_AESCCMP )
//	else if((strcmp(setPSK->encpType, "AES-CCMP") == 0) || (strcmp(setPSK->encpType, "aes-ccmp") == 0))
	{
		sprintf(gCmdStr,"<encryption>AES</encryption>\n");
		fputs(gCmdStr, file);
	}

	if(strncmp(setPSK->keyMgmtType, "wpa2", 4) == 0)
	{
		sprintf(gCmdStr,"</wpa2>\n");
		fputs(gCmdStr, file);
	}
	else if (strncmp(setPSK->keyMgmtType, "wpa", 3) == 0)
	{
		sprintf(gCmdStr,"</wpa>\n");
		fputs(gCmdStr, file);
	}
    sprintf(gCmdStr,"</userConnection>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</sharedKeyNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</wifiNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</group>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</networks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</UserConfiguration>\n");
    fputs(gCmdStr, file);
*/

    sprintf(gCmdStr,"\t<networks>\n",gnetIf);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<globalNetworks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<wifiNetwork>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t<displayName>%s</displayName>\n",setPSK->ssid);
    fputs(gCmdStr, file);    
    sprintf(gCmdStr,"\t\t\t\t<connectionTimeout>40</connectionTimeout>\n");
    fputs(gCmdStr, file);                     
    sprintf(gCmdStr,"\t\t\t\t<ssid>\n");
    fputs(gCmdStr, file);                 
	sprintf(gCmdStr,"\t\t\t\t\t<name>%s</name>\n",setPSK->ssid);
    fputs(gCmdStr, file);                  
    sprintf(gCmdStr,"\t\t\t\t</ssid>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t\t\t<associationTimeout>3</associationTimeout>\n");
    fputs(gCmdStr, file);                     
    sprintf(gCmdStr,"\t\t\t\t<CCX>\n");
    fputs(gCmdStr, file);                 
    sprintf(gCmdStr,"\t\t\t\t\t<Diagnostics>\n");
    fputs(gCmdStr, file);                
    sprintf(gCmdStr,"\t\t\t\t\t\t<AuthorizedProfile>false</AuthorizedProfile>\n");
    fputs(gCmdStr, file);                 
    sprintf(gCmdStr,"\t\t\t\t\t\t<Channel>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<EnableClientReporting>false</EnableClientReporting>\n");
    fputs(gCmdStr, file);                         
    sprintf(gCmdStr,"\t\t\t\t\t\t</Channel>\n");
    fputs(gCmdStr, file);                            
    sprintf(gCmdStr,"\t\t\t\t\t</Diagnostics>\n");
    fputs(gCmdStr, file);                             
    sprintf(gCmdStr,"\t\t\t\t\t<RadioMeasurement>\n");
    fputs(gCmdStr, file);                         
    sprintf(gCmdStr,"\t\t\t\t\t\t<disabled/>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t\t\t\t</RadioMeasurement>\n");
    fputs(gCmdStr, file);                    
    sprintf(gCmdStr,"\t\t\t\t</CCX>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t<sharedKeyNetwork>\n");
	fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t<userConnection>\n");
	fputs(gCmdStr, file); 

	if(strncmp(setPSK->keyMgmtType, "wpa2", 4) == 0)
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t<wpa2>\n");
		fputs(gCmdStr, file);
	}
	else if(strncmp(setPSK->keyMgmtType, "wpa", 3) == 0)
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t<wpa>\n");
		fputs(gCmdStr, file);
	}
	sprintf(gCmdStr,"\t\t\t\t\t\t\t<keyFromProfile>\n");
	fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<ascii encryptContent=\"true\" >%s</ascii>\n",setPSK->passphrase);
	fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t</keyFromProfile>\n");
	fputs(gCmdStr, file);

	if(setPSK->encpType == ENCRYPT_AESCCMP )
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t\t<encryption>AES</encryption>\n");
		fputs(gCmdStr, file);
	}
	else if (setPSK->encpType == ENCRYPT_TKIP )
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t\t<encryption>TKIP</encryption>\n");
		fputs(gCmdStr, file);
	}
	if(strncmp(setPSK->keyMgmtType, "wpa2", 4) == 0)
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t</wpa2>\n");
		fputs(gCmdStr, file);
	}
	else if(strncmp(setPSK->keyMgmtType, "wpa", 3) == 0)
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t</wpa>\n");
		fputs(gCmdStr, file);
	}
	sprintf(gCmdStr,"\t\t\t\t\t</userConnection>\n");
	fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t</sharedKeyNetwork>\n");
	fputs(gCmdStr, file); 
    sprintf(gCmdStr,"\t\t\t</wifiNetwork>\n");
    fputs(gCmdStr, file);                  
    sprintf(gCmdStr,"\t\t</globalNetworks>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t<group>\n");
    fputs(gCmdStr, file);                  
    sprintf(gCmdStr,"\t\t\t<groupName>Default</groupName>\n");
    fputs(gCmdStr, file);             
    sprintf(gCmdStr,"\t\t\t<allowUserToSeeScanlist>true</allowUserToSeeScanlist>\n");
    fputs(gCmdStr, file);    
    sprintf(gCmdStr,"\t\t</group>\n");
    fputs(gCmdStr, file);              
    sprintf(gCmdStr,"\t</networks>\n");
    fputs(gCmdStr, file);
	
	CiscoConfigGenerateLowerPart(file);
  }
  fclose(file);
  // sign the xml file
  sprintf(gCmdStr, "SignProfile.bat c:\\windows\\temp\\tmp.xml c:\\windows\\temp\\tmp1.xml");
	ret = system(gCmdStr);
	Sleep(2000);
	printf("Return value is %d\n",ret);
  // copy to the destnationfolder
	sprintf(gCmdStr, "copy /Y c:\\windows\\temp\\tmp1.xml \"c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\configuration.xml\"");
	ret = system(gCmdStr);
	printf("Executing %s\n",gCmdStr);
	printf("Return value is %d\n",ret);

	Sleep(4000);
  /* start the service */
	sprintf(gCmdStr, "sc start \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);


   setPskResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE; 
}



/*
 * The function is to set 
 *   1. ssid
 *   2. passPhrase
 *   3. keyMangementType - wpa/wpa2
 *   4. encrypType - tkip or aes-ccmp
 * Using Windows WpaSupplicant supplicant  
 * 
 */
int wfaStaSetPSKWpaSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
   dutCmdResponse_t *setPskResp = &gGenericResp;

   FILE *file;   
   file = fopen("c:\\WFA\\WpaSupplicant\\wpa_supplicant.conf", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {    
	  sprintf(gCmdStr,"ctrl_interface=\\Device\\NPF_%s\n",gnetIf);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"ap_scan=2\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"network={\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tssid=\"%s\"\n",setPSK->ssid);
	  fputs(gCmdStr, file);

	  if(strncmp(setPSK->keyMgmtType, "wpa2", 4) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=RSN\n");
		  fputs(gCmdStr, file);
	  } else if (strncmp(setPSK->keyMgmtType, "wpa", 3) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA\n");
		  fputs(gCmdStr, file);
	  }

	  if(setPSK->encpType == ENCRYPT_TKIP)
	  {
		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
		  fputs(gCmdStr, file);
	  }
	  else if(setPSK->encpType == ENCRYPT_AESCCMP)
	  {
		  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		  fputs(gCmdStr, file);
	  }

	  sprintf(gCmdStr,"\tkey_mgmt=WPA-PSK\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tpsk=\"%s\"\n",setPSK->passphrase);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"}\n");
  	  fputs(gCmdStr, file);
  }
  fclose(file);

  /* start the service and stop the service */

	sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

	sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);



  printf("Executing %s\n",gCmdStr);
   system(gCmdStr);

   setPskResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE; 
}


/*
 * The function is to set 
 *   1. ssid
 *   2. passPhrase
 *   3. keyMangementType - wpa/wpa2
 *   4. encrypType - tkip or aes-ccmp
 */
int wfaStaSetPSKZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
   dutCmdResponse_t *setPskResp = &gGenericResp;

   FILE *file,*tmpfd;
   char string[256],Interfacename[64];
   int i;
//   sprintf(gCmdStr, "wifi_config -limit %s -enable", gnetIf);
//   system(gCmdStr);

   sprintf(gCmdStr, "del /F c:\\WFA\\tmp.xml");
   system(gCmdStr);

#ifdef _CYGWIN
file = fopen("/tmp/tmp.xml", "w+");
#else
file = fopen("c:\\WFA\\tmp.xml", "w+");
#endif
  /* we create a file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
    sprintf(gCmdStr,"<?xml version=\"1.0\"?>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<name>%s</name>\n",setPSK->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<name>%s</name>\n",setPSK->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionType>ESS</connectionType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<authEncryption>\n");
    fputs(gCmdStr, file);
   if(setPSK->encpType == ENCRYPT_TKIP)
    {
    	sprintf(gCmdStr,"\t\t\t<authentication>WPAPSK</authentication>\n");
    	fputs(gCmdStr, file);
    	sprintf(gCmdStr,"\t\t\t<encryption>TKIP</encryption>\n");
    	fputs(gCmdStr, file);
    }
   else if(setPSK->encpType == ENCRYPT_AESCCMP)
    {
    	sprintf(gCmdStr,"\t\t\t<authentication>WPA2PSK</authentication>\n");
    	fputs(gCmdStr, file);
    	sprintf(gCmdStr,"\t\t\t<encryption>AES</encryption>\n");
    	fputs(gCmdStr, file);
    }
    sprintf(gCmdStr,"\t\t\t <useOneX>false</useOneX>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t</authEncryption>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t<sharedKey>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t<keyType>passPhrase</keyType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t<protected>false</protected>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t<keyMaterial>%s</keyMaterial>\n",setPSK->passphrase);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t</sharedKey>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</WLANProfile>\n");
    fputs(gCmdStr, file);
  }
  fclose(file);
#ifdef _CYGWIN
   sprintf(gCmdStr, "wifi_config -limit %s -add %s", setPSK->intf,"c:\\\\cygwin\\\\tmp\\\\tmp.xml");
#else
//   sprintf(gCmdStr, "wifi_config -limit %s -add %s", gnetIf,"c:\\\\windows\\\\temp\\\\tmp.xml");
     tmpfd = fopen("c:\\wfa\\WfaEndpoint\\Interface.txt", "r");
    if(tmpfd == NULL)
    {
		printf("\n Error opening the interface file \n");
    }
	else
	{
	    for(;;)
	    {
	        if(fgets(string, 256, tmpfd) == NULL)
	           break; 
		}
		fclose(tmpfd);

			if(strncmp(string, "IFNAME", 6) == 0)
			  {
				 char *str;
				 str = strtok(string, "\"");
				 str = strtok(NULL, "\"");
				 if(str != NULL)
				 {
					 strcpy(&Interfacename[0],str);
				 }

			  }

	}

   sprintf(gCmdStr, "netsh wlan add profile filename=\"%s\" interface=\"%s\" user=all","c:\\WFA\\tmp.xml",&Interfacename[0]);
#endif
   //printf("Executing %s\n",gCmdStr);
   system(gCmdStr);

   setPskResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE; 
}

int wfaStaSetPSKMarvellSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
   dutCmdResponse_t *setPskResp = &gGenericResp;

   FILE *file;   
   char filename[64];
   
   printf("Inside wfaStaSetPSKMarvellSupplicant fun...\n");

   // stop the service before adding config file

   	sprintf(gCmdStr, "Taskkill /T /F /IM Mrv8000x.exe");
	system(gCmdStr);
	Sleep(1000);

   // Check the file in C:\WFA\MarvellSupplicant
	strcpy(filename,setPSK->ssid);
	strcat (filename,"_psk");
	strcat (filename,".cfg");
	printf("The marvell config file is : %s",filename);

	sprintf(gCmdStr, "c:\\WFA\\MarvellSupplicant\\%s",filename);
	file = fopen(gCmdStr,"r");
	if(file==NULL) 
	{
		printf("Error Opening Marvell config file .\n");
		return 1;
	}
	else 
	{
		fclose(file);

		// Copy the file into c:\program files\Marvell CBxxx
   		sprintf(gCmdStr, "copy /Y c:\\WFA\\MarvellSupplicant\\%s \"c:\\Program\ Files\\Marvell\ CB82\\Data.cfg\"",filename);
		system(gCmdStr);
	}

   // Start the service

	sprintf(gCmdStr, " start \"Marvell\" /D \"c:\\Program\ Files\\Marvell\ CB82\" Mrv8000x.exe");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);
	Sleep(3000);

   setPskResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;
   return TRUE;
}


int wfaStaSetPSK(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
   dutCmdResponse_t *setPskResp = &gGenericResp;
      
   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetPSK ...\n");

#if !defined(_CYGWIN) && !defined(_WINDOWS)
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setPSK->intf, setPSK->ssid); 
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-PSK", setPSK->intf); 
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 psk '\"%s\"'", setPSK->intf, setPSK->passphrase); 
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setPSK->intf);
   system(gCmdStr);

#else 
   switch(geSupplicant)
   {
	   case eWindowsZeroConfig:
		   wfaStaSetPSKZeroConfig(len,caCmdBuf,respLen,respBuf);			
		   break;
	   case eMarvell:
		   wfaStaSetPSKMarvellSupplicant(len,caCmdBuf,respLen,respBuf);	
		   break;
	   case eWpaSupplicant:
		   wfaStaSetPSKWpaSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eCiscoSecureClient:
		   wfaStaSetPSKCiscoSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eOpen1x:
		   break;
	   default:
		   setPskResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;
		   break;
   }
#endif
   return TRUE; 
}


/*
 * wfaStaGetInfo(): 
 * Get vendor specific information in name/value pair by a wireless I/F.
 */
int wfaStaGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf;

   /*
    * Normally this is called to retrieve the vendor information
    * from a interface, no implement yet
    */
   sprintf(infoResp.cmdru.info, "interface,%s,vendor,XXX,cardtype,802.11a/b/g", getInfo->intf);
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

int wfaStaGetTestData(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
//    dutCmdResponse_t dataResp;
//    dutCommand_t *testData = (dutCommand_t *)caCmdBuf;

    /*
     * This is to trasfer the test log (file) back to console
     * It has not decided to use in-band or out of band. Will be updated
     * in a new release soon.
     */

    return TRUE;
}


int wfaStaSetEapTTLSCiscoSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTTLS_t *setTTLS = (caStaSetEapTTLS_t *)caCmdBuf;
   char *ifname = setTTLS->intf;
   dutCmdResponse_t *setEapTtlsResp = &gGenericResp;
   FILE *file;
   int ret;
   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapTTLSCiscoSupplicant ...\n");

    // stop the service
   	sprintf(gCmdStr, "sc stop \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

   file = fopen("c:\\windows\\temp\\tmp.xml", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {    

	CiscoConfigGenerateUpperPart(file);
	CiscoEAPConfigGenerateUpperPart(file,&(setTTLS->ssid[0]));

    sprintf(gCmdStr,"\t\t\t\t\t\t<authenticationMethod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<eapTtls>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<doNotValidateServerCertificate/>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<unprotectedIdentityPattern encryptContent=\"true\" >anonymous</unprotectedIdentityPattern>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<enableFastReconnect>\n");
    fputs(gCmdStr, file);     
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<alwaysAttempt/>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</enableFastReconnect>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<protectedIdentityPattern encryptContent=\"true\" >%s</protectedIdentityPattern>\n",setTTLS->username);
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<passwordSource>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<passwordFromProfile encryptContent=\"true\" >%s</passwordFromProfile>\n",setTTLS->passwd);
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</passwordSource>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<mschapv2/>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t</eapTtls>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t</authenticationMethod>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t<collectionBehavior/>\n");
    fputs(gCmdStr, file);

	CiscoEAPConfigGenerateLowerPart(file,setTTLS->encrptype,setTTLS->keyMgmtType);
	CiscoConfigGenerateLowerPart(file);
  }
  fclose(file);

  // sign the xml file
  sprintf(gCmdStr, "SignProfile.bat c:\\windows\\temp\\tmp.xml c:\\windows\\temp\\tmp1.xml");
	system(gCmdStr);
	Sleep(1000);
  // copy to the destnationfolder
	sprintf(gCmdStr, "copy /Y c:\\windows\\temp\\tmp1.xml \"c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\configuration.xml\"");
	ret=system(gCmdStr);
	Sleep(1000);
		printf("Executing %s\n",gCmdStr);
	printf("Return value is %d\n",ret);
  /* start the service */


	sprintf(gCmdStr, "sc start \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);


   setEapTtlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}


/*
 * wfaStaSetEapTTLS():
 *   This is to set
 *   1. ssid
 *   2. username
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyManagementType - wpa or wpa2
 *   6. trustedRootCA
 */
int wfaStaSetEapTTLSWpaSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTTLS_t *setTTLS = (caStaSetEapTTLS_t *)caCmdBuf;
   char *ifname = setTTLS->intf;
   dutCmdResponse_t *setEapTtlsResp = &gGenericResp;
   FILE *file;
   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapTLSWpaSupplicant ...\n");

   file = fopen("c:\\WFA\\WpaSupplicant\\wpa_supplicant.conf", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
	  sprintf(gCmdStr,"ctrl_interface=\\Device\\NPF_%s\n",gnetIf);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"ap_scan=2\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"network={\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tssid=\"%s\"\n",setTTLS->ssid);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tkey_mgmt=WPA-EAP\n");
	  fputs(gCmdStr, file);
	  
	  if(strncmp(setTTLS->keyMgmtType, "wpa2", 4) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA2\n");
		  fputs(gCmdStr, file);
//		  sprintf(gCmdStr,"\tpairwise=CCMP\n");
//		  fputs(gCmdStr, file);
	  } else if (strncmp(setTTLS->keyMgmtType, "wpa", 3) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA\n");
		  fputs(gCmdStr, file);
//		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
//		  fputs(gCmdStr, file);
	  }

	  if((strncmp(setTTLS->encrptype, "TKIP",4) == 0) || (strncmp(setTTLS->encrptype, "tkip",4) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
		  fputs(gCmdStr, file);
	  }
	  else if((strncmp(setTTLS->encrptype, "AES-CCMP",8) == 0) || (strncmp(setTTLS->encrptype, "aes-ccmp",8) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		  fputs(gCmdStr, file);
	  }

	  sprintf(gCmdStr,"\teap=TTLS\n");
	  fputs(gCmdStr, file);

// For WAP2 Test Plan 

	  sprintf(gCmdStr,"\tphase2=\"auth=MSCHAPV2\"\n");
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tca_cert=\"%s.pem\"\n",setTTLS->trustedRootCA);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tanonymous_identity=\"anonymous\"\n");
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tidentity=\"%s\"\n",setTTLS->username);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tpassword=\"%s\"\n",setTTLS->passwd);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"}\n");
  	  fputs(gCmdStr, file);
  }
  fclose(file);

  /* stop the service and start the service */
   sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
   system(gCmdStr);
   sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
   system(gCmdStr);
   printf("Executing %s\n",gCmdStr);

   setEapTtlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * wfaStaSetEapTTLS():
 *   This is to set
 *   1. ssid
 *   2. username
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyManagementType - wpa or wpa2
 *   6. trustedRootCA
 */
int wfaStaSetEapTTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTTLS_t *setTTLS = (caStaSetEapTTLS_t *)caCmdBuf;
   char *ifname = setTTLS->intf;
   dutCmdResponse_t *setEapTtlsResp = &gGenericResp;

#if !defined(_CYGWIN) && !defined(_WINDOWS)
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setTTLS->ssid);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setTTLS->username);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setTTLS->passwd);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   system(gCmdStr);

/* This may not need to set. if it is not set, default to take all */
//   sprintf(cmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"", ifname, setTTLS->encrptype);
//   system(cmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap TTLS", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setTTLS->trustedRootCA);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
   system(gCmdStr);

//   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
//   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=MSCHAPV2\"'", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   system(gCmdStr);

   setEapTtlsResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

#else
  switch(geSupplicant)
   {
	   case eWindowsZeroConfig:
		   setEapTtlsResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;			
		   break;
	   case eMarvell:
		   break;
	   case eWpaSupplicant:
		   wfaStaSetEapTTLSWpaSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eCiscoSecureClient:
		   wfaStaSetEapTTLSCiscoSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eOpen1x:
		   break;
	   default:
		   setEapTtlsResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;
		   break;
   }
#endif
   return TRUE;
}


int wfaStaSetEapSIMWpaSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapSIM_t *setSIM = (caStaSetEapSIM_t *)caCmdBuf;
   char *ifname = setSIM->intf;
   dutCmdResponse_t *setEapSimResp = &gGenericResp;
   FILE *file;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapSIMWpaSupplicant ...\n");

   file = fopen("c:\\WFA\\WpaSupplicant\\wpa_supplicant.conf", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {    
	  sprintf(gCmdStr,"ctrl_interface=\\Device\\NPF_%s\n",gnetIf);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"ap_scan=2\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"network={\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tssid=\"%s\"\n",setSIM->ssid);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tkey_mgmt=WPA-EAP\n");
	  fputs(gCmdStr, file);

	  if(strncmp(setSIM->keyMgmtType, "wpa2", 4) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA2\n");
		  fputs(gCmdStr, file);
	//	  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		//  fputs(gCmdStr, file);
	  } else if (strncmp(setSIM->keyMgmtType, "wpa", 3) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA\n");
		  fputs(gCmdStr, file);
//		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
//		  fputs(gCmdStr, file);
	  }

	  if((strncmp(setSIM->encrptype, "TKIP",4) == 0) || (strncmp(setSIM->encrptype, "tkip",4) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
		  fputs(gCmdStr, file);
	  }
	  else if((strncmp(setSIM->encrptype, "AES-CCMP",8) == 0) || (strncmp(setSIM->encrptype, "aes-ccmp",8) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		  fputs(gCmdStr, file);
	  }

	  sprintf(gCmdStr,"\teap=SIM\n");
	  fputs(gCmdStr, file);

// For WAP2 Test Plan 

	  sprintf(gCmdStr,"\tidentity=\"%s\"\n",setSIM->username);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tpassword=\"%s\"\n",setSIM->passwd);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"}\n");
  	  fputs(gCmdStr, file);
  }
  fclose(file);

  /* start the service and stop the service */

	sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

	sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

    printf("Executing %s\n",gCmdStr);
    system(gCmdStr);

	setEapSimResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;
}
/*
 * wfaStaSetEapSIM():
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyMangementType - wpa or wpa2
 */
int wfaStaSetEapSIM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapSIM_t *setSIM = (caStaSetEapSIM_t *)caCmdBuf;
   char *ifname = setSIM->intf;
   dutCmdResponse_t *setEapSimResp = &gGenericResp;

#if !defined(_CYGWIN) && !defined(_WINDOWS)
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setSIM->ssid);
   system(gCmdStr);


   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setSIM->username);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setSIM->encrptype);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap SIM", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   system(gCmdStr);

   setEapSimResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
#else
   switch(geSupplicant)
   {
	   case eWindowsZeroConfig:
		   setEapSimResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;			
		   break;
	   case eMarvell:
		   setEapSimResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;	
		   break;
	   case eWpaSupplicant:
		   wfaStaSetEapSIMWpaSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eCiscoSecureClient:
		   setEapSimResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;	
		   break;
	   case eOpen1x:
		   //wfaStaSetEapSIMOpen1x(len,caCmdBuf,respLen,respBuf);
		   break;
	   default:
		   setEapSimResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;
		   break;
   }
#endif


   return TRUE;
}

/*
 * wfaStaSetPEAP(): For ZeroConfig
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encryType - tkip or aes-ccmp
 *   5. keyMgmtType - wpa or wpa2
 *   6. trustedRootCA
 *   7. innerEAP
 *   8. peapVersion
 */
int wfaStaSetPEAPZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
   char *ifname = setPEAP->intf;
   dutCmdResponse_t *setPeapResp = &gGenericResp;
   FILE *file;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetPEAP ...\n");


   sprintf(gCmdStr, "wifi_config -limit %s -enable", gnetIf);
   system(gCmdStr);
#ifdef _CYGWIN
   file = fopen("/tmp/tmp.xml", "w+");
#else
file = fopen("c:\\windows\\temp\\tmp.xml", "w+");
#endif
 /* we create a file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
    sprintf(gCmdStr,"<?xml version=\"1.0\"?>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<name>%s</name>\n",setPEAP->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<name>%s</name>\n",setPEAP->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<nonBroadcast>false</nonBroadcast>\n");
    fputs(gCmdStr, file);	
    sprintf(gCmdStr,"\t</SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionType>ESS</connectionType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<authEncryption>\n");
    fputs(gCmdStr, file);

	if((strcmp(setPEAP->keyMgmtType, "WPA2") == 0) || (strcmp(setPEAP->keyMgmtType, "wpa2") == 0))
	{
    	sprintf(gCmdStr,"\t\t\t\t<authentication>WPA2</authentication>\n");
    	fputs(gCmdStr, file);
    	sprintf(gCmdStr,"\t\t\t\t<encryption>AES</encryption>\n");
    	fputs(gCmdStr, file);

	}
	else if((strcmp(setPEAP->keyMgmtType, "WPA") == 0) || (strcmp(setPEAP->keyMgmtType, "wpa") == 0))
	{
    	sprintf(gCmdStr,"\t\t\t\t<authentication>WPA</authentication>\n");
    	fputs(gCmdStr, file);
    	sprintf(gCmdStr,"\t\t\t\t<encryption>TKIP</encryption>\n");
    	fputs(gCmdStr, file);

	}

	
//	if((strcmp(setPEAP->encrptype, "TKIP") == 0) || (strcmp(setPEAP->encrptype, "tkip") == 0))
//	{
 //   	sprintf(gCmdStr,"\t\t\t\t<encryption>TKIP</encryption>\n");
 //   	fputs(gCmdStr, file);
//	}
//	else if((strcmp(setPEAP->encrptype, "AES-CCMP") == 0) || (strcmp(setPEAP->encrptype, "aes-ccmp") == 0))
//	{
//    	sprintf(gCmdStr,"\t\t\t\t<encryption>AES</encryption>\n");
//    	fputs(gCmdStr, file);
//	}
    sprintf(gCmdStr,"\t\t\t\t<useOneX>true</useOneX>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t</authEncryption>\n");
    fputs(gCmdStr, file);

    sprintf(gCmdStr,"\t\t\t<OneX xmlns=\"http://www.microsoft.com/networking/OneX/v1\">\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t<cacheUserData>false</cacheUserData>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t<EAPConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t<EapHostConfig xmlns=\"http://www.microsoft.com/provisioning/EapHostConfig\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t<EapMethod>\n");
    fputs(gCmdStr, file);

    sprintf(gCmdStr,"\t\t\t\t\t\t\t<Type xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">25</Type>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<VendorId xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</VendorId>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<VendorType xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</VendorType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<AuthorId xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</AuthorId>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t</EapMethod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t<ConfigBlob>010000003E000000010000000000000001000000150000001700000000000000000001000000170000001A00000001000000000000000000000000000000</ConfigBlob>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t</EapHostConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t</EAPConfig>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t</OneX>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</WLANProfile>\n");
    fputs(gCmdStr, file);

  }
  fclose(file);
#ifdef _CYGWIN
   sprintf(gCmdStr, "wifi_config -limit %s -add %s", setPSK->intf,"c:\\\\cygwin\\\\tmp\\\\tmp.xml");
#else
   sprintf(gCmdStr, "wifi_config -limit %s -add %s", gnetIf,"c:\\\\windows\\\\temp\\\\tmp.xml");
#endif
   printf("Executing %s\n",gCmdStr);
   system(gCmdStr);


   setPeapResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

int wfaStaSetPEAPCiscoSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
   char *ifname = setPEAP->intf;
   dutCmdResponse_t *setPeapResp = &gGenericResp;
   FILE *file;
	int ret;
   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetPEAPCiscoSupplicant ...\n");

   // stop the service
   	sprintf(gCmdStr, "sc stop \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);
/*

   file = fopen("c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\internalConfiguration.xml", "w+");
  // we create a empty file for reading and writing 
  
  if(file==NULL)
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
	  
	  sprintf(gCmdStr,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"<internalConfigurationData>\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"<group>\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"<groupName>Local networks</groupName>\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"<network>\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"<networkName>%s</networkName>n",setPEAP->ssid);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"<credentials>n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"<credential>01000000d08c9ddf0115d1118c7a00c04fc297eb01000000a3568b37ba115e408e3023914e2eed9b040000000a00000062006c006f006200000003660000a800000010000000fd4caa430f73b24f98413cda9f3e87f90000000004800000a000000010000000e7830c805627b3037667dd34270a330128000000395bc1b16e244630e48551e5e2cefc378aa8aa1799fd9b1edadfea24b02e52447369427cba3bbce214000000d63204fccdeaa4d831043d0e4b2cc9ddd939f2f801d1cfc92e</credential>n");
	  fputs(gCmdStr, file);
	  if ( setPEAP->peapVersion == 0 )
	  {
		  sprintf(gCmdStr,"<credential>01000000d08c9ddf0115d1118c7a00c04fc297eb01000000a3568b37ba115e408e3023914e2eed9b040000000a00000062006c006f006200000003660000a800000010000000f7c21a2dcac8ffb4e8eaf58623db8b900000000004800000a00000001000000065281a249083d700d2ca713c9b51e0f828000000bd0d8fa0ee600277d77fae28591189082ab3ddbe1149f954eec717365c39ced67b96e39a17050bd714000000f5f8158cacf2f930098a24a1a9df8f02ad6231c70169d922f8</credential>n");
		  fputs(gCmdStr, file);
	  }
	  else
	  {
		  sprintf(gCmdStr,"<credential>01000000d08c9ddf0115d1118c7a00c04fc297eb01000000a3568b37ba115e408e3023914e2eed9b040000000a00000062006c006f006200000003660000a800000010000000f7c21a2dcac8ffb4e8eaf58623db8b900000000004800000a00000001000000065281a249083d700d2ca713c9b51e0f828000000bd0d8fa0ee600277d77fae28591189082ab3ddbe1149f954eec717365c39ced67b96e39a17050bd714000000f5f8158cacf2f930098a24a1a9df8f02ad6231c70169d922f8</credential>n");
		  fputs(gCmdStr, file);
	  }
	  sprintf(gCmdStr,"</credentials>n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"</network>n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"</group>n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"</internalConfigurationData>n");
	  fputs(gCmdStr, file);
  }

  fclose(file);
*/
	file = fopen("c:\\windows\\temp\\tmp.xml", "w+");

   //file = fopen("c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\userConfiguration.xml", "w+");
  /* we create a empty file for reading and writing */


  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {    
/*
    sprintf(gCmdStr,"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<UserConfiguration major_version=\"5\" minor_version=\"1\" development_version=\"1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<networks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<group>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<groupName>Default</groupName>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<allowUserToSeeScanlist>true</allowUserToSeeScanlist>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<wifiNetwork>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"<displayName>%s</displayName>\n",setPEAP->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<connectionTimeout>40</connectionTimeout>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<ssid>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<name>%s</name>\n",setPEAP->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</ssid>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<associationTimeout>3</associationTimeout>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<authenticationNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<userAuthentication>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<collectionBehavior>\n");
    fputs(gCmdStr, file);
	// if username and password
	// else certificate
	if ( setPEAP->peapVersion == 0 )
	{
		sprintf(gCmdStr,"<withPassword>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<cachePasswordFromUser>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<forever/>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</cachePasswordFromUser>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</withPassword>\n");
		fputs(gCmdStr, file);
	}
	else
	{
		sprintf(gCmdStr,"<withToken>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<cachePinForTokenFromUser>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<forever/>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</withToken>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</cachePinForTokenFromUser>\n");
		fputs(gCmdStr, file);
	}
    sprintf(gCmdStr,"</collectionBehavior>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<authenticationMethod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<eapPeap>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<doNotValidateServerCertificate/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<unprotectedIdentityPattern encryptContent=\"true\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<EncryptedData xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Type=\"http://www.w3.org/2001/04/xmlenc#Content\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<CipherData>\n");
    fputs(gCmdStr, file);
	if ( setPEAP->peapVersion == 0 )
	{
		sprintf(gCmdStr,"<CipherValue>Og5DSocVJ5+HnskyOPsahensIoMEEC1zf+nzg2jySVA=</CipherValue>\n");
	}
	else
	{
		sprintf(gCmdStr,"<CipherValue>NIxzhb8ccY13XzRT3q0GUXVXZMOj+iwtFt8CZrgQqIw=</CipherValue>\n");		
	}
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</CipherData>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</EncryptedData>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</unprotectedIdentityPattern>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<enableFastReconnect>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<alwaysAttempt/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</enableFastReconnect>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<authMethods>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<builtinMethods>\n");
    fputs(gCmdStr, file);
	if ( setPEAP->peapVersion == 0 )
	{
		sprintf(gCmdStr,"<authenticateWithPassword>\n");
	}
	else
	{
		sprintf(gCmdStr,"<authenticateWithToken>\n");
	}
	fputs(gCmdStr, file);
    sprintf(gCmdStr,"<protectedIdentityPattern encryptContent=\"true\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<EncryptedData xmlns=\"http://www.w3.org/2001/04/xmlenc#\" Type=\"http://www.w3.org/2001/04/xmlenc#Content\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<CipherData>\n");
    fputs(gCmdStr, file);
	if ( setPEAP->peapVersion == 0 )
	{
		sprintf(gCmdStr,"<CipherValue>fT6aOmryoHPtCk+LVL2g1f2FowLQ1yqjh8p6gzY44Ug=</CipherValue>\n");
	}
	else
	{
		sprintf(gCmdStr,"<CipherValue>I81l3Y3PbrpJqSUXx34eOR/W0gO7KQrxpZ8wk4X2WAA=</CipherValue>\n");
	}
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</CipherData>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</EncryptedData>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</protectedIdentityPattern>\n");
    fputs(gCmdStr, file);
	if ( setPEAP->peapVersion == 0 )
	{
		sprintf(gCmdStr,"<passwordSource>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<passwordFromUser/>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</passwordSource>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<methods>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<eapMschapv2/>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</methods>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</authenticateWithPassword>\n");
		fputs(gCmdStr, file);
	}
	else
	{
		sprintf(gCmdStr,"<tokenSource>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<passwordFromOtherToken/>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</tokenSource>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<methods>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"<eapGtc/>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</methods>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"</authenticateWithToken>\n");
		fputs(gCmdStr, file);
	}
    sprintf(gCmdStr,"</builtinMethods>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</authMethods>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</eapPeap>\n");
    fputs(gCmdStr, file);	
    sprintf(gCmdStr,"</authenticationMethod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</userAuthentication>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<setting802.1x>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<authPeriod>30</authPeriod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<heldPeriod>60</heldPeriod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<startPeriod>30</startPeriod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<maxStart>3</maxStart>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</setting802.1x>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<associationMode>\n");
    fputs(gCmdStr, file);
	if(strncmp(setPEAP->keyMgmtType, "wpa2", 4) == 0)
	{
		sprintf(gCmdStr,"<wpa2>\n");
		fputs(gCmdStr, file);
	}
	else if (strncmp(setPEAP->keyMgmtType, "wpa", 3) == 0)
	{
		sprintf(gCmdStr,"<wpa>\n");
		fputs(gCmdStr, file);
	}
	if((strcmp(setPEAP->encrptype, "TKIP") == 0) || (strcmp(setPEAP->encrptype, "tkip") == 0))
	{
		sprintf(gCmdStr,"<encryption>TKIP</encryption>\n");
		fputs(gCmdStr, file);
	}
	else if((strcmp(setPEAP->encrptype, "AES-CCMP") == 0) || (strcmp(setPEAP->encrptype, "aes-ccmp") == 0))
	{
		sprintf(gCmdStr,"<encryption>AES</encryption>\n");
		fputs(gCmdStr, file);
	}
	if(strncmp(setPEAP->keyMgmtType, "wpa2", 4) == 0)
	{
		sprintf(gCmdStr,"</wpa2>\n");
		fputs(gCmdStr, file);
	}
	else if (strncmp(setPEAP->keyMgmtType, "wpa", 3) == 0)
	{
		sprintf(gCmdStr,"</wpa>\n");
		fputs(gCmdStr, file);
	}
    sprintf(gCmdStr,"</associationMode>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</authenticationNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</wifiNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</group>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</networks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</UserConfiguration>\n");
    fputs(gCmdStr, file);
	*/
	CiscoConfigGenerateUpperPart(file);
	CiscoEAPConfigGenerateUpperPart(file,setPEAP->ssid);

    sprintf(gCmdStr,"\t\t\t\t\t\t<authenticationMethod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<eapPeap>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<doNotValidateServerCertificate/>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<unprotectedIdentityPattern encryptContent=\"true\" >anonymous</unprotectedIdentityPattern>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<enableFastReconnect>\n");
    fputs(gCmdStr, file);     
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<alwaysAttempt/>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</enableFastReconnect>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<authMethods>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<builtinMethods>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t<authenticateWithPassword>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t<protectedIdentityPattern encryptContent=\"true\" >%s</protectedIdentityPattern>\n",setPEAP->username);
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t<passwordSource>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t\t<passwordFromProfile encryptContent=\"true\" >%s</passwordFromProfile>\n",setPEAP->passwd);
    fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t</passwordSource>\n");
    fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t<methods>\n");
    fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t\t<eapMschapv2/>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t</methods>\n");
    fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t</authenticateWithPassword>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t</builtinMethods>\n");
    fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</authMethods>\n");
    fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t</eapPeap>\n");
    fputs(gCmdStr, file); 	
	sprintf(gCmdStr,"\t\t\t\t\t\t</authenticationMethod>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t<collectionBehavior/>\n");
	fputs(gCmdStr, file);
	CiscoEAPConfigGenerateLowerPart(file,setPEAP->encrptype,setPEAP->keyMgmtType);
	CiscoConfigGenerateLowerPart(file);

  }
  fclose(file);

    // sign the xml file
  sprintf(gCmdStr, "SignProfile.bat c:\\windows\\temp\\tmp.xml c:\\windows\\temp\\tmp1.xml");
	system(gCmdStr);
	Sleep(1000);
  // copy to the destnationfolder
	sprintf(gCmdStr, "copy /Y c:\\windows\\temp\\tmp1.xml \"c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\configuration.xml\"");
	ret=system(gCmdStr);
	Sleep(1000);
	printf("Executing %s\n",gCmdStr);
	printf("Return value is %d\n",ret);
  /* start the service */

	sprintf(gCmdStr, "sc start \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

   setPeapResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * wfaStaSetPEAP(): For ZeroConfig
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encryType - tkip or aes-ccmp
 *   5. keyMgmtType - wpa or wpa2
 *   6. trustedRootCA
 *   7. innerEAP
 *   8. peapVersion
 */
int wfaStaSetPEAPWpaSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
   char *ifname = setPEAP->intf;
   dutCmdResponse_t *setPeapResp = &gGenericResp;
   FILE *file;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetPEAPWpaSupplicant ...\n");


   file = fopen("c:\\WFA\\WpaSupplicant\\wpa_supplicant.conf", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
	  sprintf(gCmdStr,"ctrl_interface=\\Device\\NPF_%s\n",gnetIf);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"ap_scan=2\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"network={\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tssid=\"%s\"\n",setPEAP->ssid);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tkey_mgmt=WPA-EAP\n");
	  fputs(gCmdStr, file);

	  if(strncmp(setPEAP->keyMgmtType, "wpa2", 4) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA2\n");
		  fputs(gCmdStr, file);
		  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		  fputs(gCmdStr, file);
	  } else if (strncmp(setPEAP->keyMgmtType, "wpa", 3) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA\n");
		  fputs(gCmdStr, file);
		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
		  fputs(gCmdStr, file);
	  }


    printf("Encryptioin type received = %s .\n",setPEAP->encrptype);
	  if((strncmp(setPEAP->encrptype, "TKIP",4) == 0) || (strncmp(setPEAP->encrptype, "tkip",4) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
		  fputs(gCmdStr, file);
	  }
	  else if((strncmp(setPEAP->encrptype, "AES-CCMP",8) == 0) || (strncmp(setPEAP->encrptype, "aes-ccmp",8) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		  fputs(gCmdStr, file);
	  }
	  
	  sprintf(gCmdStr,"\teap=PEAP\n");
	  fputs(gCmdStr, file);


	  if ( setPEAP->peapVersion == 0 )
	  {
		  sprintf(gCmdStr,"\tphase1=\"peapver=0\"\n");
		  fputs(gCmdStr, file);
		  sprintf(gCmdStr,"\tphase2=\"auth=MSCHAPV2\"\n");
		  fputs(gCmdStr, file);

		// For WAP2 Test Plan 


		  sprintf(gCmdStr,"\tca_cert=\"%s.pem\"\n",setPEAP->trustedRootCA);
		  fputs(gCmdStr, file);

//		  sprintf(gCmdStr,"\tca_cert=\"certnew.pem\"\n");
//		  fputs(gCmdStr, file);

		  sprintf(gCmdStr,"\tidentity=\"%s\"\n",setPEAP->username);
		  fputs(gCmdStr, file);

		  sprintf(gCmdStr,"\tpassword=\"%s\"\n",setPEAP->passwd);
		  fputs(gCmdStr, file);


	  }
	  else 
	  {
		  sprintf(gCmdStr,"\tphase1=\"peapver=1\"\n");
		  fputs(gCmdStr, file);
		  sprintf(gCmdStr,"\tphase2=\"auth=GTC\"\n");
		  fputs(gCmdStr, file);

			// For WAP2 Test Plan 

		  sprintf(gCmdStr,"\tidentity=\"%s\"\n",setPEAP->username);
		  fputs(gCmdStr, file);

		  sprintf(gCmdStr,"\tpassword=\"%s\"\n",setPEAP->passwd);
		  fputs(gCmdStr, file);

	  }

	  sprintf(gCmdStr,"}\n");
  	  fputs(gCmdStr, file);
  }
  fclose(file);

  /* stop the service and start the service */
   sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
   system(gCmdStr);
   sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
   system(gCmdStr);
   printf("Executing %s\n",gCmdStr);


   setPeapResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 * wfaStaSetPEAP()
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encryType - tkip or aes-ccmp
 *   5. keyMgmtType - wpa or wpa2
 *   6. trustedRootCA
 *   7. innerEAP
 *   8. peapVersion
 */
int wfaStaSetPEAP(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
   char *ifname = setPEAP->intf;
   dutCmdResponse_t *setPeapResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetPEAP ...\n");
#if !defined(_CYGWIN) && !defined(_WINDOWS)

   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setPEAP->ssid);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap PEAP", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"' ", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setPEAP->username);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setPEAP->passwd);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ca_cert '\"%s/%s\"'", ifname, CERTIFICATES_PATH, setPEAP->trustedRootCA);
   system(gCmdStr);

   /* if this not set, default to set support all */
   //sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pairwise '\"%s\"'", ifname, setPEAP->encrptype);
   //system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase1 '\"peaplabel=%i\"'", ifname, setPEAP->peapVersion);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=%s\"'", ifname, setPEAP->innerEAP);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
   system(gCmdStr);

   setPeapResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
#else
   switch(geSupplicant)
   {
	   case eWindowsZeroConfig:
		   wfaStaSetPEAPZeroConfig(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eMarvell:
		   break;
	   case eWpaSupplicant:
		   wfaStaSetPEAPWpaSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eCiscoSecureClient:
		   wfaStaSetPEAPCiscoSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eOpen1x:
		   break;
	   default:
		   setPeapResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;
		   break;
   }

#endif


   return TRUE;
}

/*
 * wfaStaSetUAPSD()
 *    This is to set
 *    1. acBE
 *    2. acBK
 *    3. acVI
 *    4. acVO
 */
int wfaStaSetUAPSD(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetUAPSD_t *setUAPSD = (caStaSetUAPSD_t *)caCmdBuf;
   char *ifname = setUAPSD->intf;
   char tmpStr[10];
   char *pathl="/etc/Wireless/RT61STA";
   dutCmdResponse_t *setUAPSDResp = &gGenericResp;
   BYTE acBE=1;
   BYTE acBK=1;
   BYTE acVO=1;
   BYTE acVI=1;
   BYTE APSDCapable;
//   FILE *pipe;

   /*
    * A series of setting need to be done before doing WMM-PS
    * Additional steps of configuration may be needed.
    */

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",ifname);
#if !defined(_CYGWIN) && !defined(_WINDOWS)
   system(gCmdStr);
#endif
   /*
    * Unload the Driver
    */
   sprintf(gCmdStr, "rmmod rt61");
#if !defined(_CYGWIN) && !defined(_WINDOWS)
   system(gCmdStr);
#endif
   if(setUAPSD->acBE != 1)
     acBE=setUAPSD->acBE = 0;
   if(setUAPSD->acBK != 1)
     acBK=setUAPSD->acBK = 0;
   if(setUAPSD->acVO != 1)
     acVO=setUAPSD->acVO = 0;
   if(setUAPSD->acVI != 1)
     acVI=setUAPSD->acVI = 0;

   APSDCapable = acBE||acBK||acVO||acVI;
   /*
    * set other AC parameters
    */

   sprintf(tmpStr,"%d;%d;%d;%d",setUAPSD->acBE,setUAPSD->acBK,setUAPSD->acVI,setUAPSD->acVO);
   sprintf(gCmdStr, "sed -e \"s/APSDCapable=.*/APSDCapable=%d/g\" -e \"s/APSDAC=.*/APSDAC=%s/g\" %s/rt61sta.dat >/tmp/wfa_tmp",APSDCapable,tmpStr,pathl);
#if !defined(_CYGWIN) && !defined(_WINDOWS)
     char line[100];
   system(gCmdStr);
   
   sprintf(gCmdStr, "mv /tmp/wfa_tmp %s/rt61sta.dat",pathl);
   system(gCmdStr);
//  pipe = popen("uname -r", "r");
  /* Read into line the output of uname*/
  //     fscanf(pipe,"%s",line);
    //   pclose(pipe);

   /*
    * load the Driver
    */
   sprintf(gCmdStr, "insmod /lib/modules/%s/extra/rt61.ko",line);
   system(gCmdStr);
   
   sprintf(gCmdStr, "ifconfig %s up",ifname);
   system(gCmdStr);
#endif
   setUAPSDResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_UAPSD_RESP_TLV, 4, (BYTE *)setUAPSDResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;
   return TRUE;
}

int wfaDeviceGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *infoResp = &gGenericResp;
   FILE *tmpfile;
   /*a vendor can fill in the proper info or anything non-disclosure */
   caDeviceGetInfoResp_t dinfo;
	int i;
	char string[512];
	 char *str;

   DPRINT_INFO(WFA_OUT, "Entering wfaDeviceGetInfo ...\n");

	sprintf(gCmdStr, "del /F c:\\WFA\\temp.txt",string);
   	//printf("Executing %s\n",gCmdStr);
   	system(gCmdStr);
	sprintf(gCmdStr, "del /F c:\\WFA\\result.txt",string);
   	//printf("Executing %s\n",gCmdStr);
   	system(gCmdStr);

	sprintf(gCmdStr, "netsh wlan show  drivers > c:\\WFA\\temp.txt");
   	//printf("Executing %s\n",gCmdStr);
   	system(gCmdStr);

	sprintf(gCmdStr, "FOR /F \"tokens=2 delims=:\" %s IN ('findstr Vendor c:\\WFA\\temp.txt') DO @echo %s > c:\\WFA\\result.txt","%i","%i");
   	//printf("Executing %s\n",gCmdStr);
   	system(gCmdStr);



	tmpfile = fopen("c:\\WFA\\result.txt", "r");
	if(tmpfile == NULL)
	{
		printf("\n Error opening the result.txt file \n");
	}
	else
	{
		for(;;)
		{
			if(fgets(string, 256, tmpfile) == NULL)
				break; 
		}
		fclose(tmpfile);
		i=strlen(string);
		string[i]='\0';
	}

	 str = strtok(string, " ");
	 //str = strtok(NULL, " ");
	 if(str != NULL)
	 {
		strncpy(dinfo.vendor, str,16);		
		printf("The Vendor %s", str);
	 }


	sprintf(gCmdStr, "FOR /F \"tokens=2 delims=:\" %s IN ('findstr Version c:\\WFA\\temp.txt') DO @echo %s > c:\\WFA\\result.txt","%i","%i");
   	//printf("Executing %s\n",gCmdStr);
   	system(gCmdStr);


	tmpfile = fopen("c:\\WFA\\result.txt", "r");
	if(tmpfile == NULL)
	{
		printf("\n Error opening the result.txt file \n");
	}
	else
	{
		for(;;)
		{
			if(fgets(string, 256, tmpfile) == NULL)
				break; 
		}
		fclose(tmpfile);
		i=strlen(string);
		string[i]='\0';
	}
	strncpy(dinfo.version, string,16);		
	printf("The Version %s", string);

	strncpy(dinfo.model, WFA_CLI_VERSION,16);		
	printf("The model %s", string);

   memcpy(&infoResp->cmdru.devInfo, &dinfo, sizeof(caDeviceGetInfoResp_t));

   infoResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return TRUE;

}

/*
 * This funciton is to retrieve a list of interfaces and return
 * the list back to Agent control.
 * ********************************************************************
 * Note: We intend to make this WLAN interface name as a hardcode name.
 * Therefore, for a particular device, you should know and change the name
 * for that device while doing porting. The MACRO "WFA_STAUT_IF" is defined in 
 * the file "inc/wfa_ca.h". If the device OS is not linux-like, this most 
 * likely is hardcoded just for CAPI command responses.
 * *******************************************************************
 * 
 */
int wfaDeviceListIF(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *infoResp = &gGenericResp;
   dutCommand_t *ifList = (dutCommand_t *)caCmdBuf;
   caDeviceListIFResp_t *ifListResp = &infoResp->cmdru.ifList;

   DPRINT_INFO(WFA_OUT, "Entering wfaDeviceListIF ...\n");
   switch(ifList->cmdsu.iftype)
   {
      case IF_80211:
      infoResp->status = STATUS_COMPLETE;
      ifListResp->iftype = IF_80211; 
#ifdef _WINDOWS
      strcpy(ifListResp->ifs[0], aINTERFACE);
#else
	  strcpy(ifListResp->ifs[0], WFA_STAUT_IF);
#endif
      strcpy(ifListResp->ifs[1], "NULL");
      strcpy(ifListResp->ifs[2], "NULL");
      break;
      case IF_ETH:
      infoResp->status = STATUS_COMPLETE;
      ifListResp->iftype = IF_ETH; 
      strcpy(ifListResp->ifs[0], "eth0");
      strcpy(ifListResp->ifs[1], "NULL");
      strcpy(ifListResp->ifs[2], "NULL");
      break;
      default:
      {
         infoResp->status = STATUS_ERROR;
         wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, 4, (BYTE *)infoResp, respBuf);   
         *respLen = WFA_TLV_HDR_LEN + 4;

         return TRUE; 
      }
   }
   
   wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   return TRUE;
}

int wfaStaDebugSet(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *debugResp = &gGenericResp;
   dutCommand_t *debugSet = (dutCommand_t *)caCmdBuf;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaDebugSet ...\n");

   if(debugSet->cmdsu.dbg.state == 1) /* enable */
      wfa_defined_debug |= debugSet->cmdsu.dbg.level;
   else
      wfa_defined_debug = (~debugSet->cmdsu.dbg.level & wfa_defined_debug);

   debugResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)debugResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);


   return TRUE;
}


/*
 *   wfaStaGetBSSID():
 *     This function is to retrieve BSSID of a specific wireless I/F.
 */ 
int wfaStaGetBSSID(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   char string[64],Interfacename[64];
   FILE *tmpfd;
   dutCmdResponse_t *bssidResp = &gGenericResp;
   dutCommand_t *getbssid= (dutCommand_t *)caCmdBuf;
   char *ifname = getbssid->intf;
   int i;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaGetBSSID ...\n");
   /* retrieve the BSSID */

#if !defined(_CYGWIN) && !defined(_WINDOWS)
   sprintf(gCmdStr, "wpa_cli status > /tmp/bssid.txt");

#else
#ifdef _CYGWIN
   sprintf(gCmdStr, "wifi_config -limit %s -query bssid> /tmp/bssid.txt", ifname);
#else
   sprintf(gCmdStr, "del c:\\windows\\temp\\bssid.txt");
   system(gCmdStr);
   if(geSupplicant == eWindowsZeroConfig)
   {


		tmpfd = fopen("c:\\wfa\\WfaEndpoint\\Interface.txt", "r");
		if(tmpfd == NULL)
		{
			printf("\n Error opening the interface file \n");
		}
		else
		{
			for(;;)
			{
				if(fgets(string, 256, tmpfd) == NULL)
					break; 
			}
			fclose(tmpfd);

			if(strncmp(string, "IFNAME", 6) == 0)
			  {
				 char *str;
				 str = strtok(string, "\"");
				 str = strtok(NULL, "\"");
				 if(str != NULL)
				 {
					 strcpy(&Interfacename[0],str);
				 }

			  }
		}
		sprintf(gCmdStr, "del /F c:\\WFA\\temp.txt",string);
       	//printf("Executing %s\n",gCmdStr);

		sprintf(gCmdStr, "netsh wlan show  interface name=\"%s\" > c:\\WFA\\temp.txt",&Interfacename[0]);
       	//printf("Executing %s\n",gCmdStr);
	   	system(gCmdStr);

		sprintf(gCmdStr, "FOR /F \"tokens=2,3,4,5,6,7 delims=:\" %s IN ('findstr BSSID c:\\WFA\\temp.txt') DO @echo %s:%s:%s:%s:%s:%s > c:\\windows\\temp\\bssid.txt","%i","%i","%j","%k","%l","%m","%n");
       	//printf("Executing %s\n",gCmdStr);
		system(gCmdStr);

   }
//	   sprintf(gCmdStr, "wifi_config -limit %s -query bssid> c:\\windows\\temp\\bssid.txt", gnetIf);
   else if(geSupplicant == eWpaSupplicant)
	   //sprintf(gCmdStr, "wpa_cli -i\\Device\\NPF_%s status > c:\\windows\\temp\\bssid.txt", gnetIf);
	   sprintf(gCmdStr, "wpa_cli status > c:\\windows\\temp\\bssid.txt", gnetIf);
   else if(geSupplicant == eCiscoSecureClient)
	   sprintf(gCmdStr, "FOR /F \"tokens=18 delims=. \" %s IN ('find \"Associated to ssid\" \"c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\logs\\CurrentLog.txt\"') DO @echo %s > c:\\windows\\temp\\bssid.txt","%i","%i");
   else if(geSupplicant == eMarvell)
	   sprintf(gCmdStr, "WfaMarvell.exe c:\\windows\\temp\\bssid.txt");

#endif
#endif
   //printf("Executing %s\n",gCmdStr);
   system(gCmdStr);
#ifndef _WINDOWS
   tmpfd = fopen("/tmp/bssid.txt", "r+");
#else
   tmpfd = fopen("c:\\windows\\temp\\bssid.txt", "r+");
#endif
   if(tmpfd == NULL)
   {
      bssidResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, 4, (BYTE *)bssidResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return FALSE;
   }

#if !defined(_CYGWIN) && !defined(_WINDOWS)
   for(;;)
   {
      if(fscanf(tmpfd, "%s", string) == EOF)
      {
         bssidResp->status = STATUS_COMPLETE; 
         strcpy(bssidResp->cmdru.bssid, "00:00:00:00:00:00");
         break; 
      }

      if(strncmp(string, "bssid", 5) == 0)
      {
	 char *str;
         str = strtok(string, "=");
         str = strtok(NULL, "=");
         if(str != NULL)
         {
            strcpy(bssidResp->cmdru.bssid, str);
            bssidResp->status = STATUS_COMPLETE;
            break;
         }
      }
   }
#else
   if(geSupplicant == eWindowsZeroConfig || geSupplicant == eCiscoSecureClient )
   {

      if(fscanf(tmpfd, "%s", string) == EOF)
      {
         bssidResp->status = STATUS_COMPLETE; 
         strcpy(bssidResp->cmdru.bssid, "00:00:00:00:00:00");
      }
      else
      {
            strcpy(bssidResp->cmdru.bssid, string);
            bssidResp->status = STATUS_COMPLETE;
      }
   } 
   else if (geSupplicant == eWpaSupplicant || geSupplicant == eMarvell)
   {
	     for(;;)
		   {
			  if(fscanf(tmpfd, "%s", string) == EOF)
			  {
				 bssidResp->status = STATUS_COMPLETE; 
				 strcpy(bssidResp->cmdru.bssid, "00:00:00:00:00:00");
				 break; 
			  }

			  if((strncmp(string, "bssid", 5) == 0) || (strncmp(string, "BSSID", 5) == 0 ))
			  {
				 char *str;

					 str = strtok(string, "=");
					 str = strtok(NULL, "=");
				 if(str != NULL)
				 {
					strcpy(bssidResp->cmdru.bssid, str);
					bssidResp->status = STATUS_COMPLETE;
					break;
				 }
			  }
			}
   }

 
#endif
   wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)bssidResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   fclose(tmpfd);
   return TRUE;
}

/*
 * wfaStaSetIBSS()
 *    This is to set
 *    1. ssid
 *    2. channel
 *    3. encrypType - none or wep
 *    optional
 *    4. key1
 *    5. key2
 *    6. key3
 *    7. key4
 *    8. activeIndex - 1, 2, 3, or 4
 */
int wfaStaSetIBSS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetIBSS_t *setIBSS = (caStaSetIBSS_t *)caCmdBuf;
   dutCmdResponse_t *setIbssResp = &gGenericResp;
   int i;

   /*
    * disable the network first
    */ 
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setIBSS->intf); 
   system(gCmdStr);

   /*
    * set SSID
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setIBSS->intf, setIBSS->ssid); 
   system(gCmdStr);

   /*
    * Set channel for IBSS
    */
   sprintf(gCmdStr, "iwconfig %s channel %i", setIBSS->intf, setIBSS->channel);
   system(gCmdStr);

   /*
    * Tell the supplicant for IBSS mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 1", setIBSS->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setIBSS->intf);
   system(gCmdStr);

   if(setIBSS->encpType == 1)
   {
      for(i=0; i<4; i++)
      {
         if((int)strlen(setIBSS->keys[i]) ==5 || (int)strlen(setIBSS->keys[i]) == 13)
         {
             sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i \"%s\"", 
                setIBSS->intf, i, setIBSS->keys[i]);
             system(gCmdStr);
         }
      } 

      i = setIBSS->activeKeyIdx;
      if((int)strlen(setIBSS->keys[i]) ==5 || (int)strlen(setIBSS->keys[i]) == 13)
      {
         sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_tx_keyidx %i", 
            setIBSS->intf, setIBSS->activeKeyIdx);
         system(gCmdStr);
      }
   }

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setIBSS->intf);
   system(gCmdStr);

   setIbssResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_IBSS_RESP_TLV, 4, (BYTE *)setIbssResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 *  wfaSetMode():
 *  The function is to set the wireless interface with a given mode (possible 
 *  adhoc)
 *  Input parameters:
 *    1. I/F
 *    2. ssid
 *    3. mode adhoc or managed
 *    4. encType
 *    5. channel
 *    6. key(s)
 *    7. active  key
 */ 
int wfaStaSetMode(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetMode_t *setmode = (caStaSetMode_t *)caCmdBuf;
   dutCmdResponse_t *SetModeResp = &gGenericResp;
   int i;

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",setmode->intf);
   system(gCmdStr);

   /*
    * distroy the interface
    */
   sprintf(gCmdStr, "wlanconfig %s destroy",setmode->intf);
   system(gCmdStr);


   /*
    * re-create the interface with the given mode
    */
   if(setmode->mode == 1)
        sprintf(gCmdStr, "wlanconfig %s create wlandev wifi0 wlanmode adhoc",setmode->intf);
   else
        sprintf(gCmdStr, "wlanconfig %s create wlandev wifi0 wlanmode managed",setmode->intf);

   system(gCmdStr);
   if(setmode->encpType == ENCRYPT_WEP)
    {
      int j = setmode->activeKeyIdx;
      for(i=0; i<4; i++)
      {
         if(setmode->keys[i][0] != '\0')
         {
             sprintf(gCmdStr, "iwconfig  %s key  s:%s",
                   setmode->intf, setmode->keys[i]);
             system(gCmdStr);
         }
      /* set active key */
         if(setmode->keys[j][0] != '\0')
             sprintf(gCmdStr, "iwconfig  %s key  s:%s",
                   setmode->intf, setmode->keys[j]);
         system(gCmdStr);
      }

    }
   /*
    * Set channel for IBSS
    */
    if(setmode->channel)
    {
      sprintf(gCmdStr, "iwconfig %s channel %i", setmode->intf, setmode->channel);
      system(gCmdStr);
    }


   /*
    * set SSID
    */
   sprintf(gCmdStr, "iwconfig %s essid %s", setmode->intf, setmode->ssid);
   system(gCmdStr);

   /*
    * bring up the interface
    */
   sprintf(gCmdStr, "ifconfig %s up",setmode->intf);
   system(gCmdStr);

   SetModeResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_MODE_RESP_TLV, 4, (BYTE *)SetModeResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}


int wfaStaUpload(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaUpload_t *upload = &((dutCommand_t *)caCmdBuf)->cmdsu.upload;
   dutCmdResponse_t *upLoadResp = &gGenericResp;
#ifdef WFA_WMM_EXT
   caStaUploadResp_t *upld = &upLoadResp->cmdru.uld;
#endif
   
   if(upload->type == WFA_UPLOAD_VHSO_RPT)
   {
#ifdef WFA_WMM_EXT
       int rbytes;
       /*
        * if asked for the first packet, always to open the file
        */
       if(upload->next == 1)
       {
          if(e2efp != NULL)
          {
              fclose(e2efp);
              e2efp = NULL;
          }

          e2efp = fopen(e2eResults, "r");
       }

       if(e2efp == NULL)
       {
           upLoadResp->status = STATUS_ERROR;
           wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;
           return FALSE;
       }
        
       rbytes = fread(upld->bytes, 1, 256, e2efp); 

       if(rbytes < 256)  
       {
           /* 
            * this means no more bytes after this read
            */
           upld->seqnum = 0;
       }
       else
       { 
           upld->seqnum = upload->next;
       }
		fclose(e2efp);
        e2efp=NULL;

       upld->nbytes = rbytes;

       upLoadResp->status = STATUS_COMPLETE;
#else
       printf("The command not supported\n");
       upLoadResp->status = STATUS_ERROR;
#endif
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   }
   else
   {
       upLoadResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;
   }

   return TRUE;
}
/*
 * wfaStaSetWMM()
 *  TO be ported on a specific plaform for the DUT
 *  This is to set the WMM related parameters at the DUT.
 *  Currently the function is used for GROUPS WMM-AC and WMM general configuration for setting RTS Threshhold, Fragmentation threshold and wmm (ON/OFF)
 *  It is expected that this function will set all the WMM related parametrs for a particular GROUP .
 */
int wfaStaSetWMM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetWMM_t *setwmm = (caStaSetWMM_t *)caCmdBuf;
   char *ifname = setwmm->intf;
   dutCmdResponse_t *setwmmResp = &gGenericResp;
#ifdef _WINDOWS
  char string[256],filename[256];
  FILE *tmpfd;
  int length;
#else

   /*
    * A series of setting need to be done before doing WMM test 
    * Additional steps of configuration may be needed.
    */

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",ifname);
   system(gCmdStr);
#endif
   switch(setwmm->group)
   {
#ifdef WFA_WMM_AC
      case GROUP_WMMAC:
            if(setwmm->action == WMMAC_ADDTS)
			{
			    //wmmacadd_t *addts= &(setwmm->actions.addts);

      			/* This needs to be ported to the specific platform with these TSPEC details*/
		         
			    printf("ADDTS AC PARAMS: dialog id: %d, TID: %d, DIRECTION: %d, PSB: %d, UP: %d,\
			    Fixed %d, MSDU Size: %d, Max MSDU Size %d, MIN SERVICE INTERVAL: %d, MAX SERVICE INTERVAL: %d\
                         ,INACTIVITY: %d,SUSPENSION %d,SERVICE START TIME: %d,MIN DATARATE: %d,MEAN DATA RATE: %d\
                         , PEAK DATA RATE: %d,BURSTSIZE: %d,DELAY BOUND: %d,PHYRATE: %d, SPLUSBW: %f,MEDIUM TIME: %d, ACCESSCAT: %d\n"\
                         ,setwmm->actions.addts.dialog_token,setwmm->actions.addts.tspec.tsinfo.TID\
			             ,setwmm->actions.addts.tspec.tsinfo.direction,setwmm->actions.addts.tspec.tsinfo.PSB,setwmm->actions.addts.tspec.tsinfo.UP\
                         ,setwmm->actions.addts.tspec.Fixed,setwmm->actions.addts.tspec.size, setwmm->actions.addts.tspec.maxsize,\
                         setwmm->actions.addts.tspec.min_srvc,\
                         setwmm->actions.addts.tspec.max_srvc,setwmm->actions.addts.tspec.inactivity,setwmm->actions.addts.tspec.suspension,\
                         setwmm->actions.addts.tspec.srvc_strt_tim,setwmm->actions.addts.tspec.mindatarate,setwmm->actions.addts.tspec.meandatarate\
                         ,setwmm->actions.addts.tspec.peakdatarate,setwmm->actions.addts.tspec.burstsize,\
                         setwmm->actions.addts.tspec.delaybound,setwmm->actions.addts.tspec.PHYrate,setwmm->actions.addts.tspec.sba,\
			             setwmm->actions.addts.tspec.medium_time,setwmm->actions.addts.accesscat);
                         
			    sprintf(gCmdStr, "iwpriv %s acm %d 1 1",ifname,setwmm->actions.addts.accesscat);
			    printf("cmd is  %s\n",gCmdStr);
				system(gCmdStr);
				if(setwmm->send_trig)
				{
					int Sockfd;
	    				struct sockaddr_in psToAddr;
					int TxMsg[512];
	         			Sockfd = wfaCreateUDPSock(setwmm->dipaddr, 12346);
					memset(&psToAddr, 0, sizeof(psToAddr));
					psToAddr.sin_family = AF_INET;
					psToAddr.sin_addr.s_addr = inet_addr(setwmm->dipaddr);
					psToAddr.sin_port = htons(12346);
					usleep(becon_int);
	   				wfaTGSetPrio(Sockfd, setwmm->trig_ac);
					printf("\r\nSending dummy Hello to %s\n",setwmm->dipaddr);
	       				create_apts_msg(APTS_HELLO, TxMsg,0);
	   				sendto(Sockfd, TxMsg, 256, 0, (struct sockaddr *)&psToAddr, sizeof(struct sockaddr));
					close(Sockfd);
				}
                         //system(gCmdStr);
			}
			else
		         printf("DELTS AC PARAMS: TID: %d\n",setwmm->actions.delts);

            setwmmResp->status = STATUS_COMPLETE;
            break;
#endif
      case GROUP_WMMCONF:
#if !defined(_CYGWIN) && !defined(_WINDOWS)
            sprintf(gCmdStr, "iwconfig %s rts_thr %d",ifname,setwmm->actions.config.rts_thr);
            system(gCmdStr);
            sprintf(gCmdStr, "iwconfig %s frag_thr %d",ifname,setwmm->actions.config.frag_thr);
            system(gCmdStr);
            sprintf(gCmdStr, "iwpriv %s wmm %d",ifname,setwmm->actions.config.wmm);
            //system(gCmdStr);
#else
		    switch(vend)
			{
				case WMM_BROADCOMM: 
	                if(!(setwmm->actions.config.wmm))
				        sprintf(gCmdStr, "wl wme 0");
				    else
					    sprintf(gCmdStr, "wl wme 1");
					system(gCmdStr);
				break;

				case WMM_INTEL: 
					sprintf(gCmdStr, "IntDis.bat");
					printf("Executing %s\n",gCmdStr);
					system(gCmdStr);
					strcpy(filename,"intel.txt");
					tmpfd = fopen(filename, "r+");
					if(tmpfd == NULL)
					{
						sprintf(gCmdStr, "IntGet.bat  1>%s 2>c:\\windows\\temp\\mynull",filename);
						printf("Executing %s\n",gCmdStr);
						system(gCmdStr);
							
						tmpfd = fopen(filename, "r+");
						if(tmpfd == NULL)
						{
							setwmmResp->status = STATUS_ERROR;
							wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);   
							*respLen = WFA_TLV_HDR_LEN + 4;

							DPRINT_ERR(WFA_ERR, "file open failed\n");
							return FALSE;
						}
					}
					fgets(string, 256, tmpfd);
					fclose(tmpfd);
					length=strlen(string);
					while(string[length -1] == '\n')
					{
						string[length-1]=0;
						length--;
					}
						
					if(!(setwmm->actions.config.wmm))
						sprintf(gCmdStr, "reg add %s /v TGeEnableBits /t REG_DWORD /d 0 /f",string);
					else
						sprintf(gCmdStr, "reg add %s /v TGeEnableBits /t REG_DWORD /d 1 /f",string);
					printf("Executing %s\n",gCmdStr);
					system(gCmdStr);

					sprintf(gCmdStr, "IntEn.bat");
					printf("Executing %s\n",gCmdStr);
					system(gCmdStr);
				break;

			    case WMM_ATHEROS: 
					sprintf(gCmdStr, "AthDis.bat");
					printf("Executing %s\n",gCmdStr);
					system(gCmdStr);
					strcpy(filename,"Ath.txt");
					tmpfd = fopen(filename, "r+");
					if(tmpfd == NULL)
					{
						sprintf(gCmdStr, "AthGet.bat 1>%s 2>c:\\windows\\temp\\mynull",filename);
						printf("Executing %s\n",gCmdStr);
						system(gCmdStr);
							
						tmpfd = fopen(filename, "r+");
						if(tmpfd == NULL)
						{
							setwmmResp->status = STATUS_ERROR;
							wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);   
							*respLen = WFA_TLV_HDR_LEN + 4;

							DPRINT_ERR(WFA_ERR, "file open failed\n");
							return FALSE;
						}
					}
					fgets(string, 256, tmpfd);
					fclose(tmpfd);
											
					length=strlen(string);
					while(string[length -1] == '\n')
					{
						string[length-1]=0;
						length--;
					}
					if(!(setwmm->actions.config.wmm))
						sprintf(gCmdStr, "reg add %s /v WmeEnabled /t REG_DWORD /d 0 /f",string);
					else
						sprintf(gCmdStr, "reg add %s /v WmeEnabled /t REG_DWORD /d 1 /f",string);
					printf("Executing %s\n",gCmdStr);
				    system(gCmdStr);
											
				    sprintf(gCmdStr, "AthEn.bat");
					printf("Executing %s\n",gCmdStr);
					system(gCmdStr);
				break;
				default:
				    printf("Unknown station %d\n",vend);
				break;
			}  /* switch (vend) */
#endif
            setwmmResp->status = STATUS_COMPLETE;
            break; /* case GROUP_WMMCONF */

	        default:
                 DPRINT_ERR(WFA_ERR, "The group %d is not supported\n",setwmm->group);
                 setwmmResp->status = STATUS_ERROR;
            break;

   }
#if !defined(_CYGWIN) && !defined(_WINDOWS)
   /*
    * bring up the interface
    */
   sprintf(gCmdStr, "ifconfig %s up",ifname);
   system(gCmdStr);
#endif

   wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);
   printf("tag is %d\n",WFA_STA_SET_WMM_RESP_TLV);
   *respLen = WFA_TLV_HDR_LEN + 4;
   return TRUE;
}


int DisableCiscoSupplicant(void)
{
	printf("Inside DisableCiscoSupplicant function ...\n");
	WinExec("AutomateCisco.exe",SW_MAXIMIZE);
	Sleep(30000);
	return 1;
}

int EnableCiscoSupplicant(void)
{
	int ret;
	printf("Inside EnableCiscoSupplicant function ...\n");

	// start the service
	sprintf(gCmdStr, "sc start \"Cisco Secure Services Client\" ");
	DPRINT_INFO(WFA_OUT,"Executing %s\n",gCmdStr);
	ret = system(gCmdStr);
	DPRINT_INFO(WFA_OUT,"Retun value: %d\n",ret);
	Sleep(2000);

	return 1;
}

int GetIntelDeviceID(char * apDeviceID)
{
	FILE *file;
	char prv3Line[96];
	char prv2Line[96];
	char prv1Line[96];
	char prvLine[128];
	char crntLine[128];
	char deviceID[16];
	char * str;

	DPRINT_INFO(WFA_OUT, "Inside GetIntelDeviceID function ...\n");	

	// get the Device ID
	sprintf(gCmdStr, "devcon hwids \"*\" > c:\\windows\\temp\\devid.txt");
	system(gCmdStr);
	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	Sleep(3000);
	// open the file and read for
	file = fopen("c:\\windows\\temp\\devid.txt","r+");
	if(file == NULL)
	{
		//error opening the registry and print error
		printf("\nError opening c:\\windows\\temp\\devid.txt - Device ID dump ");
	}
	else
	{
		for(;;)
		{
			if(fscanf(file, "%127s", crntLine) == EOF)
			{
				DPRINT_ERR(WFA_ERR, "EOF reached, Device ID not found\n");
				fclose(file);
				return TRUE;
			}

			if(strncmp(crntLine, "3945ABG", 14) == 0)
			{
				break;
			}
			strncpy(prv3Line,prv2Line,95);
			strncpy(prv2Line,prv1Line,95);
			strncpy(prv1Line,prvLine,95);
			strcpy(prvLine,crntLine);
		}
		fclose(file);
		printf("Current line is: %s",crntLine);
		printf("PrivLine line is: %s",prvLine);
		printf("Priv1Line line is: %s",prv1Line);
		printf("Priv2Line line is: %s",prv2Line);
		printf("Priv3Line line is: %s",prv3Line);	

		str = strtok(prv3Line,"&");
		str = strtok(NULL,"&");
		strcpy(deviceID,str);		
		printf("\n The Device ID is -  : %s",deviceID);
		strcpy(apDeviceID,deviceID);
	}


}
int GetIntelRegistryID(char * apRegistryID)
{	
	FILE *file;
	char prvLine[128];
	char crntLine[128];

	sprintf(gCmdStr, "reg query HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class /s > c:\\windows\\temp\\test.txt");
	system(gCmdStr);
	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	Sleep(3000);

	// open the file and read for
	file = fopen("c:\\windows\\temp\\test.txt","r+");
	if(file == NULL)
	{
		//error opening the registry and print error
		printf("\nError opening c:\\windows\\temp\\test.txt - registry dump ");
	}
	else
	{
		for(;;)
		{
			if(fscanf(file, "%127s", crntLine) == EOF)
			{
				DPRINT_ERR(WFA_ERR, "EOF reached, Requested mode not set\n");
				fclose(file);
				return TRUE;
			}

			if(strncmp(crntLine, "ModulationType", 14) == 0)
			{
				break;
			}
			strcpy(prvLine,crntLine);
		}
		fclose(file);

		printf("Current line is: %s",crntLine);
		printf("PrivLine line is: %s",prvLine);

		strcpy(apRegistryID,prvLine);
	}

		return TRUE;


}
int setIntelMode( int aMode )
{
///	FILE *file;
//	char prv3Line[96];
//	char prv2Line[96];
//	char prv1Line[96];
//	char prvLine[128];
	char registyID[128];
	char deviceID[16];
//	char * str;

	DPRINT_INFO(WFA_OUT, "Inside setIntelmode function ...\n");	


	// get the Device ID
	GetIntelDeviceID(deviceID);
/*
	sprintf(gCmdStr, "devcon hwids \"*\" > c:\\windows\\temp\\devid.txt");
	system(gCmdStr);
	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	Sleep(3000);

	// open the file and read for
	file = fopen("c:\\windows\\temp\\devid.txt","r+");
	if(file == NULL)
	{
		//error opening the registry and print error
		printf("\nError opening c:\\windows\\temp\\devid.txt - Device ID dump ");
	}
	else
	{
		for(;;)
		{
			if(fscanf(file, "%127s", crntLine) == EOF)
			{
				DPRINT_ERR(WFA_ERR, "EOF reached, Device ID not found\n");
				fclose(file);
				return TRUE;
			}

			if(strncmp(crntLine, "3945ABG", 14) == 0)
			{
				break;
			}
			strncpy(prv3Line,prv2Line,95);
			strncpy(prv2Line,prv1Line,95);
			strncpy(prv1Line,prvLine,95);

			strcpy(prvLine,crntLine);




		}
		fclose(file);
		printf("Current line is: %s",crntLine);
		printf("PrivLine line is: %s",prvLine);
		printf("Priv1Line line is: %s",prv1Line);
		printf("Priv2Line line is: %s",prv2Line);
		printf("Priv3Line line is: %s",prv3Line);	

		str = strtok(prv3Line,"&");
		str = strtok(NULL,"&");
		strcpy(deviceID,str);		
		printf("\n The Device ID is -  : %s",deviceID);

	}
	*/
	// Get the Regstry ID	
		// get the Device registry ID
	GetIntelRegistryID(registyID);
/*
	sprintf(gCmdStr, "reg query HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class /s > c:\\windows\\temp\\test.txt");
	system(gCmdStr);
	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	Sleep(3000);

	// open the file and read for
	file = fopen("c:\\windows\\temp\\test.txt","r+");
	if(file == NULL)
	{
		//error opening the registry and print error
		printf("\nError opening c:\\windows\\temp\\test.txt - registry dump ");
	}
	else
	{
		for(;;)
		{
			if(fscanf(file, "%127s", crntLine) == EOF)
			{
				DPRINT_ERR(WFA_ERR, "EOF reached, Requested mode not set\n");
				fclose(file);
				return TRUE;
			}

			if(strncmp(crntLine, "ModulationType", 14) == 0)
			{
				break;
			}
			strcpy(prvLine,crntLine);
		}
		fclose(file);

		printf("Current line is: %s",crntLine);
		printf("PrivLine line is: %s",prvLine);
	}
	*/
	if(aMode == eModeB)
	{
		sprintf(gCmdStr, "reg add %s /v ModulationType /t REG_SZ /d 0 /f",registyID);
		system(gCmdStr);
		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		Sleep(1000);
		sprintf(gCmdStr, "reg add %s /v BandType /t REG_DWORD /d 0x0 /f",registyID);
		system(gCmdStr);
		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		Sleep(1000);
	}
	else if(aMode == eModeABG)
	{
		sprintf(gCmdStr, "reg add %s /v ModulationType /t REG_SZ /d 2 /f",registyID);
		system(gCmdStr);
		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		Sleep(1000);
		sprintf(gCmdStr, "reg add %s /v BandType /t REG_DWORD /d 0x2 /f",registyID);
		system(gCmdStr);
		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		Sleep(1000);
	}

	sprintf(gCmdStr, "devcon disable *%s*",deviceID);
	system(gCmdStr);
	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	Sleep(2000);
	sprintf(gCmdStr, "devcon enable *%s*",deviceID);
	system(gCmdStr);
	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	Sleep(2000);

	return TRUE;
}
int setIntelPowerSave( BYTE aPowerSave)
{
//	FILE *file;
//	char prvLine[128];
	char registyID[128];
	char deviceID[16];
//	char *str;

	DPRINT_INFO(WFA_OUT, "Inside setIntelPowerSave function ...\n");	

	// get the Device ID
	GetIntelDeviceID(deviceID);

	// Get the Registry ID
	GetIntelRegistryID(registyID);

	if(aPowerSave == 1)
	{
		sprintf(gCmdStr, "reg add %s /v PowerIndex /t REG_SZ /d 5 /f",registyID);
		system(gCmdStr);
		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		Sleep(1000);
	}
	else 
	{
		sprintf(gCmdStr, "reg add %s /v PowerIndex /t REG_SZ /d 0 /f",registyID);
		system(gCmdStr);
		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		Sleep(1000);
	}

	sprintf(gCmdStr, "devcon disable *%s*",deviceID);
	system(gCmdStr);
	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	Sleep(2000);
	sprintf(gCmdStr, "devcon enable *%s*",deviceID);
	system(gCmdStr);
	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	Sleep(2000);

	return TRUE;
}
int wfaStaPresetParameters(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;
   dutCmdResponse_t *PresetParamsResp = &gGenericResp;
   int ret;
   char *intfname = presetParams->intf;
   BYTE presetDone=0;
   int st = 0;

   DPRINT_INFO(WFA_OUT, "Inside wfaStaPresetParameters function ...\n");
   DPRINT_INFO(WFA_OUT,"\nCurrent Supplicant value: %d\n",geSupplicant);
   DPRINT_INFO(WFA_OUT,"\nReceived Supplicant value: %d\n",presetParams->supplicant);
  

#if defined(_CYGWIN) || defined(_WINDOWS)
  /* switch(presetParams->supplicant)
   { 
	   case eWindowsZeroConfig:
	  
		   // Cisco Secure client supplicant
			DisableCiscoSupplicant();

		   // stop the other supplicants and start ZeroConfig
			// WpaSupplicant supplicant
		   sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	       DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		   ret = system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Retun value: %d\n",ret);

		   // stop the Marvell supplicant
   			sprintf(gCmdStr, "Taskkill /T /F /IM Mrv8000x.exe");
			system(gCmdStr);
			Sleep(1000);


		   sprintf(gCmdStr, "sc start wzcsvc");
		   DPRINT_INFO(WFA_OUT,"Executing %s\n",gCmdStr);
		   ret = system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Retun value: %d\n",ret);
		   Sleep(500);
		   sprintf(gCmdStr, "wifi_config -limit %s -enable", gnetIf);
		   system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Executing %s\n",gCmdStr);

		   geSupplicant = eWindowsZeroConfig;
		   DPRINT_INFO(WFA_OUT,"New Supplicant value: %d\n",geSupplicant);
		   
		   presetDone = 1;
		   break;
	   case eMarvell:
		   // stop the other supplicants and start Marvell Supplicant

		   
		   //Disable Cisco supplicant
		   DisableCiscoSupplicant();
		   

		   // WpaSupplicant supplicant
		   sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	       DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		   ret = system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Retun value: %d\n",ret);
		   
		   // Disable Zero Config
		   sprintf(gCmdStr, "wifi_config -limit %s -disable", gnetIf);
		   system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Executing %s\n",gCmdStr);
		   
		   // Run Marvell Supplicant
		   //sprintf(gCmdStr, "\"C:\\Program\ Files\Marvell CB82\Mrv8000x.exe\"");
		   //system(gCmdStr);
			sprintf(gCmdStr, " start \"Marvell\" /D \"c:\\Program\ Files\\Marvell\ CB82\" Mrv8000x.exe");
			system(gCmdStr);
			printf("Executing %s\n",gCmdStr);
		   // Check in the process list that the Mrv8000x.exe is running.

		   geSupplicant = eMarvell;

		   presetDone = 1;
		   break;
	   case eWpaSupplicant:
		   // stop the other supplicants and start WpaSupplicant

			// Cisco Secure client supplicant
			DisableCiscoSupplicant();

		   // stop the Marvell supplicant
   			sprintf(gCmdStr, "Taskkill /T /F /IM Mrv8000x.exe");
			system(gCmdStr);
			Sleep(1000);

			// Zero Config
		   sprintf(gCmdStr, "wifi_config -limit %s -disable", gnetIf);
		   system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Executing %s\n",gCmdStr);

		   sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
		   ret = system(gCmdStr);
		   printf("Retun value: %d\n",ret);
		   Sleep(1000);
	
		   geSupplicant = eWpaSupplicant;
		   printf("supplicant after WpaSupplicant is set: %d\n",geSupplicant);

		   presetDone = 1;
		   break;
	   case eCiscoSecureClient:
		   // stop the other supplicants and start Cisco Secure Client
		   sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	      DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		   ret = system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Retun value: %d\n",ret);

		   // stop the Marvell supplicant
   			sprintf(gCmdStr, "Taskkill /T /F /IM Mrv8000x.exe");
			system(gCmdStr);
			Sleep(1000);

			// Zero Config
		   sprintf(gCmdStr, "wifi_config -limit %s -disable", gnetIf);
		   system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Executing %s\n",gCmdStr);

			// Cisco Secure client supplicant
			EnableCiscoSupplicant();

		   geSupplicant = eCiscoSecureClient;

		   presetDone = 1;
		   break;
	   case eOpen1x:
		   // stop the other supplicants and start Open1x
		   geSupplicant = eOpen1x;

		   break;
	   case eIntelProset:
		   // stop the other supplicants and start IntelProset
		   geSupplicant = eIntelProset;

		   break;		
	   case eDefault:
	   default:
		   geSupplicant = eWindowsZeroConfig;
		   PresetParamsResp->status = STATUS_COMPLETE;
		   wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;
		   break;
   }
   */
   // check for other preset parameters
#ifndef TGN_TB_STATION
	if(presetParams->modeFlag)
	{
		if( vend == WMM_INTEL )
			setIntelMode(presetParams->wirelessMode);
		else
			printf("Not an Intel Sta for setting wirelessmode");
	}
#else

   	if(presetParams->reset != 0)
	{
		switch(presetParams->reset)
		{
		case eResetProg11n:
			sprintf(gCmdStr, "cd %s & reset_default /interface %s /set 11n", WFA_CLI_CMD_DIR, aINTERFACE);	        
			break;
		default:
			printf("The program not supported.\n");
		}

        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}
    if(presetParams->fragFlag == 1)
	{
		sprintf(gCmdStr, "cd %s & SET_FRAG /interface %s /value %d", WFA_CLI_CMD_DIR, aINTERFACE,presetParams->fragThreshold);
        printf("%s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}

	if(presetParams->rtsFlag == 1)
	{

		sprintf(gCmdStr, "cd %s & SET_RTS /interface %s /value %d", WFA_CLI_CMD_DIR, aINTERFACE,presetParams->rtsThreshold);
        printf("%s\n", gCmdStr);

        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}

	if(presetParams->preambleFlag == 1)
	{
		if(presetParams->preamble == eLong)
			sprintf(gCmdStr, "cd %s & STA_SET_PREAMBLE /interface %s /value long", WFA_CLI_CMD_DIR, aINTERFACE);
		else
			sprintf(gCmdStr, "cd %s & STA_SET_PREAMBLE /interface %s /value short", WFA_CLI_CMD_DIR, aINTERFACE);

		printf("%s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}


    if(presetParams->wmmFlag)
	{
		if(presetParams->wmmState == 1)
		{
			sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action on", WFA_CLI_CMD_DIR, aINTERFACE);
	        printf("%s\n", gCmdStr);
		}
		else
		{
			sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action off", WFA_CLI_CMD_DIR, aINTERFACE);
	        printf("%s\n", gCmdStr);
		}

        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}

	if(presetParams->ht == 1)
	{
        //sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action on", WFA_CLI_CMD_DIR, aINTERFACE);
	    //printf("%s\n", gCmdStr);
        tgWMMTestEnable = 0;
	}
	else
	{
		//sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action off", WFA_CLI_CMD_DIR, aINTERFACE);
	    //printf("%s\n", gCmdStr);
        tgWMMTestEnable = 1;
	}

	if(presetParams->modeFlag != 0)
	{
		switch(presetParams->wirelessMode)
		{
		case eModeB:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode BO",WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		case eModeBG:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode BG", WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		case eModeA:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode AO", WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		case eModeAN:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode NA", WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		case eModeGN:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode NG", WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		case eModeNL:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode NL", WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		default:
			printf("other mode does not need to support\n");
        }

        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}

#endif

#ifndef TGN_TB_STATION
	
	if(presetParams->psFlag)
	{
		if( vend == WMM_INTEL )
			setIntelPowerSave(presetParams->legacyPowerSave  );
		else if(vend == WMM_BROADCOMM)
		{
			if(presetParams->legacyPowerSave)
			{
				// call wl utility to execute the powersave mode.
				sprintf(gCmdStr, "wl PM 1");
				system(gCmdStr);
				Sleep(1000);
			}
			else
			{
				// call wl utility to execute the powersave mode.
				sprintf(gCmdStr, "wl PM 0");
				system(gCmdStr);
				Sleep(1000);
			}
		}
		else
			printf("Not an Intel /Broadcom Sta for setting powersave ");
	}
#else

#if 0
    if(presetParams->wmmFlag)
	{
		    if(presetParams->wmmState == 1)
		    {
			    sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action on", WFA_CLI_CMD_DIR, aINTERFACE);
				printf("%s\n", gCmdStr);
			    system(gCmdStr);
                tgWMMTestEnable = 1;
		    }
		    else
		    {
			    sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action off", WFA_CLI_CMD_DIR, aINTERFACE);
				printf("%s\n", gCmdStr);
			    system(gCmdStr);
                tgWMMTestEnable = 0;
		    }
	}
#endif

    if(presetParams->psFlag)
	{
		if(presetParams->legacyPowerSave == 1)
		    sprintf(gCmdStr, "cd %s & sta_set_power_save /interface %s /powersave pspoll", WFA_CLI_CMD_DIR, aINTERFACE);
		else if(presetParams->legacyPowerSave == 2)
			sprintf(gCmdStr, "cd %s & sta_set_power_save /interface %s /powersave fast", WFA_CLI_CMD_DIR, aINTERFACE);
		else if(presetParams->legacyPowerSave == 3)
			sprintf(gCmdStr, "cd %s & sta_set_power_save /interface %s /powersave psnonpoll ", WFA_CLI_CMD_DIR, aINTERFACE);
		else
            sprintf(gCmdStr, "cd %s & sta_set_power_save /interface %s /powersave off", WFA_CLI_CMD_DIR, aINTERFACE);

		printf("%s\n", gCmdStr);
        //system(gCmdStr);
        st = wfaExecuteCLI(gCmdStr);

	    switch(st)
		{
			case 0:
			   presetDone = 1;
			   break;
			case 1:
			    presetDone = 0;
				PresetParamsResp->status = STATUS_ERROR;
				break;
			case 2:
			    presetDone = 0;
				PresetParamsResp->status = STATUS_INVALID;
				break;
		}
		

	}
#endif

	if(presetParams->noack_be != 0 || presetParams->noack_bk != 0 || presetParams->noack_vi != 0 || presetParams->noack_vo != 0)
	{
		sprintf(gCmdStr, "cd %s & set_noack /interface %s /mode %x %x %x %x",WFA_CLI_CMD_DIR,aINTERFACE,presetParams->noack_be-1,presetParams->noack_bk-1,presetParams->noack_vi-1,presetParams->noack_vo-1);
        printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);

	}

    if (presetDone)
    {
		PresetParamsResp->status = STATUS_COMPLETE;
		wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + 4;
    }
    else
    {
		PresetParamsResp->status = STATUS_INVALID;
		wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + 4;
    }


#else
   setPskResp->status = STATUS_INVALID;
   wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;
#endif
	return TRUE;
}

int CiscoConfigGenerateUpperPart(FILE *file)
{
	if(file==NULL) 
	{
		printf("Error: can't Open Config file.\n");
		return 1;
	}
	sprintf(gCmdStr,"<configuration minor_version=\"1\" development_version=\"2\" major_version=\"5\" >\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<networkPolicy>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<allowedAssociationModes>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<openNoEncryption/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<openStaticWep/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<sharedStaticWep/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<open1xDynamicWep/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<wpaPersonalTkip/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<wpaPersonalAes/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<wpa2PersonalTkip/>\n");
    fputs(gCmdStr, file);    
    sprintf(gCmdStr,"\t\t\t<wpa2PersonalAes/>\n");
    fputs(gCmdStr, file);           
    sprintf(gCmdStr,"\t\t\t<wpaEnterpriseTkip/>\n");
    fputs(gCmdStr, file);            
    sprintf(gCmdStr,"\t\t\t<wpaEnterpriseAes/>\n");
    fputs(gCmdStr, file);               
    sprintf(gCmdStr,"\t\t\t<wpa2EnterpriseTkip/>\n");
    fputs(gCmdStr, file);               
    sprintf(gCmdStr,"\t\t\t<wpa2EnterpriseAes/>\n");
    fputs(gCmdStr, file);             
    sprintf(gCmdStr,"\t\t\t<cckmEnterpriseTkip/>\n");
    fputs(gCmdStr, file);               
    sprintf(gCmdStr,"\t\t\t<cckmEnterpriseAes/>\n");
    fputs(gCmdStr, file);               
    sprintf(gCmdStr,"\t\t</allowedAssociationModes>\n");
    fputs(gCmdStr, file);               
    sprintf(gCmdStr,"\t\t<allowedEapMethods>\n");
    fputs(gCmdStr, file);              
    sprintf(gCmdStr,"\t\t\t<eapMd5/>\n");
    fputs(gCmdStr, file); 
    sprintf(gCmdStr,"\t\t\t<eapMschapv2/>\n");
    fputs(gCmdStr, file);  
    sprintf(gCmdStr,"\t\t\t<eapTls/>\n");
    fputs(gCmdStr, file);             
    sprintf(gCmdStr,"\t\t\t<eapFast/>\n");
    fputs(gCmdStr, file);             
    sprintf(gCmdStr,"\t\t\t<eapGtc/>\n");
    fputs(gCmdStr, file);              
    sprintf(gCmdStr,"\t\t\t<leap/>\n");
    fputs(gCmdStr, file);              
    sprintf(gCmdStr,"\t\t\t<eapPeap/>\n");
    fputs(gCmdStr, file);             
    sprintf(gCmdStr,"\t\t\t<eapTtls/>\n");
    fputs(gCmdStr, file);           
    sprintf(gCmdStr,"\t\t</allowedEapMethods>\n");
    fputs(gCmdStr, file);           
    sprintf(gCmdStr,"\t</networkPolicy>\n");
    fputs(gCmdStr, file);

	return 1;
}
int CiscoConfigGenerateLowerPart(FILE *file)
{
	if(file==NULL) 
	{
		printf("Error: can't Open Config file.\n");
		return 1;
	}
	sprintf(gCmdStr,"\t<connectionSettings>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<connectionBehaviorAtLogon>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<attemptConnectionAfterUserLogon/>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</connectionBehaviorAtLogon>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<validateWpaHandshake>true</validateWpaHandshake>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<defaultConnectionTimeout>40</defaultConnectionTimeout>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<defaultAssociationTimeout>3</defaultAssociationTimeout>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</connectionSettings>\n");
    fputs(gCmdStr, file);    
    sprintf(gCmdStr,"\t<userControlPolicy>\n");
    fputs(gCmdStr, file);          
    sprintf(gCmdStr,"\t\t<allowedMedia>\n");
    fputs(gCmdStr, file);            
    sprintf(gCmdStr,"\t\t\t<wifi/>\n");
    fputs(gCmdStr, file);         
    sprintf(gCmdStr,"\t\t</allowedMedia>\n");
    fputs(gCmdStr, file);           
    sprintf(gCmdStr,"\t\t<allowVpn>false</allowVpn>\n");
    fputs(gCmdStr, file);          
//    sprintf(gCmdStr,"\t\t<allowRunScriptAfterConnect>false</allowRunScriptAfterConnect>\n");
//    fputs(gCmdStr, file);           
    sprintf(gCmdStr,"\t</userControlPolicy>\n");
    fputs(gCmdStr, file);      
    sprintf(gCmdStr,"</configuration>\n");
    fputs(gCmdStr, file);
	
	return 1;
}

int CiscoEAPConfigGenerateUpperPart(FILE *file, char *ssid)
{
	if(file==NULL) 
	{
		printf("Error: can't Open Config file.\n");
		return 1;
	}

    sprintf(gCmdStr,"\t<networks>\n",gnetIf);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<globalNetworks>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<wifiNetwork>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t<displayName>%s</displayName>\n",ssid);
    fputs(gCmdStr, file);    
    sprintf(gCmdStr,"\t\t\t\t<connectionTimeout>40</connectionTimeout>\n");
    fputs(gCmdStr, file);                     
    sprintf(gCmdStr,"\t\t\t\t<ssid>\n");
    fputs(gCmdStr, file);                 
	sprintf(gCmdStr,"\t\t\t\t\t<name>%s</name>\n",ssid);
    fputs(gCmdStr, file);                  
    sprintf(gCmdStr,"\t\t\t\t</ssid>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t\t\t<associationTimeout>3</associationTimeout>\n");
    fputs(gCmdStr, file);                     
    sprintf(gCmdStr,"\t\t\t\t<CCX>\n");
    fputs(gCmdStr, file);                 
    sprintf(gCmdStr,"\t\t\t\t\t<Diagnostics>\n");
    fputs(gCmdStr, file);                
    sprintf(gCmdStr,"\t\t\t\t\t\t<AuthorizedProfile>false</AuthorizedProfile>\n");
    fputs(gCmdStr, file);                 
    sprintf(gCmdStr,"\t\t\t\t\t\t<Channel>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<EnableClientReporting>false</EnableClientReporting>\n");
    fputs(gCmdStr, file);                         
    sprintf(gCmdStr,"\t\t\t\t\t\t</Channel>\n");
    fputs(gCmdStr, file);                            
    sprintf(gCmdStr,"\t\t\t\t\t</Diagnostics>\n");
    fputs(gCmdStr, file);                             
    sprintf(gCmdStr,"\t\t\t\t\t<RadioMeasurement>\n");
    fputs(gCmdStr, file);                         
    sprintf(gCmdStr,"\t\t\t\t\t\t<disabled/>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t\t\t\t</RadioMeasurement>\n");
    fputs(gCmdStr, file);                    
    sprintf(gCmdStr,"\t\t\t\t</CCX>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t<authenticationNetwork>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t<userAuthentication>\n");
    fputs(gCmdStr, file);

	return TRUE;

}
int CiscoEAPConfigGenerateLowerPart(FILE *file,char *encrType,char *secuType)
{
	if(file==NULL) 
	{
		printf("Error: can't Open Config file.\n");
		return 1;
	}
    sprintf(gCmdStr,"\t\t\t\t\t</userAuthentication>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t<setting802.1x>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t<authPeriod>30</authPeriod>\n");
    fputs(gCmdStr, file);	                   
    sprintf(gCmdStr,"\t\t\t\t\t\t<heldPeriod>60</heldPeriod>\n");
    fputs(gCmdStr, file);                    
    sprintf(gCmdStr,"\t\t\t\t\t\t<startPeriod>30</startPeriod>\n");
    fputs(gCmdStr, file);                          
    sprintf(gCmdStr,"\t\t\t\t\t\t<maxStart>3</maxStart>\n");
    fputs(gCmdStr, file);                          
    sprintf(gCmdStr,"\t\t\t\t\t</setting802.1x>\n");
    fputs(gCmdStr, file);    
    sprintf(gCmdStr,"\t\t\t\t\t<associationMode>\n");
    fputs(gCmdStr, file);

	if(strncmp(secuType, "wpa2", 4) == 0)
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t<wpa2>\n");
		fputs(gCmdStr, file);    
	}
	else if (strncmp(secuType, "wpa", 3) == 0)
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t<wpa>\n");
		fputs(gCmdStr, file);  
	}
	if((strcmp(encrType, "TKIP") == 0) || (strcmp(encrType, "tkip") == 0))
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t\t<encryption>TKIP</encryption>\n");
		fputs(gCmdStr, file);   
	}
	else if ((strcmp(encrType, "AES-CCMP") == 0) || (strcmp(encrType, "aes-ccmp") == 0))
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t\t<encryption>AES</encryption>\n");
		fputs(gCmdStr, file);   
	}
	if(strncmp(secuType, "wpa2", 4) == 0)
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t</wpa2>\n");
		fputs(gCmdStr, file);    
	}
	else if (strncmp(secuType, "wpa", 3) == 0)
	{
		sprintf(gCmdStr,"\t\t\t\t\t\t</wpa>\n");
		fputs(gCmdStr, file);  
	}

    sprintf(gCmdStr,"\t\t\t\t\t</associationMode>\n");
    fputs(gCmdStr, file);                           
    sprintf(gCmdStr,"\t\t\t\t</authenticationNetwork>\n");
    fputs(gCmdStr, file);                               
    sprintf(gCmdStr,"\t\t\t</wifiNetwork>\n");
    fputs(gCmdStr, file);                         
    sprintf(gCmdStr,"\t\t</globalNetworks>\n");
    fputs(gCmdStr, file);                      
    sprintf(gCmdStr,"\t\t<group>\n");
    fputs(gCmdStr, file);    
    sprintf(gCmdStr,"\t\t\t<groupName>Default</groupName>\n");
    fputs(gCmdStr, file); 
    sprintf(gCmdStr,"\t\t\t<allowUserToSeeScanlist>true</allowUserToSeeScanlist>\n");
    fputs(gCmdStr, file);             
    sprintf(gCmdStr,"\t\t</group>\n");
    fputs(gCmdStr, file);          
    sprintf(gCmdStr,"\t</networks>\n");
    fputs(gCmdStr, file);

	return TRUE;
}



int wfaStaSetEapFASTCiscoSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{

   caStaSetEapFAST_t *setFAST = (caStaSetEapFAST_t *)caCmdBuf;
   char *ifname = setFAST->intf;
   dutCmdResponse_t *setEapFastResp = &gGenericResp;
   FILE *file;
   int ret;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapFASTCiscoSupplicant ...\n");

    // stop the service
   	sprintf(gCmdStr, "sc stop \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

	file = fopen("c:\\windows\\temp\\tmp.xml", "w+");
   //file = fopen("c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\userConfiguration.xml", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {    
	CiscoConfigGenerateUpperPart(file);
	CiscoEAPConfigGenerateUpperPart(file,&(setFAST->ssid[0]));

    sprintf(gCmdStr,"\t\t\t\t\t\t<authenticationMethod>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t<eapFast>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<doNotValidateServerCertificate/>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<unprotectedIdentityPattern encryptContent=\"true\" >anonymous</unprotectedIdentityPattern>\n");
    fputs(gCmdStr, file);
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<enableFastReconnect>\n");
    fputs(gCmdStr, file);     
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<alwaysAttempt/>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</enableFastReconnect>\n");
    fputs(gCmdStr, file);   
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<usePac>\n");
    fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<allowUnauthPacProvisioning>true</allowUnauthPacProvisioning>\n");
    fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<validateWithSpecificPacs/>\n");
    fputs(gCmdStr, file); 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</usePac>\n");
    fputs(gCmdStr, file);                       
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<enablePosture>true</enablePosture>\n");
    fputs(gCmdStr, file);                                        
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<authMethods>\n");
    fputs(gCmdStr, file);                                       
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<builtinMethods>\n");
    fputs(gCmdStr, file);

	if((strncmp(setFAST->innerEAP, "MSCHAP", 6) == 0) || (strncmp(setFAST->innerEAP, "mschap", 6) == 0))
	{
	// for MSCHAP
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t<authenticateWithPassword>\n");
		fputs(gCmdStr, file);                                     
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t<protectedIdentityPattern encryptContent=\"true\" >%s</protectedIdentityPattern>\n",setFAST->username);
		fputs(gCmdStr, file);  

		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t<passwordSource>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t\t<passwordFromProfile encryptContent=\"true\" >%s</passwordFromProfile>\n",setFAST->passwd);
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t</passwordSource>\n");
		fputs(gCmdStr, file);
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t<methods>\n");
		fputs(gCmdStr, file);                                                        
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t\t<eapMschapv2/>\n");
		fputs(gCmdStr, file);                                                 
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t</methods>\n");
		fputs(gCmdStr, file);                                              
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t</authenticateWithPassword>\n");
		fputs(gCmdStr, file);
	}
	else if((strncmp(setFAST->innerEAP, "GTC", 3) == 0) || (strncmp(setFAST->innerEAP, "gtc", 3) == 0))
	{
	// for GTC
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t<authenticateWithToken>\n");
		fputs(gCmdStr, file);                                     
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t<protectedIdentityPattern encryptContent=\"true\" >%s</protectedIdentityPattern>\n",setFAST->username);
		fputs(gCmdStr, file);                                   
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t<tokenSource>\n");
		fputs(gCmdStr, file);   
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t\t<passwordFromOtherToken/>\n");
		fputs(gCmdStr, file);   
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t</tokenSource>\n");
		fputs(gCmdStr, file);   	                                        
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t<methods>\n");
		fputs(gCmdStr, file);                                               
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t\t<eapGtc/>\n");
		fputs(gCmdStr, file);                                                 
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t\t</methods>\n");
		fputs(gCmdStr, file);                                                  
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t\t</authenticateWithToken>\n");
		fputs(gCmdStr, file);                                               
	}                
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t</builtinMethods>\n");
    fputs(gCmdStr, file);                                                 
	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</authMethods>\n");
    fputs(gCmdStr, file);                                             
	sprintf(gCmdStr,"\t\t\t\t\t\t\t</eapFast>\n");
    fputs(gCmdStr, file);                                             
	sprintf(gCmdStr,"\t\t\t\t\t\t</authenticationMethod>\n");
    fputs(gCmdStr, file); 

	if((strncmp(setFAST->innerEAP, "MSCHAP", 6) == 0) || (strncmp(setFAST->innerEAP, "mschap", 6) == 0))
	{
		//for MSCHAP
		sprintf(gCmdStr,"\t\t\t\t\t\t<collectionBehavior/>\n");
		fputs(gCmdStr, file); 	
	}
	else if((strncmp(setFAST->innerEAP, "GTC", 3) == 0) || (strncmp(setFAST->innerEAP, "gtc", 3) == 0))
	{
		//for GTC
		sprintf(gCmdStr,"\t\t\t\t\t\t<collectionBehavior>\n");
		fputs(gCmdStr, file); 	
		sprintf(gCmdStr,"\t\t\t\t\t\t\t<withToken>\n");
		fputs(gCmdStr, file); 	
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<cachePinForTokenFromUser>\n");
		fputs(gCmdStr, file); 	                        
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t\t<never/>\n");
		fputs(gCmdStr, file); 	                             
		sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</cachePinForTokenFromUser>\n");
		fputs(gCmdStr, file); 	                                  
		sprintf(gCmdStr,"\t\t\t\t\t\t\t</withToken>\n");
		fputs(gCmdStr, file); 	                                    
		sprintf(gCmdStr,"\t\t\t\t\t\t</collectionBehavior>\n");
		fputs(gCmdStr, file);                     
	}       


	CiscoEAPConfigGenerateLowerPart(file,setFAST->encrptype,setFAST->keyMgmtType);
	CiscoConfigGenerateLowerPart(file);
  }
  fclose(file);

  // sign the xml file
  sprintf(gCmdStr, "SignProfile.bat c:\\windows\\temp\\tmp.xml c:\\windows\\temp\\tmp1.xml");
	system(gCmdStr);
	Sleep(1000);
  // copy to the destnationfolder
	sprintf(gCmdStr, "copy /Y c:\\windows\\temp\\tmp1.xml \"c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\configuration.xml\"");
	ret=system(gCmdStr);
	Sleep(1000);
		printf("Executing %s\n",gCmdStr);
	printf("Return value is %d\n",ret);
  /* start the service */

	sprintf(gCmdStr, "sc start \"Cisco Secure Services Client\"");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);


   setEapFastResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;


	return TRUE;
}

int wfaStaSetEapFASTWpaSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{

   caStaSetEapFAST_t *setFAST = (caStaSetEapFAST_t *)caCmdBuf;
   char *ifname = setFAST->intf;
   dutCmdResponse_t *setEapFastResp = &gGenericResp;
   FILE *file;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapFASTWpaSupplicant ...\n");

   file = fopen("c:\\WFA\\WpaSupplicant\\wpa_supplicant.conf", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {    
	  sprintf(gCmdStr,"ctrl_interface=\\Device\\NPF_%s\n",gnetIf);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"ap_scan=2\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"network={\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tssid=\"%s\"\n",setFAST->ssid);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tkey_mgmt=WPA-EAP\n");
	  fputs(gCmdStr, file);

	  if(strncmp(setFAST->keyMgmtType, "wpa2", 4) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA2\n");
		  fputs(gCmdStr, file);
	//	  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		//  fputs(gCmdStr, file);
	  } else if (strncmp(setFAST->keyMgmtType, "wpa", 3) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA\n");
		  fputs(gCmdStr, file);
//		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
//		  fputs(gCmdStr, file);
	  }

	  if((strncmp(setFAST->encrptype, "TKIP",4) == 0) || (strncmp(setFAST->encrptype, "tkip",4) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
		  fputs(gCmdStr, file);
	  }
	  else if((strncmp(setFAST->encrptype, "AES-CCMP",8) == 0) || (strncmp(setFAST->encrptype, "aes-ccmp",8) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		  fputs(gCmdStr, file);
	  }

	  sprintf(gCmdStr,"\teap=FAST\n");
	  fputs(gCmdStr, file);

// For WAP2 Test Plan 

	  sprintf(gCmdStr,"\tpac_file=\"%s\"\n",setFAST->pacFileName);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tphase1=\"fast_provisioning=2\"\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tphase2=\"auth=%s\"\n",setFAST->innerEAP);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tanonymous_identity=\"anonymous\"\n");
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tidentity=\"%s\"\n",setFAST->username);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tpassword=\"%s\"\n",setFAST->passwd);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"}\n");
  	  fputs(gCmdStr, file);

  }
  fclose(file);

  /* start the service and stop the service */

	sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

	sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

    printf("Executing %s\n",gCmdStr);
    system(gCmdStr);

	setEapFastResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV,4, (BYTE *)setEapFastResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;
}
int wfaStaSetEapFAST(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEapFAST_t *setFAST= (caStaSetEapFAST_t *)caCmdBuf;
	char *ifname = setFAST->intf;
	dutCmdResponse_t *setEapFastResp = &gGenericResp;

#if !defined(_CYGWIN) && !defined(_WINDOWS)

	sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setFAST->ssid);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setFAST->username);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setFAST->passwd);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap FAST", ifname);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 pac_file '\"%s/%s\"'", ifname, CERTIFICATES_PATH,     setFAST->pacFileName);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 anonymous_identity '\"anonymous\"'", ifname);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase1 '\"fast_provisioning=1\"'", ifname);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase2 '\"auth=%s\"'", ifname,setFAST->innerEAP);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
	system(gCmdStr);

	setEapFastResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

#else
   switch(geSupplicant)
   {
	   case eWindowsZeroConfig:
		   setEapFastResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;			
		   break;
	   case eMarvell:
		   setEapFastResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;	
		   break;
	   case eWpaSupplicant:
		   wfaStaSetEapFASTWpaSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eCiscoSecureClient:
		   wfaStaSetEapFASTCiscoSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eOpen1x:
		   //wfaStaSetEapSIMOpen1x(len,caCmdBuf,respLen,respBuf);
		   break;
	   default:
		   setEapFastResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;	
		   break;
   }
#endif

	return TRUE;
}

int wfaStaSetEapAKAWpaSupplicant(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapAKA_t *setAKA = (caStaSetEapAKA_t *)caCmdBuf;
   char *ifname = setAKA->intf;
   dutCmdResponse_t *setEapAkaResp = &gGenericResp;
   FILE *file;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetEapAKAWpaSupplicant ...\n");

   file = fopen("c:\\WFA\\WpaSupplicant\\wpa_supplicant.conf", "w+");
  /* we create a empty file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {    
	  sprintf(gCmdStr,"ctrl_interface=\\Device\\NPF_%s\n",gnetIf);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"ap_scan=2\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"network={\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tssid=\"%s\"\n",setAKA->ssid);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tkey_mgmt=WPA-EAP\n");
	  fputs(gCmdStr, file);

	  if(strncmp(setAKA->keyMgmtType, "wpa2", 4) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA2\n");
		  fputs(gCmdStr, file);
	//	  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		//  fputs(gCmdStr, file);
	  } else if (strncmp(setAKA->keyMgmtType, "wpa", 3) == 0)
	  {
		  sprintf(gCmdStr,"\tproto=WPA\n");
		  fputs(gCmdStr, file);
//		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
//		  fputs(gCmdStr, file);
	  }

	  if((strncmp(setAKA->encrptype, "TKIP",4) == 0) || (strncmp(setAKA->encrptype, "tkip",4) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=TKIP\n");
		  fputs(gCmdStr, file);
	  }
	  else if((strncmp(setAKA->encrptype, "AES-CCMP",8) == 0) || (strncmp(setAKA->encrptype, "aes-ccmp",8) == 0))
	  {
		  sprintf(gCmdStr,"\tpairwise=CCMP\n");
		  fputs(gCmdStr, file);
	  }

	  sprintf(gCmdStr,"\teap=AKA\n");
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"\tphase1=\"result_ind=1\"\n");
	  fputs(gCmdStr, file);
// For WAP2 Test Plan 

	  sprintf(gCmdStr,"\tidentity=\"%s\"\n",setAKA->username);
	  fputs(gCmdStr, file);

	  sprintf(gCmdStr,"\tpassword=\"%s\"\n",setAKA->passwd);
	  fputs(gCmdStr, file);
	  sprintf(gCmdStr,"}\n");
  	  fputs(gCmdStr, file);
  }
  fclose(file);

  /* start the service and stop the service */

	sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

	sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
	system(gCmdStr);
	printf("Executing %s\n",gCmdStr);

    printf("Executing %s\n",gCmdStr);
    system(gCmdStr);

	setEapAkaResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);   
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;
}

int wfaStaSetEapAKA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEapAKA_t *setAKA= (caStaSetEapAKA_t *)caCmdBuf;
	char *ifname = setAKA->intf;
	dutCmdResponse_t *setEapAkaResp = &gGenericResp;

#if !defined(_CYGWIN) && !defined(_WINDOWS)


	sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", ifname);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", ifname, setAKA->ssid);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt WPA-EAP", ifname);
	system(gCmdStr);
	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto WPA2", ifname);
	system(gCmdStr);
	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 proto CCMP", ifname);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 eap AKA", ifname);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 phase1 \"result_ind=1\");
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 identity '\"%s\"'", ifname, setAKA->username);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s set_network 0 password '\"%s\"'", ifname, setAKA->passwd);
	system(gCmdStr);

	sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", ifname);
	system(gCmdStr);

	setEapAkaResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
#else
   switch(geSupplicant)
   {
	   case eWindowsZeroConfig:
		   setEapAkaResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;			
		   break;
	   case eMarvell:
		   setEapAkaResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;	
		   break;
	   case eWpaSupplicant:
		   wfaStaSetEapAKAWpaSupplicant(len,caCmdBuf,respLen,respBuf);
		   break;
	   case eCiscoSecureClient:
		   setEapAkaResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;	
		   break;
	   case eOpen1x:
		   //wfaStaSetEapSIMOpen1x(len,caCmdBuf,respLen,respBuf);
		   break;
	   default:
		   setEapAkaResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;	
		   break;
   }
#endif
	return TRUE;
}


int wfaStaSetSystime(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetSystime_t *systime = (caStaSetSystime_t *)caCmdBuf;
   dutCmdResponse_t *setSystimeResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetSystime ...\n"); 

   sprintf(gCmdStr, "date %d-%d-%d",systime->month,systime->date,systime->year);
   system(gCmdStr);
   printf("Executing %s\n",gCmdStr);

   sprintf(gCmdStr, "time %d:%d:%d", systime->hours,systime->minutes,systime->seconds);
   system(gCmdStr);
   printf("Executing %s\n",gCmdStr);

   setSystimeResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_SYSTIME_RESP_TLV, 4, (BYTE *)setSystimeResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}


void RefreshTaskbarNotificationArea()
{
    HWND hNotificationArea;
    RECT r;
	LONG x ;
	LONG y ;
    GetClientRect(hNotificationArea = FindWindowEx(FW(FW(FW(NULL, L"Shell_TrayWnd"), L"TrayNotifyWnd"), L"SysPager"),NULL,L"ToolbarWindow32",L"Notification Area"),&r);
;    
    for ( x = 0; x < r.right; x += 5)
        for ( y = 0; y < r.bottom; y += 5)
            SendMessage(
                hNotificationArea,
                WM_MOUSEMOVE,
                0,
                (y << 16) + x);
} 
int wfaStaSet11n(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf) 
{
	
	caSta11n_t * v11nParams = (caSta11n_t *)caCmdBuf;
	dutCmdResponse_t *v11nParamsResp = &gGenericResp;
#ifndef _WINDOWS
	char *intf = v11nParams->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st=0, status = STATUS_ERROR;

	DPRINT_INFO(WFA_OUT, "START - wfaStaSet11n at interface %s\n", intf); 
	//TODO

	if(v11nParams->addba_reject != 0xFF && v11nParams->addba_reject < 2)
	{
        //sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_ADDBA_REJECT", intf, capstr[v11nParams->addba_reject]);
        sprintf(gCmdStr, "cd %s & set_addba_reject /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->addba_reject]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_addba_reject failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}
	
    if(v11nParams->ampdu != 0xFF && v11nParams->ampdu < 2)
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_AMPDU", intf, capstr[v11nParams->ampdu]);
        sprintf(gCmdStr, "cd %s & set_ampdu /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->ampdu]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_ampdu failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}
	
    if(v11nParams->amsdu != 0xFF && v11nParams->amsdu < 2)
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_AMSDU", intf, capstr[v11nParams->amsdu]);
        sprintf(gCmdStr, "cd %s & set_amsdu /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->amsdu]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_amsdu failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

    if(v11nParams->greenfield != 0xFF && v11nParams->greenfield < 2)
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_GREENFIELD", intf, capstr[v11nParams->greenfield]);
        sprintf(gCmdStr, "cd %s & set_greenfield /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->greenfield]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "_set_greenfield failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

    if(v11nParams->mcs32!= 0xFF && v11nParams->mcs32 < 2 && v11nParams->mcs_fixedrate[0] != '\0')
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /mcs32 %s", WFA_CLI_CMD_DIR, "SET_MCS", intf, capstr[v11nParams->mcs32]);
        sprintf(gCmdStr, "cd %s & set_mcs /interface %s /fixedRate %s /mcs32 %s /BW %d", WFA_CLI_CMD_DIR, intf, v11nParams->mcs_fixedrate, capstr[v11nParams->mcs32],g11nChnlWidth);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_mcs failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	} 
	else if (v11nParams->mcs32!= 0xFF && v11nParams->mcs32 < 2 && v11nParams->mcs_fixedrate[0] == '\0')
	{
        //sprintf(gCmdStr, "%s\%s /interface %s /mcs32 %s", WFA_CLI_CMD_DIR, "SET_MCS", intf, v11nParams->mcs_supported);
        sprintf(gCmdStr, "cd %s & set_mcs /interface %s  /fixedRate null /mcs32 %s /BW %d", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->mcs32],g11nChnlWidth);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_mcs32 failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}

	} 
	else if (v11nParams->mcs32 == 0xFF && v11nParams->mcs_fixedrate[0] != '\0')
	{
		sprintf(gCmdStr, "cd %s & set_mcs /interface %s /fixedRate %s /mcs32 disable /BW %d", WFA_CLI_CMD_DIR, intf, v11nParams->mcs_fixedrate,g11nChnlWidth);
	}

    if(v11nParams->rifs_test != 0xFF && v11nParams->rifs_test < 2)
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_RIFS_TEST", intf, capstr[v11nParams->rifs_test]);
        sprintf(gCmdStr, "cd %s & set_rifs_test /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->rifs_test]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_rifs_test failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

    if(v11nParams->sgi20 != 0xFF && v11nParams->sgi20 < 2)
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_SGI20", intf, capstr[v11nParams->sgi20]);
        sprintf(gCmdStr, "cd %s & set_sgi20 /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->sgi20]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_sgi20 failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	if(v11nParams->smps != 0xFFFF)
	{
	    if(v11nParams->smps == 0)
	    {
            sprintf(gCmdStr, "cd %s & set_smps /interface %s /mode dynamic",WFA_CLI_CMD_DIR, intf);
	    }
	    else if(v11nParams->smps == 1)
	    {
            sprintf(gCmdStr, "cd %s & set_smps /interface %s /mode static", WFA_CLI_CMD_DIR, intf);
	    }
	    else if(v11nParams->smps == 2)
		{
            sprintf(gCmdStr, "cd %s & set_smps /interface %s /mode nolimit", WFA_CLI_CMD_DIR, intf);
	    }
        printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_smps failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	if(v11nParams->stbc_rx != 0xFFFF)
	{
		sprintf(gCmdStr, "cd %s & set_stbc_rx /interface %s /streams %i", WFA_CLI_CMD_DIR, intf, v11nParams->stbc_rx);
		printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_stbc_rx failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}
	
	if(v11nParams->width[0] != '\0')
	{
		sprintf(gCmdStr, "cd %s & set_11n_channel_width /interface %s /width %s", WFA_CLI_CMD_DIR, intf, v11nParams->width);
		printf("RUN: %s\n", gCmdStr);
		g11nChnlWidth = atoi(v11nParams->width);
        st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_11n_channel_width failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}

	}
	
    if(v11nParams->_40_intolerant != 0xFF && v11nParams->_40_intolerant < 2)
	{
		sprintf(gCmdStr, "cd %s & set_40_intolerant /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->_40_intolerant]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		printf("st %i\n", st);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_40_intolerant failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}

	}

	if(v11nParams->txsp_stream != 0 && v11nParams->txsp_stream <4)
	{
		sprintf(gCmdStr, "cd %s & set_txsp_stream /interface %s /value %u", WFA_CLI_CMD_DIR, intf, v11nParams->txsp_stream);
		printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
		printf("st %i\n", st);
		if(st != 0)
		{
			v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_txsp_stream failed");
			wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}

	}

	if(v11nParams->rxsp_stream != 0 && v11nParams->rxsp_stream < 4)
	{
        sprintf(gCmdStr, "cd %s & set_rxsp_stream /interface %s /value %u", WFA_CLI_CMD_DIR, intf, v11nParams->rxsp_stream);
		printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
		printf("st %i\n", st);
		if(st != 0)
		{
			v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_rxsp_stream failed");
			wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	v11nParamsResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, 4, (BYTE *)v11nParamsResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	return TRUE;
}

int wfaStaSetWireless(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf){
	
	caStaSetWireless_t * staWirelessParams = (caStaSetWireless_t *)caCmdBuf;
	dutCmdResponse_t *staWirelessResp = &gGenericResp;
#ifndef _WINDOWS
	char *intf = staWirelessParams->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st = 0;
	
	DPRINT_INFO(WFA_OUT, "START - wfaStaSetWireless \n");
	if((staWirelessParams->noAck[NOACK_BE] == 0 || staWirelessParams->noAck[NOACK_BE] == 1) && 
		(staWirelessParams->noAck[NOACK_BK] == 0 ||  staWirelessParams->noAck[NOACK_BK] == 1) &&
		(staWirelessParams->noAck[NOACK_VI] == 0 || staWirelessParams->noAck[NOACK_VI] == 1) &&
		(staWirelessParams->noAck[NOACK_VO] == 0 || staWirelessParams->noAck[NOACK_VO] == 0) )
	{
		sprintf(gCmdStr, "cd %s & set_noack /interface %s /mode %x %x %x %x", staWirelessParams->noAck[NOACK_BE], staWirelessParams->noAck[NOACK_BK], staWirelessParams->noAck[NOACK_VI], staWirelessParams->noAck[NOACK_VO]);
        printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
        printf("st %i\n", st);
		if(st != 0)
		{
			staWirelessResp->status = STATUS_ERROR;
			strcpy(staWirelessResp->cmdru.info, "set_noack failed");
		}
	}

	staWirelessResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_WIRELESS_RESP_TLV, 4, (BYTE *)staWirelessResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	return TRUE;
}

int wfaStaSendADDBA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf){
	caStaSetSendADDBA_t *staSendADDBA = (caStaSetSendADDBA_t *)caCmdBuf;
	dutCmdResponse_t *staSendADDBAResp = &gGenericResp;
#ifndef _WINDOWS
	char *intf = caStaSetSendADDBA->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;

	DPRINT_INFO(WFA_OUT, "START - wfaStaSendADDBA \n"); 

	sprintf(gCmdStr, "cd %s & send_addba /interface %s /tid %i", WFA_CLI_CMD_DIR, intf, staSendADDBA->tid);
	printf("RUN: %s\n", gCmdStr);
	st = wfaExecuteCLI(gCmdStr);

	switch(st)
	{
	case 0:
	   staSendADDBAResp->status = STATUS_COMPLETE;
	   break;
	case 1:
		staSendADDBAResp->status = STATUS_ERROR;
		break;
	case 2:
		staSendADDBAResp->status = STATUS_INVALID;
		break;
	}

	wfaEncodeTLV(WFA_STA_SET_SEND_ADDBA_RESP_TLV, 4, (BYTE *)staSendADDBAResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	return TRUE;
}

int wfaStaSetRIFS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetRIFS_t *setRIFS = (caStaSetRIFS_t *)caCmdBuf;
#ifndef _WINDOWS
	char *intf = setRIFS->intf;
#else
	char *intf = aINTERFACE;
#endif

    dutCmdResponse_t *staSetRIFSResp = &gGenericResp;
	int st;
	
	sprintf(gCmdStr, "cd %s & set_rifs_test /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[setRIFS->action]);
	printf("RUN: %s\n", gCmdStr);
	st = wfaExecuteCLI(gCmdStr);

	switch(st)
	{
	case 0:
	   staSetRIFSResp->status = STATUS_COMPLETE;
	   break;
	case 1:
		staSetRIFSResp->status = STATUS_ERROR;
		break;
	case 2:
		staSetRIFSResp->status = STATUS_INVALID;
		break;
	}

	wfaEncodeTLV(WFA_STA_SET_RIFS_TEST_RESP_TLV, 4, (BYTE *)staSetRIFSResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;

}

int wfaStaSendCoExistMGMT(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSendCoExistMGMT_t *sendMGMT = (caStaSendCoExistMGMT_t *)caCmdBuf;
#ifndef _WINDOWS
	char *intf = sendMGMT->intf;
#else
	char *intf = aINTERFACE;
#endif
    dutCmdResponse_t *staSendMGMTResp = &gGenericResp;
	int st = 0;
	
	sprintf(gCmdStr, "cd %s & send_coexist_mgmt /interface %s /type %s /value %s", WFA_CLI_CMD_DIR, intf, sendMGMT->type, sendMGMT->value);
	st = wfaExecuteCLI(gCmdStr);
	printf("%s\n", gCmdStr);

	switch(st)
	{
	case 0:
	   staSendMGMTResp->status = STATUS_COMPLETE;
	   break;
	case 1:
		staSendMGMTResp->status = STATUS_ERROR;
		break;
	case 2:
		staSendMGMTResp->status = STATUS_INVALID;
		break;
	}
	wfaEncodeTLV(WFA_STA_SEND_COEXIST_MGMT_RESP_TLV, 4, (BYTE *)staSendMGMTResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;

}

int wfaStaResetDefault(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaResetDefault_t *reset = (caStaResetDefault_t *)caCmdBuf;
#ifndef _WINDOWS
	char *intf = reset->intf;
#else
	char *intf = aINTERFACE;
#endif
	char *prog = reset->set;
    dutCmdResponse_t *staResetResp = &gGenericResp;
	int st;

	sprintf(gCmdStr, "cd %s & reset_default /interface %s /set %s", WFA_CLI_CMD_DIR, intf, prog);
	st = wfaExecuteCLI(gCmdStr);

    switch(st)
	{
	case 0:
	   staResetResp->status = STATUS_COMPLETE;
	   break;
	case 1:
		staResetResp->status = STATUS_ERROR;
		break;
	case 2:
		staResetResp->status = STATUS_INVALID;
		break;
	}

    wfaEncodeTLV(WFA_STA_RESET_DEFAULT_RESP_TLV, 4, (BYTE *)staResetResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;
}

int wfaStaDisconnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *disc = (dutCommand_t *)caCmdBuf;
	char *intf = disc->intf;
	dutCmdResponse_t *staDiscResp = &gGenericResp;
	int ret,i;
   FILE *tmpfile = NULL;
   char result[32],filename[256];
   char string[64],Interfacename[64];
	// stop the supplicant
    switch(geSupplicant)
	{
	case  eWindowsZeroConfig :
//		sprintf(gCmdStr, "FOR /F \"tokens=2 delims=/\" %s IN ('wifi_config.exe -aps') DO (wifi_config.exe -delete %s)","%i","%i");

		tmpfile = fopen("c:\\wfa\\WfaEndpoint\\Interface.txt", "r");
		if(tmpfile == NULL)
		{
			printf("\n Error opening the interface file \n");
		}
		else
		{
			for(;;)
			{
				if(fgets(string, 256, tmpfile) == NULL)
					break; 
			}
			fclose(tmpfile);

			if(strncmp(string, "IFNAME", 6) == 0)
			  {
				 char *str;
				 str = strtok(string, "\"");
				 str = strtok(NULL, "\"");
				 if(str != NULL)
				 {
					 strcpy(&Interfacename[0],str);
				 }

			  }

		}
		sprintf(gCmdStr, "del /F c:\\WFA\\temp.txt");
       	//printf("Executing %s\n",gCmdStr);

		sprintf(gCmdStr, "netsh wlan delete profile name=\"*\" interface=\"%s\"",&Interfacename[0]);
       	//printf("Executing %s\n",gCmdStr);
	   	system(gCmdStr);

		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		ret = system(gCmdStr);
		break;
	case eCiscoSecureClient:
		sprintf(gCmdStr, "sc stop \"Cisco Secure Services Client\"");
		system(gCmdStr);
		printf("Executing %s\n",gCmdStr);
		sprintf(gCmdStr, "del /F /Q c:\\Documents\ and\ Settings\\All\ Users\\Application\ Data\\Cisco\\Cisco Secure Services Client\\system\\configuration.xml");
		ret=system(gCmdStr);
		printf("Executing %s\n",gCmdStr);
		printf("Return value is %d\n",ret);
		/* start the service */
		sprintf(gCmdStr, "sc start \"Cisco Secure Services Client\"");
		system(gCmdStr);
		printf("Executing %s\n",gCmdStr);
		break;
	case eWpaSupplicant:
		sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		ret = system(gCmdStr);
		DPRINT_INFO(WFA_OUT,"Retun value: %d\n",ret);

		sprintf(gCmdStr, " copy /Y NUL c:\\wfa\\wpa_supplicant.conf");
		ret=system(gCmdStr);
		printf("Executing %s\n",gCmdStr);
		printf("Return value is %d\n",ret);

		sprintf(gCmdStr, "sc start WFA_WpaSupplicant_Service");
		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		ret = system(gCmdStr);
		DPRINT_INFO(WFA_OUT,"Return value: %d\n",ret);

		break;
	default :
		printf(" \n Unknown Supplicant in Disconnect function");
	}

	staDiscResp->status = STATUS_COMPLETE;

    wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staDiscResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

    return TRUE;
}


/* Execute CLI, read the status from Environment variable */
int wfaExecuteCLI(char *CLI)
{
   int st = 0;
   char *retstr;

   system(CLI);

   retstr = getenv("WFA_CLI_STATUS");
   printf("cli status %s\n", retstr);
   return atoi(retstr);
}

int wfaStaReassociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaReAssoc_t *reassoc = (caStaReAssoc_t *)caCmdBuf;
#ifndef _WINDOWS
	char *intf = reassoc->intf;
#else
	char *intf = aINTERFACE;
#endif
	char *bssid = reassoc->bssid;
    dutCmdResponse_t *staReAssocResp = &gGenericResp;
	int st;

	sprintf(gCmdStr, "cd %s & sta_send_reassoc /interface %s /bssid %s", WFA_CLI_CMD_DIR, intf, bssid);
	st = wfaExecuteCLI(gCmdStr);

    switch(st)
	{
	case 0:
	   staReAssocResp->status = STATUS_COMPLETE;
	   break;
	case 1:
		staReAssocResp->status = STATUS_ERROR;
		break;
	case 2:
		staReAssocResp->status = STATUS_INVALID;
		break;
	}

    wfaEncodeTLV(WFA_STA_REASSOCIATE_RESP_TLV, 4, (BYTE *)staReAssocResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return TRUE;
}

int wfaStaCliCommand(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{

	char cmdName[32];
	char * pcmdStr,*str;
	int st;
	char CmdStr[WFA_CMD_STR_SZ];
	FILE *wfaCliFd;
	char wfaCliBuff[64];
	char retstr[256];
	int CmdReturnFlag;

	caStaCliCmdResp_t infoResp;

	printf("\n Entry wfaStaCliCommand... ");

	printf("The command Received: %s",caCmdBuf);

	memcpy(cmdName, strtok_r((char *)caCmdBuf, ",", (char **)&pcmdStr), 32);

	sprintf(CmdStr, "%s",cmdName);




	for(;;)
	{
		str = strtok_r(NULL, ",", &pcmdStr);
		if(str == NULL || str[0] == '\0')
			break;
		else
		{
			sprintf(CmdStr, "%s /%s",CmdStr,str);
			str = strtok_r(NULL, ",", &pcmdStr);
			sprintf(CmdStr, "%s %s",CmdStr,str);
		}
	}

	CmdReturnFlag =0;
	// check the return process
	wfaCliFd=fopen("c:\\wfa\\WfaEndpoint\\wfa_cli.txt","r");
	if(wfaCliFd!= NULL)
	{
		while(fgets(wfaCliBuff, 64, wfaCliFd) != NULL)
		{
			//printf("\nLine read from CLI file : %s",wfaCliBuff);
			if(ferror(wfaCliFd))
				break;
			str=strtok(wfaCliBuff,"-");
			if(strcmp(str,cmdName) == 0)
			{
				str=strtok(NULL,",");
				//printf("\n The str: %s Check\n",str);
				if(strcmp(str,"TRUE") == 0)
					CmdReturnFlag =1;
				break;
			}
		}
		fclose(wfaCliFd);

	}


	//printf("\n Command Return Flag : %d",CmdReturnFlag);
	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & %s", WFA_CLI_CMD_DIR, CmdStr);
    system(gCmdStr);
    //printf("CLI Command %s\n", gCmdStr);

	Sleep(2000);
    //printf("\nbefore wfaGetEnvVal\n");
    //printf("CLI status %d\n",st);
	
	memset(&retstr[0],'\0',256);
    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    //printf("cli status %s\n", retstr);
	if(strlen(retstr) > 0)
	    st = atoi(retstr);

    //printf("\nBefore deciding the rertun status\n");
    //printf("CLI status %d\n",st);

    infoResp.resFlag=CmdReturnFlag;

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   if (CmdReturnFlag)
	   {
			memset(&retstr[0],'\0',256);
			//printf("cli status beforoe %s**** len%d**** \n", retstr,strlen(retstr));
			wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
			//printf("cli status %s**** len%d**** \n", retstr,strlen(retstr));
			memset(&infoResp.result[0],'\0',WFA_CLI_CMD_RESP_LEN);
			if(retstr != NULL)
			{
				strncpy(&infoResp.result[0], retstr,(strlen(retstr) < WFA_CLI_CMD_RESP_LEN ) ? strlen(retstr) : (WFA_CLI_CMD_RESP_LEN-1) );
				//printf("Return CLI result to CA: %s****\n", &infoResp.result[0]);			
			}
			else
				strcpy(&infoResp.result[0], "ENV_VAR_NOT_DEFINED");

	   }

	
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

   wfaEncodeTLV(WFA_STA_CLI_CMD_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;

	
}




int wfaClearEnvVal(char * in_value)
{
	sprintf(gCmdStr, "reg delete HKEY_CURRENT_USER\\Environment /v %s /f",in_value);
    system(gCmdStr);
    //printf("CLI Command %s\n", gCmdStr);

	return TRUE;
}

int wfaGetEnvVal(char * in_value,char * out_value,int size)
{

   FILE *file_hd;
   char *str;

   printf("Entry wfaGetEnvVal.. ");

   // get the status
		sprintf(gCmdStr, "del /F /Q C:\\WFA\\temp.txt && del /F /Q C:\\WFA\\env_val.txt");
		system(gCmdStr);


	sprintf(gCmdStr, "reg query HKEY_CURRENT_USER\\Environment /v %s > C:\\WFA\\temp.txt",in_value);
    system(gCmdStr);
   // printf("CLI Command %s\n", gCmdStr);

	sprintf(gCmdStr, "FOR /F \"tokens=3,* delims= \" %s in ('findstr \"%s\" c:\\WFA\\temp.txt') do @echo %s %s > C:\\WFA\\env_val.txt","%i",in_value,"%i","%j" );
    system(gCmdStr);
    //printf("CLI Command %s\n", gCmdStr);

	// get the status
	file_hd = fopen("c:\\WFA\\env_val.txt","r");
	if(file_hd != NULL && !ferror(file_hd))
	{
		fgets(gCmdStr,WFA_CMD_STR_SZ,file_hd);
		strcpy(out_value,gCmdStr);
		out_value = rtrim(out_value);
		/*
		str=strtok(gCmdStr," ");
		strcpy(out_value,str);
		printf("In GetEnv token %s*** The return value:%s***\n",str,out_value);
		str=strtok(NULL," ");
		if(strlen(str) >2)
			sprintf(&out_value[strlen(out_value)]," %s",str);
			*/
		printf("In GetEnv token %s**** The return value:%s***\n",str,out_value);
		fclose(file_hd);
	}
	else
	{
		out_value = NULL;
	}

	printf("\n Exit wfaGetEnvVal.. ");
	return 1;
}


#ifdef WFA_P2P
/*
 * wfaStaGetP2pDevAddress(): 
 */
int wfaStaGetP2pDevAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	st = 1;

	printf("\n Entry wfaStaGetP2pDevAddress... ");

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_get_p2p_dev_address /interface %s", WFA_CLI_CMD_DIR, intf);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
   	if(retstr !=NULL)
	    st = atoi(retstr);


	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;

	    wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
	    printf("cli status %s\n", retstr);
		memset(&infoResp.cmdru.devid[0],0,WFA_P2P_DEVID_LEN);
		if(retstr != NULL)
		{
			strncpy(&infoResp.cmdru.devid[0], retstr,(strlen(retstr) < WFA_P2P_DEVID_LEN ) ? strlen(retstr) : (WFA_P2P_DEVID_LEN-1) );
			printf("Device ID : %s\n", &infoResp.cmdru.devid[0]);			
		}
		else
			strcpy(&infoResp.cmdru.devid[0], "ENV_VAR_NOT_DEFINED");
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}
	
   wfaEncodeTLV(WFA_STA_GET_P2P_DEV_ADDRESS_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

/*
 * wfaStaSetP2p(): 
 */
int wfaStaSetP2p(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaSetP2p_t *getStaSetP2p = (caStaSetP2p_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getStaSetP2p->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
	char cmd[512];
   char retstr[128];

   
	printf("\n Entry wfaStaSetP2p... ");

	memset(cmd,0,512);
	
	if(getStaSetP2p->oper_chn_flag == 1)
		sprintf(cmd+strlen(cmd)," /oper_chn %d",getStaSetP2p->oper_chn);
	if(getStaSetP2p->intent_val_flag == 1)
		sprintf(cmd+strlen(cmd)," /intent_val %d",getStaSetP2p->intent_val);
	if(getStaSetP2p->listen_chn_flag == 1)
		sprintf(cmd+strlen(cmd)," /listen_chn %d",getStaSetP2p->listen_chn);
	if(getStaSetP2p->p2p_mode_flag == 1)
		sprintf(cmd+strlen(cmd)," /p2p_mode %s",getStaSetP2p->p2p_mode);
	if(getStaSetP2p->ssid_flag == 1)
		sprintf(cmd+strlen(cmd)," /ssid %s",getStaSetP2p->ssid);
	if(getStaSetP2p->presistent_flag == 1)
		sprintf(cmd+strlen(cmd)," /presistent %d",getStaSetP2p->presistent);
	if(getStaSetP2p->intra_bss_flag == 1)
		sprintf(cmd+strlen(cmd)," /intra_bss %d",getStaSetP2p->intra_bss);
	if(getStaSetP2p->noa_duration_flag == 1)
		sprintf(cmd+strlen(cmd)," /noa_duration %d",getStaSetP2p->noa_duration);
	if(getStaSetP2p->noa_interval_flag == 1)
		sprintf(cmd+strlen(cmd)," /noa_interval %d",getStaSetP2p->noa_interval);
	if(getStaSetP2p->noa_count_flag == 1)
		sprintf(cmd+strlen(cmd)," /noa_count %d",getStaSetP2p->noa_count);

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_set_p2p /interface %s %s", WFA_CLI_CMD_DIR, intf, cmd);
	st = wfaExecuteCLI(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

	// Implement the function and this does not return any thing back.
   
   wfaEncodeTLV(WFA_STA_SET_P2P_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}
/*
 * wfaStaP2pConnect(): 
 */
int wfaStaP2pConnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaP2pConnect_t *getStaP2pConnect = (caStaP2pConnect_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

   
	printf("\n Entry wfaStaP2pConnect... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_p2p_connect /interface %s /p2pdevid %s", WFA_CLI_CMD_DIR, intf,getStaP2pConnect->devId);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;

	    wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
	    printf("cli status %s\n", retstr);
		memset(&infoResp.cmdru.grpid[0],0,WFA_P2P_GRP_ID_LEN);
		if(retstr != NULL)
		{
			strncpy(&infoResp.cmdru.grpid[0], retstr,(strlen(retstr) < WFA_P2P_GRP_ID_LEN ) ? strlen(retstr) : (WFA_P2P_GRP_ID_LEN-1) );
			printf("Device ID : %s\n", &infoResp.cmdru.grpid[0]);			
		}
		else
			strcpy(&infoResp.cmdru.grpid[0], "ENV_VAR_NOT_DEFINED");
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}
	
	// Implement the function and this  return the grpid.
   wfaEncodeTLV(WFA_STA_P2P_CONNECT_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

/*
 * wfaStaP2pJoin(): 
 */
int wfaStaP2pJoin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaP2pJoin_t *getStaP2pJoin = (caStaP2pJoin_t *)caCmdBuf;


	#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

   
	printf("\n Entry wfaStaP2pJoin... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");


	sprintf(gCmdStr, "cd %s & sta_p2p_join /interface %s /p2pdevid %s /ssid %s", WFA_CLI_CMD_DIR, intf,getStaP2pJoin->devId,getStaP2pJoin->ssid);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}


	// Implement the function and this does not return any thing back.
   wfaEncodeTLV(WFA_STA_P2P_JOIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaP2pStartGrpFormation(): 
 */
int wfaStaP2pStartGrpFormation(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaP2pStartGrpForm_t *getStaP2pStartGrpForm = (caStaP2pStartGrpForm_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];


	printf("\n Entry wfaStaP2pStartGrpFormation... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_p2p_start_group_formation /interface %s /p2pdevid %s /intent_val %d", WFA_CLI_CMD_DIR, intf,getStaP2pStartGrpForm->devId,getStaP2pStartGrpForm->intent_val);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;

	    wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
	    printf("cli status %s\n", retstr);
		memset(&infoResp.cmdru.grpid[0],0,WFA_P2P_GRP_ID_LEN);
		if(retstr != NULL)
		{
			strncpy(&infoResp.cmdru.p2presult[0], retstr,(strlen(retstr) < WFA_P2P_GRP_ID_LEN ) ? strlen(retstr) : (WFA_P2P_GRP_ID_LEN-1) );
			printf("Device ID : %s\n", &infoResp.cmdru.grpid[0]);			
		}
		else
			strcpy(&infoResp.cmdru.grpid[0], "ENV_VAR_NOT_DEFINED");
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

	wfaEncodeTLV(WFA_STA_P2P_START_GRP_FORM_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaP2pDissolve(): 
 */
int wfaStaP2pDissolve(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaP2pDissolve_t *getStap2pDissolve= (caStaP2pDissolve_t *)caCmdBuf;
	
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaP2pDissolve... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");


	sprintf(gCmdStr, "cd %s & sta_p2p_dissolve /interface %s /groupid %s", WFA_CLI_CMD_DIR, intf,getStap2pDissolve->grpId);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

   wfaEncodeTLV(WFA_STA_P2P_DISSOLVE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

/*
 * wfaStaSendP2pInvReq(): 
 */
int wfaStaSendP2pInvReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaSendP2pInvReq_t *getStaP2pInvReq= (caStaSendP2pInvReq_t *)caCmdBuf;
	
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaSendP2pInvReq... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	if(getStaP2pInvReq->grpId_flag == 1)
		sprintf(gCmdStr, "cd %s & sta_send_p2p_invitation_req /interface %s /p2pdevid %s /groupid %s", WFA_CLI_CMD_DIR, intf,getStaP2pInvReq->devId,getStaP2pInvReq->grpId);
	else
		sprintf(gCmdStr, "cd %s & sta_send_p2p_invitation_req /interface %s /p2pdevid %s", WFA_CLI_CMD_DIR, intf,getStaP2pInvReq->devId);

	system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);

	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

	
   wfaEncodeTLV(WFA_STA_SEND_P2P_INV_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaAcceptP2pReq(): 
 */
int wfaStaAcceptP2pReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaSendP2pInvReq_t *getStaP2pInvReq= (caStaSendP2pInvReq_t *)caCmdBuf;
	
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaAcceptP2pReq... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	if(getStaP2pInvReq->grpId_flag == 1)
		sprintf(gCmdStr, "cd %s & sta_accept_p2p_invitation_req /interface %s /p2pdevid %s /groupid %s", WFA_CLI_CMD_DIR, intf,getStaP2pInvReq->devId,getStaP2pInvReq->grpId);
	else
		sprintf(gCmdStr, "cd %s & sta_accept_p2p_invitation_req /interface %s /p2pdevid %s", WFA_CLI_CMD_DIR, intf,getStaP2pInvReq->devId);

	system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

   wfaEncodeTLV(WFA_STA_ACCEPT_P2P_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaSendP2pProvDisReq(): 
 */
int wfaStaSendP2pProvDisReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaSendP2pProvDisReq_t *getStaP2pProvDisReq= (caStaSendP2pProvDisReq_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaSendP2pProvDisReq... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_send_p2p_provision_dis_req /interface %s /configmethod %s /p2pdevid %s", WFA_CLI_CMD_DIR, intf,getStaP2pProvDisReq->confMethod,getStaP2pProvDisReq->devId);
	system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);

	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

	wfaEncodeTLV(WFA_STA_SEND_P2P_PROV_DIS_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

/*
 * wfaStaSetWpsPbc(): 
 */
int wfaStaSetWpsPbc(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getStaSetWpsPbc= (dutCommand_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaSetWpsPbc... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_set_wps_pbc /interface %s", WFA_CLI_CMD_DIR, intf);
	system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);

	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}
   wfaEncodeTLV(WFA_STA_SET_WPS_PBC_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

/*
 * wfaStaWpsReadPin(): 
 */
int wfaStaWpsReadPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getStaWpsReadPin= (dutCommand_t *)caCmdBuf;
	
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[WFA_WPS_PIN_LEN];


	printf("\n Entry wfaStaWpsReadPin... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_wps_read_pin /interface %s", WFA_CLI_CMD_DIR, intf);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);

	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;

	    wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
	    printf("cli status %s\n", retstr);
		memset(&infoResp.cmdru.wpsPin[0],0,WFA_WPS_PIN_LEN);
		if(retstr != NULL)
		{
			strncpy(&infoResp.cmdru.wpsPin[0], retstr,(strlen(retstr) < WFA_WPS_PIN_LEN ) ? strlen(retstr) : (WFA_WPS_PIN_LEN-1) );
			printf("Device ID : %s\n", &infoResp.cmdru.wpsPin[0]);			
		}
		else
			strcpy(&infoResp.cmdru.grpid[0], "ENV_VAR_NOT_DEFINED");
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}
		
   wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaWpsEnterPin(): 
 */
int wfaStaWpsEnterPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaWpsEnterPin_t *getStaWpsEnterPin= (caStaWpsEnterPin_t *)caCmdBuf;
   
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaWpsEnterPin... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_wps_enter_pin /interface %s /pin ", WFA_CLI_CMD_DIR, intf,getStaWpsEnterPin->wpsPin);
	system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);

	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

   wfaEncodeTLV(WFA_STA_WPS_ENTER_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaGetPsk(): 
 */
int wfaStaGetPsk(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getStaGetPsk= (dutCommand_t *)caCmdBuf;
   	
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[WFA_WPS_PIN_LEN];
      
   printf("\n Entry wfaStaGetPsk... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_get_psk /interface %s", WFA_CLI_CMD_DIR, intf);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;

	    wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
	    printf("cli status %s\n", retstr);
		memset(&infoResp.cmdru.pskInfo.passPhrase[0],0,WFA_WPS_PIN_LEN);
		if(retstr != NULL)
		{
			strncpy(&infoResp.cmdru.pskInfo.passPhrase[0], retstr,(strlen(retstr) < WFA_WPS_PIN_LEN ) ? strlen(retstr) : (WFA_WPS_PIN_LEN-1) );
			printf("Device ID : %s\n", &infoResp.cmdru.pskInfo.passPhrase[0]);			
		}
		else
			strcpy(&infoResp.cmdru.grpid[0], "ENV_VAR_NOT_DEFINED");
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

   wfaEncodeTLV(WFA_STA_GET_PSK_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

#endif
