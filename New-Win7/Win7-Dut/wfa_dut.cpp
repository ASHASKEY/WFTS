/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *  LICENSE
 *
 * License is granted only to Wi-Fi Alliance members and designated
 * contractors (“Authorized Licensees”).  Authorized Licensees are granted
 * the non-exclusive, worldwide, limited right to use, copy, import, export
 * and distribute this software:
 * (i) solely for noncommercial applications and solely for testing Wi-Fi
 * equipment; and
 * (ii) solely for the purpose of embedding the software into Authorized
 * Licensee’s proprietary equipment and software products for distribution to
 * its customers under a license with at least the same restrictions as
 * contained in this License, including, without limitation, the disclaimer of
 * warranty and limitation of liability, below.  The distribution rights
 * granted in clause (ii), above, include distribution to third party 
 * companies who will redistribute the Authorized Licensee’s product to their 
 * customers with or without such third party’s private label. Other than 
 * expressly granted herein, this License is not transferable or sublicensable,
 * and it does not extend to and may not be used with non-Wi-Fi applications. 
 * Wi-Fi Alliance reserves all rights not expressly granted herein. 
 * 
 * Except as specifically set forth above, commercial derivative works of
 * this software or applications that use the Wi-Fi scripts generated by this
 * software are NOT AUTHORIZED without specific prior written permission from
 * Wi-Fi Alliance. Non-Commercial derivative works of this software for 
 * internal use are authorized and are limited by the same restrictions; 
 * provided, however, that the Authorized Licensee shall provide Wi-Fi Alliance
 * with a copy of such derivative works under a perpetual, payment-free license
 * to use, modify, and distribute such derivative works for purposes of testing
 * Wi-Fi equipment.
 * Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 * or promote products that are derived from or that use this software without
 * specific prior written permission from Wi-Fi Alliance.
 *
 * THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE,
 * ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 * ****************************************************************************
 */

/*
 * File: wfa_dut.c - The main program for DUT agent.
 *       This is the top level of traffic control. It initializes a local TCP
 *       socket for command and control link and waits for a connect request
 *       from a Control Agent. Once the the connection is established, it 
 *       will process the commands from the Control Agent. For details, please
 *       reference the architecture documents.   
 *
 * Revision History:
 *       2008/11/05 --  Sigma Beta2 - Timer Fixed for File Transfer profile Windows code - [AV]
 *       2009/08/04 --  Add new dedicated thread to handle volume receiving traffic for Windows code[QH]
 *       2009/09/30 --  WINv03.00.00. Support TGn Program Release and WPA2 & WMM [QH]
 *       2010/04/16 --  WINv03.xxxx Support P2P Program [Chandra]
 *
 */


#include "stdafx.h"
#include <windows.h>
#include <winbase.h>

#include <time.h>

#include "wfa_debug.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_dut.h"
#include "wfa_sock.h"
#include "wfa_tlv.h"
#include "wfa_tg.h"
#include "wfa_miscs.h"
#include "wfa_agt.h"
#include "wfa_rsp.h"
#include "wfa_wmmps.h"
#define DONE 1
/* Global flags for synchronizing the TG functions */
BOOL       gtgSend = 0;         /* flag to sync Send traffic */
BOOL       gtgRecv = 0;         /* flag to sync Recv traffic */
BOOL       gtgTransac = 0;      /* flag to sync Transaction traffic */
int        gRegSec = 1;         /* regularly periodical timeout     */
int        gtimeOut = 0;        /* timeout value for select call in usec */

extern int newCmdOn;

#ifdef WFA_WMM_EXT
#ifdef WFA_WMM_PS_EXT
BOOL       gtgWmmPS = 0;
unsigned long psTxMsg[512];
unsigned long psRxMsg[512];
wfaWmmPS_t wmmps_info;
int        psSockfd = -1;

extern struct apts_msg *apts_msgs;
extern void BUILD_APTS_MSG(int msg, unsigned long *txbuf);
extern int wfaWmmPowerSaveProcess(int sockfd);
#endif /* WFA_WMM_PS_EXT */
extern int gettimeofday(struct timeval *tv, void *tz);
extern void int2BuffBigEndian(int val, char *buf);
extern int bigEndianBuff2Int(char *buff);
extern double wfa_ftime_diff(struct timeval *t1, struct timeval *t2);
extern int settimeofday(struct timeval *tv,void *tz);
#endif /* WFA_WMM_EXT */

int adj_latency;           /* adjust sleep time due to latency */

char       gnetIf[WFA_BUFF_32];        /* specify the interface to use */

int geSupplicant;  /* specifies the supplicant, default is zeroconfig */
char gStaSSID[WFA_SSID_NAME_LEN];  // For Marvell supplicant 

/* stream table */
tgStream_t gStreams[WFA_MAX_TRAFFIC_STREAMS];         /* streams' buffers             */ 

/* the agent local Socket, Agent Control socket and baseline test socket*/
int        gagtSockfd = -1, gxcSockfd = -1, btSockfd = -1;

int txSockfd = -1;

/* the WMM traffic streams socket fds - Socket Handler table */
int        tgSockfds[WFA_MAX_WMM_STREAMS];

int tgWMMTestEnable = 0;

extern     xcCommandFuncPtr gWfaCmdFuncTbl[]; /* command process functions */
extern     char gCmdStr[];
extern     dutCmdResponse_t gGenericResp;
extern     void tmout_stop_send(int);
extern     tgStream_t *findStreamProfile(int);
extern     int clock_drift_ps;

unsigned short wfa_defined_debug = WFA_DEBUG_ERR | WFA_DEBUG_WARNING | WFA_DEBUG_INFO;
unsigned short dfd_lvl = WFA_DEBUG_DEFAULT | WFA_DEBUG_ERR | WFA_DEBUG_INFO;
//#ifdef _WINDOWS
//LPCTSTR lpmut[6] = { "mut1","mut2","mut3","mut4","mut5","mut6"};
//LPCTSTR newmut = "MYNEW";
//#endif

int newCmdOn = 0;
void RefreshTaskbarNotificationArea();
void wfa_set_envs();
extern void rand_gen_sid();

int hasRecv = 0;

#ifdef WFA_WMM_EXT
/*
 * Thread Synchronize flags
 */
tgWMM_t wmm_thr[WFA_THREADS_NUM];
#ifdef _WINDOWS
//char mymut[10];
extern DWORD WINAPI wfa_wmm_thread(void *thr_param);
HANDLE              hStdOut = NULL;
extern HANDLE recv_mutex;
#else
extern void *wfa_wmm_thread(void *thr_param);
#endif
extern void *wfa_wmmps_thread();

BOOL       gtgStartSync = 0;       /* flag to sync End2End Time handshaking */
//double gtgPktRTDelay;
double min_rttime = 0xFFFFFFFF;

int e2eCnt = 0;
tgE2EStats_t *e2eStats;
#endif

#define DEBUG 0

extern int wfa_estimate_timer_latency();
extern void wfa_dut_init(BYTE **tBuf, BYTE **rBuf, BYTE **paBuf, BYTE **cBuf, struct timeval **timerp);
#ifdef _WINDOWS
DWORD WINAPI wfa_wpa2_sleep_thread(void *thr_param)
{
   int sleep_prd = *(int *)thr_param;
   Sleep(sleep_prd);
   DPRINT_INFOL(WFA_OUT, "Timer timeout after %i milliseconds\n", sleep_prd);
   tmout_stop_send(0);
   return 0;
}

DWORD recvThr;

DWORD WINAPI wfa_recv_thread(void *thr_param)
{
   char recvBuf[3072];
   int newRelease = 0;

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");

   while(1)
   {
       if(!gtgRecv)
       {
          int bw = 0;
            
          WaitForSingleObject( recv_mutex, 400);
          if(newRelease == 0)
          {
             ReleaseMutex(recv_mutex);
             newRelease = 1;
             DPRINT_INFOL(WFA_OUT, "wake up hold object %i...\n", newRelease);
          }
       }
       else
       {
          int ncnt = 0, n=0;
          newRelease = 0;

          if(btSockfd >= 0)
          {
             while (n!=-1)
             {
                n = wfaRecvFile(btSockfd, gtgRecv, (char  *)recvBuf);
                if(gtgTransac != 0 && n != -1) /* for transaction DT3, need to send a response back */
                {
                    char respBuf[WFA_BUFF_4K]; 
                    int respLen = 0;

                    if(wfaSendShortFile(btSockfd, gtgTransac,(BYTE *) recvBuf, n, (BYTE *) respBuf, &respLen) == DONE)
                    {
                        if(wfaCtrlSend(gxcSockfd, (BYTE *)respBuf, respLen)!=respLen)
                        {
                           DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
                        }
                    }
               }
            }
            continue;  /* this one assumes normal profile will not co-exist with WMM (IPTV) profile */
         }
      }
   } /* while */
}

#endif

int
main(int argc, char **argv)
{
    int       nfds, maxfdn1 = -1, nbytes = 0, cmdLen = 0, isExit = 1;
    int       respLen;
    WORD      locPortNo = 0;   /* local control port number                  */
    fd_set    sockSet;         /* Set of socket descriptors for select()     */
    BYTE      *xcCmdBuf=NULL, *parmsVal=NULL;
    BYTE      *trafficBuf=NULL, *respBuf=NULL;
    struct timeval *toutvalp=NULL, *tovalp; /* Timeout for select()           */
    WORD      xcCmdTag;
    struct sockfds fds;

#ifdef WFA_WMM_EXT
    struct timeval lstime;
    int asn=1;
    double rttime = 0;
    tgThrData_t tdata[WFA_THREADS_NUM];
    int cntThr = 0;
// LPCTSTR lpszMutex="MUTEX";
#ifndef _WINDOWS
    pthread_attr_t ptAttr;
    int ptPolicy;
    struct sched_param ptSchedParam;
#else
    int timer_dur=0;
    DWORD thr_id;
// DWORD recvThr;
    SECURITY_ATTRIBUTES sa;
    
    DWORD               dwFlags;

#endif
#endif
    geSupplicant = 1;
    if (argc < 3)              /* Test for correct number of arguments */
    {
        DPRINT_ERR(WFA_ERR, "Usage:  %s <command interface> <Local Control Port> \n", argv[0]);
        WFA_EXIT(1);
    }
#ifndef _WINDOWS
    if(isString(argv[1]) == FALSE)
    {
        DPRINT_ERR(WFA_ERR, "incorrect network interface\n");
        exit(1);
    }
#else
 
    if(argc > 3)
    {
       sa.nLength              =   sizeof  (   SECURITY_ATTRIBUTES);
       sa.lpSecurityDescriptor =   NULL;
       sa.bInheritHandle       =   TRUE;
       dwFlags =       FILE_ATTRIBUTE_NORMAL;
       hStdOut =   CreateFile  ( (LPCWSTR)  argv[3], 
                          GENERIC_WRITE,
                          0,
                          //FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          //&sa,
                          CREATE_ALWAYS,
                          dwFlags,
                          NULL);

       SetStdHandle(STD_OUTPUT_HANDLE,hStdOut);
       SetStdHandle(STD_ERROR_HANDLE,hStdOut);
       freopen(argv[3],"a",stdout);
       DPRINT_INFOL(WFA_OUT, "Redirected output to %s\n",argv[3]);
  
    }
#endif
#ifndef _WINDOWS
    strncpy(gnetIf, argv[1], 31);
#else
    strncpy(gnetIf, argv[1], 50);
#endif
    DPRINT_INFOL(WFA_OUT, "Interface is %s\n",gnetIf);
    if(isNumber(argv[2]) == FALSE)
    {
        DPRINT_ERR(WFA_ERR, "Incorrect port number\n");
        WFA_EXIT(1);
    }

    locPortNo = atoi(argv[2]);

    rand_gen_sid();
    /* raise itself priority class first */
    //adjust_variation = atoi(argv[3]);
    adj_latency = wfa_estimate_timer_latency() + 2000; /* four more mini */
    DPRINT_INFOL(WFA_OUT, "\r\nLatency is %d",adj_latency);
    
    /* allocate the traffic stream table */
    wfa_dut_init(&trafficBuf, &respBuf, &parmsVal, &xcCmdBuf, &toutvalp);

    /* 4create listening TCP socket */
    gagtSockfd = wfaCreateTCPServSock(locPortNo);
    if(gagtSockfd == -1)
    {
       DPRINT_ERR(WFA_ERR, "Failed to open socket\n");
       WFA_EXIT(1);
    }

#ifdef WFA_WMM_EXT
    #ifndef _WINDOWS
    pthread_attr_init(&ptAttr);

    ptSchedParam.sched_priority = 10;
    pthread_attr_setschedparam(&ptAttr, &ptSchedParam);
    pthread_attr_getschedpolicy(&ptAttr, &ptPolicy);
    pthread_attr_setschedpolicy(&ptAttr, SCHED_RR);
    pthread_attr_getschedpolicy(&ptAttr, &ptPolicy);
#endif

#ifdef _WINDOWS
 /* create a receive thread */
    timer_dur = 1000;

    recv_mutex = CreateMutex( NULL, FALSE, NULL );
 WaitForSingleObject( recv_mutex, INFINITE );

    recvThr = (DWORD) CreateThread(NULL, 0, wfa_recv_thread, (PVOID)&timer_dur, 0,&thr_id);
#if 0
    SetThreadPriority(recvThr, THREAD_PRIORITY_HIGHEST);

    thrPri = GetThreadPriority(recvThr);

 if(thrPri == THREAD_PRIORITY_HIGHEST)
     DPRINT_INFO(WFA_OUT, "the thread set to highest\n");
 else
  DPRINT_INFO(WFA_OUT, "can't set thread to highest\n");
#endif
 // initial some external pointers
    wfa_set_envs();

#endif

    /*
     * Create multiple threads for WMM Stream processing.
     */
    for(cntThr = 0; cntThr< WFA_THREADS_NUM; cntThr++)
    { 
        tdata[cntThr].tid = cntThr;
#ifndef _WINDOWS
        pthread_mutex_init(&wmm_thr[cntThr].thr_flag_mutex, NULL);
        pthread_cond_init(&wmm_thr[cntThr].thr_flag_cond, NULL);
        wmm_thr[cntThr].thr_id = pthread_create(&wmm_thr[cntThr].thr, 
                       &ptAttr, wfa_wmm_thread, &tdata[cntThr]);
#else
        tdata[cntThr].tid = cntThr;
        wmm_thr[cntThr].thr_flag_mutex = CreateMutex( NULL, FALSE, NULL );
        WaitForSingleObject( wmm_thr[cntThr].thr_flag_mutex, INFINITE );
#if 0
        DPRINT_INFOL(WFA_OUT, "Creating thread #%d\n",cntThr);
#endif
        wmm_thr[cntThr].thr = CreateThread(NULL, 5242880,(LPTHREAD_START_ROUTINE) wfa_wmm_thread, (PVOID)&tdata[cntThr], 0,
                                       &wmm_thr[cntThr].thr_id);

//        SetThreadPriority(wmm_thr[cntThr].thr, BELOW_NORMAL_PRIORITY_CLASS);
        
#endif 
    }
#endif
    //SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

    maxfdn1 = gagtSockfd + 1;
    while (isExit) {
        /* set socket file descriptors. For baseline, there are only 
         * three sockets required. They are an agent main socket,
         * Control Agent link socket and Traffic Generator Socket.
         */ 

        fds.agtfd = &gagtSockfd;   
        fds.cafd = &gxcSockfd;
#if 0
        fds.tgfd = &btSockfd; 
#endif
//        fds.tgfd = &txSockfd;

#ifdef WFA_WMM_EXT
#if 0
        fds.wmmfds = tgSockfds;
#endif
#ifdef WFA_WMM_PS_EXT
        fds.psfd = &psSockfd;
#endif
#endif

        wfaSetSockFiDesc(&sockSet, &maxfdn1, &fds);

        /* 
         * The timer will be set for transaction traffic if no echo is back
         * The timeout from the select call force to send a new packet
         */
        tovalp = NULL;
        if(gtimeOut != 0)
        {
          /* timeout is set to usec */
          tovalp = wfaSetTimer(0, gtimeOut*1000, toutvalp);
        }

        nfds = 0;
#ifdef _WINDOWS
        fflush(stdout);
        //Put a sleep so that the thread gets the mutex then main thread gets it
        Sleep(1);
#endif  
        if ( (nfds = select(maxfdn1, &sockSet, NULL, NULL, tovalp)) < 0) 
        {
           if (errno == EINTR)
              continue;  /* back to for() */
           else
           {
#ifndef _WINDOWS
              DPRINT_WARNING(WFA_WNG, "select error: %i", errno);
#else
              int errsv =(int) WSAGetLastError();
              DPRINT_WARNING(WFA_WNG, "Select error: %i", errsv);
#endif
           }
        }

        if(nfds == 0)
        {
            /*
             * For transaction test, if it times out without receive a packet,
             * here it should initiate/send the next transac packet and count 
             * a packet loss for the previous one
             */
            if(gtgTransac != 0)
            {
               memset(respBuf, 0, WFA_BUFF_512); 
               respLen = 0;

#ifdef WFA_WMM_EXT
               /*
                * handle end to end time syc
                */
               DPRINT_INFOL(WFA_OUT, "Initiate sync message %i\n", asn);
               gettimeofday((timeval *)&lstime, NULL);
               /*
                * If your device is BIG ENDIAN, you need to 
                * modify the the function calls
                */
               int2BuffBigEndian(asn++, &((tgHeader_t *)trafficBuf)->hdr[8]);
               int2BuffBigEndian((int)lstime.tv_sec, &((tgHeader_t *)trafficBuf)->hdr[12]);
               int2BuffBigEndian((int)lstime.tv_usec, &((tgHeader_t *)trafficBuf)->hdr[16]);
#endif
               if(wfaSendShortFile(btSockfd, gtgTransac, 
                       trafficBuf, 0, respBuf, &respLen) == DONE)
               {
                  if(wfaCtrlSend(gxcSockfd, respBuf, respLen) != respLen)
                  {
                      DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
                  }
               }
               continue;
            }
#ifdef WFA_WMM_EXT
#ifdef WFA_WMM_PS_EXT
            /*
             * For WMM-Power Save
             * periodically send HELLO to Console for initial setup.
             */
            if(gtgWmmPS != 0 && psSockfd != -1)
            {
                BUILD_APTS_MSG(APTS_HELLO, psTxMsg);
                wfaTrafficSendTo(psSockfd, (char *)psTxMsg, sizeof(psTxMsg), (struct sockaddr *) &wmmps_info.psToAddr);

                wmmps_info.sta_state = 0;
                wmmps_info.wait_state = WFA_WAIT_STAUT_00;
                continue;
            }
#endif /* WFA_WMM_PS_EXT */
#endif /* WFA_WMM_EXT */
        }

        if (FD_ISSET(gagtSockfd, &sockSet)) 
        {
            /* Incoming connection request */
            gxcSockfd = wfaAcceptTCPConn(gagtSockfd);
            if(gxcSockfd == -1)
            {
               DPRINT_ERR(WFA_ERR, "Failed to open control link socket\n");
               WFA_EXIT(1);
            }
        }

        /* Control Link port event*/
        if(gxcSockfd > 0 && FD_ISSET(gxcSockfd, &sockSet)) 
        {
            memset(xcCmdBuf, '\0', WFA_BUFF_1K);  /* reset the buffer */
            nbytes = wfaCtrlRecv(gxcSockfd, xcCmdBuf);

            if(nbytes <=0)
            {
                /* errors at the port, close it */
#ifndef _WINDOWS
                shutdown(gxcSockfd, SHUT_WR);
                close(gxcSockfd);
#else
                closesocket(gxcSockfd);
#endif
                gxcSockfd = -1;
            }
            else
            {
                /*  Clean the tray for any in Active icons */
                RefreshTaskbarNotificationArea();

                DPRINT_INFOL(WFA_OUT, "\nThe command Received after socket: %s\n",xcCmdBuf+4);

                memset(parmsVal,'\0',MAX_PARMS_BUFF);
                /* command received */
                wfaDecodeTLV(xcCmdBuf, nbytes, &xcCmdTag, &cmdLen, parmsVal);    
                memset(respBuf, 0, WFA_BUFF_512); 
                respLen = 0;

                DPRINT_INFOL(WFA_OUT, "\nThe command Received after decode: cmdTag %i arguments %s len: %d\n",xcCmdTag, parmsVal,cmdLen);

                /* reset two commond storages used by control functions */
                memset(gCmdStr, '\0', WFA_CMD_STR_SZ);
                memset(&gGenericResp, '\0', sizeof(dutCmdResponse_t));

                /* command process function defined in wfa_ca.c and wfa_tg.c */

                if((xcCmdTag != 0 
                      && xcCmdTag > WFA_STA_NEW_COMMANDS_START 
                      && xcCmdTag < WFA_STA_NEW_COMMANDS_END) 
                      && gWfaCmdFuncTbl[xcCmdTag - WFA_STA_NEW_COMMANDS_START + (WFA_STA_COMMANDS_END - 1)] != NULL)
                {
                    gWfaCmdFuncTbl[xcCmdTag - WFA_STA_NEW_COMMANDS_START + (WFA_STA_COMMANDS_END - 1)](cmdLen, parmsVal, &respLen, (BYTE *)respBuf);   
                }
                else if((xcCmdTag != 0 && xcCmdTag < WFA_STA_COMMANDS_END) && gWfaCmdFuncTbl[xcCmdTag] != NULL)
                {
                    gWfaCmdFuncTbl[xcCmdTag](cmdLen, parmsVal, &respLen, (BYTE *)respBuf);
                }
                else
                { // no command defined
                    gWfaCmdFuncTbl[0](cmdLen, parmsVal, &respLen, (BYTE *)respBuf);
                    DPRINT_INFOL(WFA_OUT, "Not supported command\n");
                }
                DPRINT_INFOL(WFA_OUT, "Completed control command\n");
    
                newCmdOn = 1;

                if(wfaCtrlSend(gxcSockfd, (BYTE *)respBuf, respLen) != respLen)
                {
                   DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
                   // resend one more time
                   wfaCtrlSend(gxcSockfd, (BYTE *)respBuf, respLen);
                }
      
                // !!!! a hack !!!!
                if(xcCmdTag == WFA_TRAFFIC_AGENT_RECV_STOP_TLV)
                {
                   
                   printf("Exiting from Recv %s\n", hasRecv);
                   Sleep(3000);
                   exit(0);
                }
            }

        }

#ifdef WFA_WMM_EXT
#ifndef _WINDOWS
        /* First Check for WMM traffic , higher priority */
  
        for( ncnt = 0; ncnt < WFA_MAX_WMM_STREAMS; ncnt++)
        {
           if(tgSockfds[ncnt]> 0 && FD_ISSET(tgSockfds[ncnt], &sockSet))
           {
              int sn,n=0;
              struct timeval ttval, currTimeVal;
              while ( n!=-1)
              { 
                 n = wfaRecvFile(tgSockfds[ncnt], gStreams[ncnt].id, (char  *)trafficBuf);
                 sn = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[8]);
                 ttval.tv_sec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[12]);
                 ttval.tv_usec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[16]);
                 gettimeofday(&currTimeVal, NULL);

                 /*
                  * take the end2end stats
                  */
                 if(e2eCnt < 6000)
                 {
                    tgE2EStats_t *ep = &e2eStats[e2eCnt++];
                    ep->seqnum = sn;
                    ep->rsec = ttval.tv_sec;
                    ep->rusec = ttval.tv_usec;

                    ep->lsec = currTimeVal.tv_sec;
                    ep->lusec = currTimeVal.tv_usec;

                    if(ep->lusec  < 0)
                    {
                       ep->lsec -=1;
                       ep->lusec += 1000000;
                    }
                    else if(ep->lusec >= 1000000)
                    {
                       ep->lsec += 1;
                       ep->lusec -= 1000000;
                    }
                 }
              } // While 
           } 
        }
#endif
#endif

#ifndef _WINDOWS
        /* Baseline Test Transaction Traffic received */
        if(gtgTransac != 0 || gtgRecv != 0) 
        {
            int n =0;
#ifdef WFA_WMM_EXT
            struct timeval ttval;
#endif
  
            memset(trafficBuf, 0, sizeof(trafficBuf));

            if((btSockfd != -1 && FD_ISSET(btSockfd, &sockSet))) 
            {
                int i = gtgRecv?gtgRecv:gtgTransac;
           
                while(n != -1)
                {
                    n = wfaRecvFile(btSockfd, i, (char  *)trafficBuf);
    
#ifdef WFAN_WMM_EXT
                    ttval.tv_sec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[12]);
                    ttval.tv_usec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[16]);
#endif

                    /* If it is testing transaction, once it receives a packet
                     * send a new one right away.
                     */
                    if(n != -1 )
                    {
#ifdef WFAN_WMM_EXT
                       /*
                        * end2end time sync:
                        *   1. retrieve the timestamp
                        *   2. calculate the Trt(1) roundtrip delay
                        *   3. store the minimum Trt(1)
                        *   4. store Cdut(t1) and Ctm(2)
                        */
                        gettimeofday(&lrtime, NULL);
                        /* get a round trip time */
                        rttime = wfa_ftime_diff(&lstime, &lrtime);

                        if(min_rttime > rttime)
                        {
                            min_rttime = rttime;
                            ttval.tv_sec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[12]);
                            ttval.tv_usec = bigEndianBuff2Int(&((tgHeader_t *)trafficBuf)->hdr[16]);
                            if(gtgStartSync != 0) /* "start" used to sync clock */
                            {
                                gtgPktRTDelay = min_rttime; 

                                /* adjust the local clock against TM clock */
                                ttval.tv_usec += (long) min_rttime/2*1000000; /* add one way delay */
                                if(ttval.tv_usec > 1000000)
                                {
                                   ttval.tv_sec +=1;
                                   ttval.tv_usec -=1000000;
                                }

                                settimeofday(&ttval, NULL);
      
                            } 
                        }

                        gettimeofday(&lstime, NULL);
                        int2BuffBigEndian(lstime.tv_sec, &((tgHeader_t *)trafficBuf)->hdr[12]);
                        int2BuffBigEndian(lstime.tv_usec, &((tgHeader_t *)trafficBuf)->hdr[16]);
#endif
                        if(gtgTransac != 0)
                        {
                            memset(respBuf, 0, WFA_BUFF_512); 
                            respLen = 0;
                            if(wfaSendShortFile(btSockfd, gtgTransac, trafficBuf, n, respBuf, &respLen) == DONE)
                            {
                                if(wfaCtrlSend(gxcSockfd, (BYTE *)respBuf, respLen)!=respLen)
                                {
                                      DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
                                }
                            }
                        }
                    }
                }
            }

#ifdef WFAN_WMM_EXT
            if(gtgStartSync != 0 )
            {
#ifdef _WINDOWS
               Sleep(5);
#else
               usleep(5000);
#endif
            }
#endif
        }

#endif

#ifdef WFA_WMM_EXT
#ifdef WFA_WMM_PS_EXT
        /*
         * Check if there is from Console
         */
        if(psSockfd > 0 && FD_ISSET(psSockfd, &sockSet))
        {
            wfaWmmPowerSaveProcess(psSockfd);
            continue;
        }
#endif /* WFA_WMM_PS_EXT */
#endif /* WFA_WMM_EXT */

        /*
         * If the profile is set for file transfer, this will run to
         * complete (blocking).
         */
  
        if(gtgSend != 0 && gtgTransac == 0)
        {
            tgStream_t *myStream = NULL;
   
            memset(respBuf, 0, WFA_BUFF_512); 
            respLen = 0;
            myStream = findStreamProfile(gtgSend);
#ifndef     _WINDOWS
            signal(SIGALRM, tmout_stop_send);
            alarm(myStream->profile.duration);
#else
   
            DPRINT_INFO(WFA_OUT, "\r\n WPA2 -Setting timer for %d ms\n",(myStream->profile.duration)*1000);
            timer_dur = (myStream->profile.duration)*1000;
            CreateThread(NULL, 0, wfa_wpa2_sleep_thread, (PVOID)&timer_dur, 0,&thr_id);
    
#endif
            wfaSendLongFile(btSockfd, gtgSend, respBuf, &respLen );
   
            if(wfaCtrlSend(gxcSockfd, (BYTE *)respBuf, respLen) != respLen)
            {
                 DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
            }
        }     
    }

    /*
     * necessarily free all mallocs for flat memory real-time systems
     */
    free(gStreams);
    free(trafficBuf);
    free(toutvalp);
    free(respBuf);
    free(xcCmdBuf);
    free(parmsVal);
#ifdef WFA_WMM_EXT
    free(e2eStats);
#endif

     /* Close sockets */
#ifndef _WINDOWS
    close(gagtSockfd);
    close(gxcSockfd);
    close(btSockfd);
#else
    closesocket(gagtSockfd);
    closesocket(gxcSockfd);
    closesocket(btSockfd);
#endif

    DPRINT_INFOL(WFA_OUT, "Exiting MAIN\n");
    return 0;
}
