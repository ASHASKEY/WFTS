
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors ($B!H(BAuthorized Licensees$B!I(B)..AN  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee$B!G(Bs proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below..AN  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee$B!G(Bs product to their customers with or
 *  without such third party$B!G(Bs private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications..AN  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein..AN 
 *.AN 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *.AN 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *.AN 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A.AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
 *  ******************************************************************************
 */
/*       Revision History:
 *       2006/11/10  -- initial created by qhu
 *       2007/02/15  -- WMM Extension Beta released by qhu, mkaroshi
 *       2007/03/30  -- 01.40 WPA2 and Official WMM Beta Release by qhu
 *       2007/04/20 --  02.00 WPA2 and Official WMM Release by qhu
 *       2007/08/15 --  02.10 WMM-Power Save release by qhu
 *       2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *       2007/11/07 --  02.30 Voice HSO -- qhu
 *       2007/12/10 --  02.32 no change
 *       2008/03/12 --  02.41 Bug #15, could cause "buffer overflow" in 
 *                            function "wfaSendStatsResp()" by increasing 
 *                            the "BYTE buff[]" size.
 *
 *                            Bug #19, potential race condition in function 
 *                            "sender()". Change the order of calling 
 *                            "wfaWMMPwrOn()" and "usleep()", also add 
 *                            "wfaSetDUTPwrMgmt(psave)" to turn PS ON before 
 *                            confirming start a test in function 
 *                            wfaStaSndConfirm().
 *
 *                            Bug #18, the hello counter limit could fails 
 *                            other tests. Reset num_hello count in function 
 *                            WfaSndHello()
 *
 */

/*
 * For MADWIFI driver, the TOS to 11E queue mapping as:
 *    0x08, 0x20            ----> WME_AC_BK;
 *    0x28, 0xa0            ----> WMC_AC_VI;
 *    0x30, 0xe0 0x88, 0xb8 ----> WME_AC_VO
 *      here 0x88 for UPSD, will be implemented later
 *    all other/default     ----> WME_AC_BE;
 */
#include "stdafx.h"
#ifdef WFA_WMM_EXT
#include <stdio.h>
#include <sys/types.h>
#ifdef _WINDOWS
#include <winsock2.h>
#include <time.h>

#ifdef _IA64_
#pragma warning (disable: 4267)
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <Ws2def.h>

#include <mswsock.h>
#include <iphlpapi.h>

#include <ntddndis.h>
#include <traffic.h>
#include <qos.h>
#include <qosobjs.h>

#include "resolve.h"

//#include "iphdr.h"

#define NOT_SPECIFIED   0xFFFF

#else
#include <pthread.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
#include <errno.h>
#endif
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include "wfa_debug.h"

#include "wfa_types.h"
#include "wfa_main.h"
#include "wfa_tg.h"
#include "wfa_debug.h"
#include "wfa_tlv.h"
#include "wfa_sock.h"
#include "wfa_rsp.h"
#include "wfa_wmmps.h"
#include "wfa_debug.h"



extern int firstPktCnt;

/*
 * external global thread sync variables
 */
extern tgWMM_t wmm_thr[];
extern int resetsnd;
extern int resetrcv;
extern int newCmdOn;
extern int gettimeofday(struct timeval *tv, void *tz);
extern tgStream_t *findStreamProfile(int id);
extern int gxcSockfd,vend;
extern int wfaSetProcPriority(int);
extern tgStream_t gStreams[WFA_MAX_TRAFFIC_STREAMS];
extern DWORD WINAPI wfa_traffic_resend_results_thread(void *direction);

extern int        tgSockfds[WFA_MAX_TRAFFIC_STREAMS];

extern int hasRecv;

//extern tgStream_t *gStreams;
extern unsigned short wfa_defined_debug;
extern DWORD recvThr;
extern int tgWMMTestEnable;
int num_stops=0;
int num_hello=0;
double gtgPktRTDelay = 0xFFFFFFFF;

extern int totalTranPkts, sentTranPkts;
extern BOOL gtgTransac;

int mainSendThread;

#ifdef WFA_WMM_PS_EXT
extern int gtgWmmPS;
extern int psSockfd;
extern int **ac_seq;
extern wfaWmmPS_t wmmps_info;
int msgsize=256;

extern void wfaSetDUTPwrMgmt(int mode);
extern void BUILD_APTS_MSG(int msg, unsigned long *txbuf);
extern void wmmps_wait_state_proc();

extern void mpx(char *m, void *buf_v, int len);
#endif /* WFA_WMM_PS_EXT */

extern unsigned int psTxMsg[512];
extern unsigned int psRxMsg[512];

extern void tmout_stop_send(int);
extern StationProcStatetbl_t stationProcStatetbl[LAST_TEST+1][11];
extern int bigEndianBuff2Int(char *buff);

int nsent;

//
// Function: ResolveAddress
//
// Description:
//    This routine resolves the specified address and returns a list of addrinfo
//    structure containing SOCKADDR structures representing the resolved addresses.
//    Note that if 'addr' is non-NULL, then getaddrinfo will resolve it whether
//    it is a string listeral address or a hostname.
//
struct addrinfo *ResolveAddress(char *addr, char *port, int af, int type, int proto)
{
    struct addrinfo hints,
    *res = NULL;
    int             rc;

    memset(&hints, 0, sizeof(hints));
    hints.ai_flags  = ((addr) ? 0 : AI_PASSIVE);
    hints.ai_family = af;
    hints.ai_socktype = type;
    hints.ai_protocol = proto;

    DPRINT_INFOL(WFA_OUT, "receiving port %s\n", port);
    rc = getaddrinfo(addr, port, &hints, &res);
    if (rc != 0)
    {
        DPRINT_ERR(WFA_ERR, "Invalid address %s\n", addr);
        return NULL;
    }

    return res;
}



//
// Routine: 
// DeleteFlow
// Description:
// Deletes the flow and its member variables
// Arguments:
// [in] pFlow -
//  ptr to the existing Flow struct.
//            
//******************************************************************************
BOOL DeleteFlow (IN PTC_GEN_FLOW *pFlow)
{
   if(pFlow == NULL || *pFlow == NULL)
   {
       return TRUE;
   }

   free(*pFlow);
   *pFlow = NULL;

   return TRUE;
}

//
// Routine: 
// CreateFlow
// Description:
// The function returns a tc flow in ppTcFlowObj on success 
// Arguments:
// [in,out] ppTcFlowObj -
//  double ptr to Flow struct in which the function returns the flow.
// [in] DSCPValue -
//  dscp value for the flow
// [in] OnePValue - 
//  802.1p value for the flow
// [in] ThrottleRate -
//  throttle rate for the flow
// Return:
// TRUE if file creating is successful
// FALSE if creating file failed.
//            
//******************************************************************************
BOOL CreateFlow( IN OUT PTC_GEN_FLOW *_ppTcFlowObj, 
                 IN  USHORT   DSCPValue, 
                 IN  USHORT   OnePValue,
                 IN  ULONG   ThrottleRate)
{
   BOOL status = FALSE;

 //
 // Flow Parameters
 //
   ULONG   TokenRate = QOS_NOT_SPECIFIED;
   ULONG   TokenBucketSize = QOS_NOT_SPECIFIED;
   ULONG   PeakBandwidth = QOS_NOT_SPECIFIED;
   ULONG   Latency = QOS_NOT_SPECIFIED;
   ULONG   DelayVariation = QOS_NOT_SPECIFIED;
   SERVICETYPE  ServiceType = SERVICETYPE_BESTEFFORT;
   ULONG   MaxSduSize = QOS_NOT_SPECIFIED;
   ULONG   MinimumPolicedSize = QOS_NOT_SPECIFIED;

   PVOID   pCurrentObject;
   PTC_GEN_FLOW _pTcFlowObj = NULL;

   int    Length = 0;
  
   //
   // Calculate the memory size required for the optional TC objects
   //
   Length += (OnePValue == NOT_SPECIFIED ? 0 : sizeof(QOS_TRAFFIC_CLASS)) + 
          (DSCPValue == NOT_SPECIFIED ? 0 : sizeof(QOS_DS_CLASS));

   //
   // Print the Flow parameters
   //
   if(ThrottleRate == QOS_NOT_SPECIFIED) 
   {
      // DPRINT_INFO(WFA_OUT, "\tThrottleRate: *\n");
      // DPRINT_INFO(WFA_OUT, "\tServiceType: Best effort\n");
   }
   else 
   {
      ServiceType = SERVICETYPE_GUARANTEED;
   }

   TokenRate = TokenBucketSize = ThrottleRate;

   //
   // Allocate the flow descriptor
   //
   _pTcFlowObj = (PTC_GEN_FLOW)malloc(FIELD_OFFSET(TC_GEN_FLOW, TcObjects) + Length);
   if (!_pTcFlowObj) 
   {
      DPRINT_ERR(WFA_ERR, "Flow Allocation Failed\n");
      goto Exit;
   }

   _pTcFlowObj->SendingFlowspec.TokenRate = TokenRate;
   _pTcFlowObj->SendingFlowspec.TokenBucketSize = TokenBucketSize;
   _pTcFlowObj->SendingFlowspec.PeakBandwidth = PeakBandwidth;
   _pTcFlowObj->SendingFlowspec.Latency = Latency;
   _pTcFlowObj->SendingFlowspec.DelayVariation = DelayVariation;
   _pTcFlowObj->SendingFlowspec.ServiceType = ServiceType;
   _pTcFlowObj->SendingFlowspec.MaxSduSize = MaxSduSize;
   _pTcFlowObj->SendingFlowspec.MinimumPolicedSize = MinimumPolicedSize;

   memcpy(&(_pTcFlowObj->ReceivingFlowspec), &(_pTcFlowObj->SendingFlowspec), sizeof(_pTcFlowObj->ReceivingFlowspec));

   _pTcFlowObj->TcObjectsLength = Length;

   //
   // Add any requested objects
   //
   pCurrentObject = (PVOID)_pTcFlowObj->TcObjects;

   if(OnePValue != NOT_SPECIFIED)
   {
      QOS_TRAFFIC_CLASS *pTClassObject = (QOS_TRAFFIC_CLASS*)pCurrentObject;
      pTClassObject->ObjectHdr.ObjectType = QOS_OBJECT_TRAFFIC_CLASS;
      pTClassObject->ObjectHdr.ObjectLength = sizeof(QOS_TRAFFIC_CLASS);
      pTClassObject->TrafficClass = OnePValue; //802.1p tag to be used

      pCurrentObject = (PVOID)(pTClassObject + 1);
   }

   if(DSCPValue != NOT_SPECIFIED)
   {
      QOS_DS_CLASS *pDSClassObject = (QOS_DS_CLASS*)pCurrentObject;
      pDSClassObject->ObjectHdr.ObjectType = QOS_OBJECT_DS_CLASS;
      pDSClassObject->ObjectHdr.ObjectLength = sizeof(QOS_DS_CLASS);
      pDSClassObject->DSField = (DSCPValue << 3); //Services Type
   }

   DeleteFlow(_ppTcFlowObj);
   *_ppTcFlowObj = _pTcFlowObj;

   status = TRUE;

   Exit:
   if(!status)
   {
       DPRINT_INFO(WFA_OUT, "Flow Creation Failed\n");
       DeleteFlow(&_pTcFlowObj);
   }
   else
   {
       DPRINT_INFO(WFA_OUT, "Flow Creation Succeeded\n");
   }

   return status;
}

//******************************************************************************
// Routine: 
//      DeleteFilter
//
// Description:
//      Deletes the filter and its member variables
//            
//******************************************************************************
BOOL DeleteFilter(PTC_GEN_FILTER *ppFilter)
{
    PTC_GEN_FILTER pFilter;

    if (ppFilter == NULL || *ppFilter == NULL)
    {
        return TRUE;
    }

    pFilter = (*ppFilter);

    if (pFilter->Pattern)
    {
        free(pFilter->Pattern);
    }

    if (pFilter->Mask)
    {
        free(pFilter->Mask);
    }

    *ppFilter = NULL;

    return TRUE;
}

//
// Routine: 
// CreateFilter
// Description:
// The function returns a tc filter in ppFilter on success 
// Arguments:
// [in, out] ppFilter - 
//  double ptr to Filter struct in which the function returns the filter
// [in] Address -
//  destination address of the outgoing packets of interest.
// [in] Port -
//  destination port of the outgoing packets of interest.
// [in] ProtocolId -
//  protocol of the outgoing packets of interest.
// Return:
// TRUE if filter creating successes.
// FALSE if failed.
//
BOOL CreateFilter( IN OUT PTC_GEN_FILTER  *ppFilter,
                   IN  SOCKADDR_STORAGE Address,
                   IN  USHORT    Port,
                   IN  UCHAR    ProtocolId)
{  
   BOOL status = FALSE;
   USHORT AddressFamily = Address.ss_family;
   PTC_GEN_FILTER pFilter = NULL;
   PIP_PATTERN pPattern = NULL;
   PIP_PATTERN pMask = NULL;

   if(AddressFamily != AF_INET)
   {
      DPRINT_INFO(WFA_OUT, "Address family is not AF_INET");
      goto Exit;
   }
  
   //
   // Allocate memory for the filter
   //
   pFilter = (PTC_GEN_FILTER)malloc(sizeof(TC_GEN_FILTER));
   if(!pFilter)
   {
      DPRINT_INFO(WFA_OUT, "Error, No memory for filter\n");
      goto Exit;
   }
   ZeroMemory(pFilter, sizeof(TC_GEN_FILTER));
      
   //
   // Allocate memory for the pattern and mask
   //
   pPattern = (PIP_PATTERN)malloc(sizeof(IP_PATTERN));
   pMask    = (PIP_PATTERN)malloc(sizeof(IP_PATTERN));

   if(!pPattern || !pMask)
   {
      DPRINT_INFO(WFA_OUT, "pPattern or pMask is null");
      goto Exit;
   }
  
   memset(pPattern, 0, sizeof(IP_PATTERN));

   pPattern->DstAddr = ((SOCKADDR_IN *)&Address)->sin_addr.s_addr;
   pPattern->tcDstPort = htons(Port);
   pPattern->ProtocolId = ProtocolId;

   memset(pMask, (ULONG)-1, sizeof(IP_PATTERN));
   //
   // Set the source address and port to wildcard
   // 0 -> wildcard, 0xFF-> exact match 
   //
   pMask->SrcAddr = 0;
   pMask->tcSrcPort = 0;

   //
   // If the user specified 0 for dest port, dest address or protocol
   // set the appropriate mask as wildcard
   // 0 -> wildcard, 0xFF-> exact match 
   //

   if(pPattern->tcDstPort == 0)
   {
      pMask->tcDstPort = 0;
   }

   if(pPattern->ProtocolId == 0)
   {
      pMask->ProtocolId = 0;
   }

   if(pPattern->DstAddr == 0)
   {
      pMask->DstAddr = 0;
   }

   pFilter->AddressType = NDIS_PROTOCOL_ID_TCP_IP;
   pFilter->PatternSize = sizeof(IP_PATTERN);
   pFilter->Pattern = pPattern;
   pFilter->Mask = pMask;

   //
   // Delete any previous instances of the Filter
   //
   DeleteFilter(ppFilter);
   *ppFilter = pFilter;

   status = TRUE;

   Exit:
   if(!status)
   {
      DPRINT_INFO(WFA_OUT, "Filter Creation Failed\n");
      DeleteFilter(&pFilter);
   }
   else
   {
      DPRINT_INFO(WFA_OUT, "Filter Creation Succeeded\n");
   }

   return status; 
}

//
// Routine: 
// ClNotifyHandler
// Description:
// Empty notification handler.
// The ClNotifyHandler function is used by traffic control to notify the client of various 
// traffic control$(Dx7(Bspecific events, including the deletion of flows, changes in filter parameters,
// or the closing of an interface.
// Arguments:
// [in] ClRegCtx -
//  Client registration context, provided to traffic control by the client with the client's call
//  to the TcRegisterClient function.
// [in] ClIfcCtx -
//  Client interface context, provided to traffic control by the client with the client's call to
//  the TcOpenInterface function. Note that during a TC_NOTIFY_IFC_UP event, ClIfcCtx is not
//  available and will be set to NULL.
// [in] Event -
//  Describes the notification event. See the Remarks section for a list of notification events.
// [in] SubCode -
//  Handle used to further qualify a notification event.
// [in] BufSize -
//  Size of the buffer included with the notification event, in bytes.
// [in] Buffer -
//  Buffer containing the detailed event information associated with Event and SubCode.
// Return:
// None
//
void ClNotifyHandler( IN HANDLE ClRegCtx,
                      IN HANDLE ClIfcCtx,
                      IN ULONG Event,
                      IN HANDLE SubCode,
                      IN ULONG BufSize,
                      IN PVOID Buffer)
{
   UNREFERENCED_PARAMETER(ClRegCtx);
   UNREFERENCED_PARAMETER(ClIfcCtx);
   //
   // Notification was unexpected
   //
   DPRINT_INFO(WFA_OUT, "Unexpected notification: Event=%d, SubCode=%p, BufSize=%d, Buffer=%p", 
                             (int)Event, (void *)SubCode, (int)BufSize, Buffer);
}

//
// Routine: 
// ClearIfcList
// Description:
// Clears the IfcList and its member variables
// Arguments:
// [in] pIfcList -
//  The interface list.
// Return:
// TRUE if successes or FALSE if fails.
//
BOOL ClearIfcList( IN PIFC_LIST pIfcList)
{
   ULONG i;

   if(!pIfcList)
   {
      return TRUE;
   }

   if(pIfcList->pIfcInfo)
   {
      //
      // Delete filter, flow and interface
      //
      PIFC_INFO pCurrentIfcInfo = pIfcList->pIfcInfo;

      for(i = 0; i < pIfcList->IfcCount; i ++)
      {
         if(pCurrentIfcInfo->hFilter)
         {
            TcDeleteFilter(pCurrentIfcInfo->hFilter);
         }
         if(pCurrentIfcInfo->hFlow)
         {
            TcDeleteFlow(pCurrentIfcInfo->hFlow);
         }
         if(pCurrentIfcInfo->hIfc)
         {
            TcCloseInterface(pCurrentIfcInfo->hIfc);
         }

         pCurrentIfcInfo++;
      }

      free(pIfcList->pIfcInfo);
   }

   ZeroMemory(pIfcList, sizeof(IFC_LIST));

   return TRUE;
}


//
// Routine: 
// MakeIfcList
// Description:
// The function enumerates all TC enabled interfaces. 
// opens each TC enabled interface and stores each ifc handle in IFC_LIST struct
// pointed to by pIfcList.
// Arguments:
// [in] hClient -
//  Handle returned by TcRegisterClient
// [in] pIfcList -
//  ptr to IfcList structure which will be populated by the function
// Return:
// TRUE if successes or FALSE if fails.
//
BOOL
MakeIfcList( IN HANDLE  hClient,
             IN PIFC_LIST pIfcList)
{
   BOOL    status = FALSE;
   ULONG    err = ERROR_INVALID_PARAMETER;

   ULONG     BufferSize = 1, ActualBufferSize, RemainingBufferSize = 0;
   PTC_IFC_DESCRIPTOR pIfcBuffer = NULL, pCurrentIfc;
   PIFC_INFO   pIfcInfo = NULL, pCurrentIfcInfo;
   ULONG    nIfcs = 0;

   //
   // Enumerate the TC enabled interfaces
   //
   while(TRUE)
   {
      ActualBufferSize = BufferSize;
      pIfcBuffer = (PTC_IFC_DESCRIPTOR)malloc(ActualBufferSize);
      if(pIfcBuffer == NULL)
      {
         break;
      }

      err = TcEnumerateInterfaces(hClient, &ActualBufferSize, pIfcBuffer);
      if(err == ERROR_INSUFFICIENT_BUFFER)
      {
         free(pIfcBuffer);
         BufferSize *= 2;
      }
      else
      {
         break;
      }
   }

   if(err != NO_ERROR)
   {
      goto Exit;
   }

   //
   // Count the number of interfaces
   //

   pCurrentIfc = pIfcBuffer;
   RemainingBufferSize = ActualBufferSize;
   while(RemainingBufferSize)
   {
      nIfcs ++;

      RemainingBufferSize -= pCurrentIfc->Length;
      pCurrentIfc = (PTC_IFC_DESCRIPTOR)(((PBYTE)pCurrentIfc) + pCurrentIfc->Length);
   }
  
   if(nIfcs == 0)
   {
      goto Exit;
   }

   //
   // Allocate memory for the size(IFC_INFO) X nIfcs
   // 
   pIfcInfo = (PIFC_INFO)malloc(sizeof(IFC_INFO) * nIfcs);
   if(!pIfcInfo)
   {
      goto Exit;
   }
  
   ZeroMemory(pIfcInfo, sizeof(IFC_INFO) * nIfcs);

   ClearIfcList(pIfcList);
   pIfcList->IfcCount = nIfcs;
   pIfcList->pIfcInfo = pIfcInfo;

   //
   // Open Each interface and store the ifc handle in ifcList
   //
   pCurrentIfc = pIfcBuffer;
   pCurrentIfcInfo = pIfcInfo;

   RemainingBufferSize = ActualBufferSize;
   while(RemainingBufferSize)
   {
     HANDLE hIfc;

     err = TcOpenInterfaceW(pCurrentIfc->pInterfaceName, 
                    hClient,
                    0,
                    &hIfc);
  
     if(err != NO_ERROR)
     {
       DPRINT_ERR(WFA_ERR, "TcOpenInterface Failed %d\n", err);
       break;
     }

     pCurrentIfcInfo->hIfc = hIfc;

     RemainingBufferSize -= pCurrentIfc->Length;
     pCurrentIfc = (PTC_IFC_DESCRIPTOR)(((PBYTE)pCurrentIfc) + pCurrentIfc->Length);
     pCurrentIfcInfo ++;
   }
  
   if(err != NO_ERROR)
   {
      goto Exit;
   }

   status = TRUE;

   Exit:
   if(!status)
   {
      ClearIfcList(pIfcList);
   }
   
   //
   // Cleanup the IfcBuffer
   //
   if(pIfcBuffer)
   {
      free(pIfcBuffer);
   }

   return status;
}

//
// Routine: 
// AddTcFlows
// Description:
// Add Tc Flow in pTcFlow to each interface in IfcList.
// Arguments:
// [in] IfcList -
//  The interface list.
// [in] pTcFlow -
//  The TC flow to add.
// Return:
// TRUE if successes. Otherwise return FALSE.
//
BOOL AddTcFlows( IN IFC_LIST  IfcList,
                 IN PTC_GEN_FLOW pTcFlow)
{
   UINT   i;
   ULONG  err;
   BOOL  status = FALSE;
   PIFC_INFO pCurrentIfcInfo = IfcList.pIfcInfo;

   //
   // For each interface in the list, add a TC flow
   //
   for(i = 0; i < IfcList.IfcCount; i++)
   {
       HANDLE hFlow;

       err = TcAddFlow(pCurrentIfcInfo->hIfc,
                       0, 0, pTcFlow, &hFlow);
       if(err != NO_ERROR)
       {
          DPRINT_ERR(WFA_ERR, "TcAddFlow Failed %d\n", err);
          goto Exit;
       }

       pCurrentIfcInfo->hFlow = hFlow;
       pCurrentIfcInfo++;
   }

   status = TRUE;

   Exit:

   return status;
}

//
// Routine: 
// AddTcFilters
// Description:
// Add Tc Filter in pTcFilter to each interface in IfcList
// Arguments:
// [in] IfcList -
//  The interface list.
// [in] pTcFilter -
//  The filter to apply.
// Return:
// TRUE if successes. Otherwise return FALSE.
//
BOOL AddTcFilters( IN IFC_LIST  IfcList,
                   IN PTC_GEN_FILTER pTcFilter)
{
   UINT  i;
   ULONG  err;
   BOOL  status = FALSE;
   PIFC_INFO pCurrentIfcInfo = IfcList.pIfcInfo;

   //
   // For each interface in the list, add TC filter on the corresponding TcFlow
   //
   for(i = 0; i < IfcList.IfcCount; i++)
   {
       HANDLE hFilter;

       err = TcAddFilter(pCurrentIfcInfo->hFlow, pTcFilter, &hFilter);
       if(err != NO_ERROR)
       {
           DPRINT_ERR(WFA_ERR, "TcAddFilter Failed %d\n", err);
           goto Exit;
       }

       pCurrentIfcInfo->hFilter = hFilter;
       pCurrentIfcInfo++;      
   }

   status = TRUE;

   Exit:

   return status;
}


int CleanTos_Win7 (IN PIFC_LIST pIfcList,PTC_GEN_FILTER *ppFilter,IN PTC_GEN_FLOW *pFlow)
{
   //
   // Cleanup
   //
   ClearIfcList(pIfcList);
   DeleteFilter(ppFilter);
   DeleteFlow(pFlow);
   return 0;
}

/*
 * wfaTGSetPrio_Win7(): This depends on the network interface card.
 *               So you might want to remap according to the driver
 *               provided.
 *               The current implementation is to set the TOS/DSCP bits
 *               in the IP header
 */
int wfaTGSetPrio_Win7(int sockfd, int tgClass, tgProfile_t *myProfile)
{
   PTC_GEN_FLOW  pTcFlow = NULL;
 
   DWORD TOS = (tgClass << 5);
   SOCKADDR_STORAGE Address = { 0 };
   struct addrinfo  *dest = NULL;

   int gProtocol = IPPROTO_UDP;
   PTC_GEN_FILTER  pTcFilter = NULL;
   TCI_CLIENT_FUNC_LIST ClientHandlerList;
   HANDLE    hClient = TC_INVALID_HANDLE;
   IFC_LIST   IfcList = {0};
   ULONG    err;
   int Qos=0;

   int tosval;
   int threadPrio;
    
   int size = sizeof(tosval);

   DPRINT_INFOL(WFA_OUT, "Entering wfaTGSetPrio_Win7 with tag = %i ...\n", tgClass);

#if 1
   getsockopt(sockfd, IPPROTO_IP, IP_TOS, (char *)&tosval, &size);
#endif

   switch(tgClass)
   {
       case TG_WMM_AC_BK:
       /*Change this value to the ported device*/
       Qos = 1;
       DPRINT_INFOL(WFA_OUT, "Setting QoS Background tag\n");
       tosval = TOS_BK;
       threadPrio = THREAD_PRIORITY_BELOW_NORMAL;
       break;

       case TG_WMM_AC_VI:
       Qos = 4;
       DPRINT_INFOL(WFA_OUT, "Setting QoS Video tag\n");
       tosval = TOS_VI;
       threadPrio = THREAD_PRIORITY_ABOVE_NORMAL;       
       break;

       case TG_WMM_AC_UAPSD:
       tosval = 0x88;
       break;

       case TG_WMM_AC_VO:
       /*Change this value to the ported device*/
       Qos = 6;
       DPRINT_INFOL(WFA_OUT, "Setting QoS Voice Tag\n");
       tosval=TOS_VO7;
       threadPrio = THREAD_PRIORITY_HIGHEST;       
       break;

       case TG_WMM_AC_BE:
       Qos = 0;
       DPRINT_INFOL(WFA_OUT, "Setting QoS BE tag\n");
       tosval = TOS_BE;
       threadPrio = THREAD_PRIORITY_NORMAL;
       break;

#if 0
       case TG_WMM_AC_UP0:
       tosval = 0x00;
       break;

       case TG_WMM_AC_UP1:
       tosval = 0x20;
       break;

       case TG_WMM_AC_UP2:
       tosval = 0x40;
       break;

       case TG_WMM_AC_UP3:
       tosval = 0x60;
       break;

       case TG_WMM_AC_UP4:
       tosval = 0x80;
       break;

       case TG_WMM_AC_UP5:
       tosval = 0xa0;
       break;

       case TG_WMM_AC_UP6:
       tosval = 0xc0;
       break;

       case TG_WMM_AC_UP7:
       tosval = 0xe0;
       break;
#endif
       default:
         DPRINT_WARNING(WFA_WNG, "Unknown tag value %i\n", tgClass);
         tosval = 0x00;
           /* default */
         ;
   }

   SetThreadPriority(GetCurrentThread(), threadPrio);
#if 0
   if(tgWMMTestEnable == 0)
   {
      SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);
   }
   else
   {
      SetThreadPriority(GetCurrentThread(), threadPrio);
   } 
#endif

#ifdef WFA_WMM_EXT 
#ifdef WFA_WMM_PS_EXT
   psTxMsg[1] = tosval;
#endif
#endif



   //
   // Create the TC Flow with the parameters
   //
   DPRINT_INFO(WFA_OUT, "TC flow creation - start\n");
   if(!CreateFlow(&pTcFlow, Qos, NOT_SPECIFIED, QOS_NOT_SPECIFIED))
   {
      goto CLEANUP;
   }

   char *stport = (char *) malloc(16);
//   char stport[16];
   sprintf(stport, "%i", myProfile->dport);

   DPRINT_INFOL(WFA_OUT, "The port string is %s\n", stport);

   // Resolve the destination address
   dest = ResolveAddress( myProfile->dipaddr, stport, AF_INET, SOCK_DGRAM, IPPROTO_UDP);
 
   if(dest == NULL)
   {
      DPRINT_ERR(WFA_ERR, "Couldnot resolve the ip address");
      goto CLEANUP;
   }

   Address.ss_family = AF_INET;

   memcpy(&Address, dest->ai_addr, (int)dest->ai_addrlen);
   //Address.ss_family = AF_INET;

   DPRINT_INFO(WFA_OUT, "TC filter creation - start\n");

   DPRINT_INFOL(WFA_OUT, "creating a filter for QoS %i\n", Qos);

   //
   // Create the TC Filter with the parameters
   //
   if (!CreateFilter(&pTcFilter, Address, myProfile->dport, gProtocol))
   {
      goto CLEANUP;
   }

   //
   // Register TC client
   //
   memset(&ClientHandlerList, 0, sizeof(ClientHandlerList));
   ClientHandlerList.ClNotifyHandler = (TCI_NOTIFY_HANDLER)ClNotifyHandler;
   err = TcRegisterClient(CURRENT_TCI_VERSION, 0, &ClientHandlerList, &hClient);
   if(err != NO_ERROR)
   {
      DPRINT_ERR(WFA_ERR, "TcRegisterClient Failed %d\n", err);

      if(err == ERROR_OPEN_FAILED)
      {
         DPRINT_ERR(WFA_ERR, "Please make sure you are running with admin credentials\n");
      }

      goto CLEANUP;
   }

   //
   // Enumerate All TC enabled Interfaces and 
   // store the information in IfcList
   //
   if(!MakeIfcList(hClient, &IfcList))
   {
      DPRINT_ERR(WFA_ERR, "Error reading interface list, make sure QoS Packet Scheduler is active for this interface\n");
      goto CLEANUP;
   }

   //
   // Add pTcFlow on all the Ifcs in the IfcList
   //
   if(!AddTcFlows(IfcList, pTcFlow))
   {
      DPRINT_ERR(WFA_ERR, "Error adding flows\n");
      goto CLEANUP;
   }

   //
   // Add pTcFilter to all the corresponding TcFlows
   // on all the Ifcs in the IfcList
   //
   if (!AddTcFilters(IfcList, pTcFilter))
   {
      DPRINT_ERR(WFA_ERR, "Error adding filter...\n");
      goto CLEANUP;
   }

#if 1
   if(setsockopt ( sockfd, IPPROTO_IP, IP_TOS, (char *)&tosval, sizeof(tosval)) < 0)
   {
      DPRINT_ERR(WFA_ERR, "Failed to set IP_TOS\n");
   }
#endif

   DPRINT_INFO(WFA_OUT, "set the TOS as %d\n",tosval);
   return (tosval == 0xE0)?0xD8:tosval;

   CLEANUP:

   //
   // Cleanup
   //
   CleanTos_Win7(&IfcList,&pTcFilter,&pTcFlow);
   return 0;
}



/*
 * wfaTGSetPrio(): This depends on the network interface card.
 *               So you might want to remap according to the driver
 *               provided.
 *               The current implementation is to set the TOS/DSCP bits
 *               in the IP header
 */
int wfaTGSetPrio(int sockfd, int tgClass)
{
    int tosval;
    int threadPrio;
    
    int size = sizeof(tosval);
    getsockopt(sockfd, IPPROTO_IP, IP_TOS, (char *)&tosval, &size);

    switch(tgClass)
    {
       case TG_WMM_AC_BK:
       /*Change this value to the ported device*/
#if 0
    if(vend == WMM_ATHEROS)
  tosval = 0x08;
    else
#endif
       tosval = TOS_BK;
       threadPrio = THREAD_PRIORITY_BELOW_NORMAL;
       break;

       case TG_WMM_AC_VI:
       tosval = TOS_VI;
       threadPrio = THREAD_PRIORITY_ABOVE_NORMAL;       
       break;

       case TG_WMM_AC_UAPSD:
       tosval = 0x88;
       break;

       case TG_WMM_AC_VO:
       /*Change this value to the ported device*/
       tosval=TOS_VO7;
       //else
       //tosval = TOS_VO;
       //tosval = 0x30;
//#       tosval = 0x88;
       threadPrio = THREAD_PRIORITY_HIGHEST;       
       break;

       case TG_WMM_AC_BE:
       tosval = TOS_BE;
       threadPrio = THREAD_PRIORITY_NORMAL;
       break;

       default:
         tosval = 0x00;
           /* default */
         ;
    }

    SetThreadPriority(GetCurrentThread(), threadPrio);
#if 0
    if(tgWMMTestEnable == 0)
    {
       SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);
    }
    else
    {
       SetThreadPriority(GetCurrentThread(), threadPrio);
    }
#endif 

#ifdef WFA_WMM_EXT 
#ifdef WFA_WMM_PS_EXT
    psTxMsg[1] = tosval;
#endif
#endif
#ifdef _WINDOWS
    if(setsockopt ( sockfd, IPPROTO_IP, IP_TOS, (char *)&tosval, sizeof(tosval)) < 0)
#else
    if(setsockopt ( sockfd, IPPROTO_IP, IP_TOS, &tosval, sizeof(tosval)) != 0)
#endif
    {
       DPRINT_ERR(WFA_ERR, "Failed to set IP_TOS\n");
    }

    DPRINT_INFO(WFA_OUT, "set the TOS as %d\n",tosval);
    return (tosval == 0xE0)?0xD8:tosval;
}


#ifdef resolve
/*
 * wfaSetThreadPrio():
 *    Set thread priorities
 *    It is an optional experiment if you decide not necessary.
 */
void wfaSetThreadPrio(int tid, int class)
{
    struct sched_param tschedParam;
    pthread_attr_t tattr;

    pthread_attr_init(&tattr);
    pthread_attr_setschedpolicy(&tattr, SCHED_RR);

    switch(class)
    {
       case TG_WMM_AC_BK:
       tschedParam.sched_priority = 70-3;
       break;
       case TG_WMM_AC_VI:
       tschedParam.sched_priority = 70-1;
       break;
       case TG_WMM_AC_VO:
       tschedParam.sched_priority = 70;
       break;
       case TG_WMM_AC_BE:
       tschedParam.sched_priority = 70-2;
       default:
           /* default */
         ;
    }

    pthread_attr_setschedparam(&tattr, &tschedParam);
}
#endif
/* 
 * collects the traffic statistics from other threads and 
 * sends the collected information to CA
 */
void  wfaSentStatsResp(int sock, BYTE *buf)
{
   int i, total=0, pkLen;
   tgStream_t *allStreams = gStreams;
   dutCmdResponse_t *sendStatsResp = (dutCmdResponse_t *)buf, *first;
   char buff[WFA_BUFF_4K];
   DPRINT_INFO(WFA_OUT, "wfaSentStatsResp: gstream is %d\n",gStreams);
   if(sendStatsResp == NULL)
      return;

   first = sendStatsResp;
 
   for(i = 0; i < WFA_MAX_TRAFFIC_STREAMS; i++)
   {
#if 0
          DPRINT_INFO(WFA_OUT, "id=%i rxFrames=%i txFrames=%i rxPayLoadBytes=%i txPayloadBytes=%i lastPktSN=%i\n", allStreams->id,
                                  allStreams->stats.rxFrames,
                                  allStreams->stats.txFrames,
                                  allStreams->stats.rxPayloadBytes,
                                  allStreams->stats.txPayloadBytes,
                                  allStreams->lastPktSN); 
#endif
      if((allStreams->id != 0) && (allStreams->profile.direction == DIRECT_SEND) && (allStreams->state == WFA_STREAM_ACTIVE))
      {
          sendStatsResp->status = STATUS_COMPLETE;
          sendStatsResp->streamId = allStreams->id;
          memcpy(&sendStatsResp->cmdru.stats, &allStreams->stats, sizeof(tgStats_t));          

          DPRINT_INFO(WFA_OUT, "id=%i rxFrames=%i txFrames=%i rxPayLoadBytes=%i txPayloadBytes=%i lastPktSN=%i\n", allStreams->id,
                                  allStreams->stats.rxFrames,
                                  allStreams->stats.txFrames,
                                  allStreams->stats.rxPayloadBytes,
                                  allStreams->stats.txPayloadBytes,
                                  allStreams->lastPktSN); 

          sendStatsResp++;
          total++;
      } 
      allStreams++;
   } 

#if 0
   DPRINT_INFO(WFA_OUT, "%i %i %i %i %i %i\n", first->cmdru.stats.txFrames,
                                  first->cmdru.stats.rxFrames,
                                  first->cmdru.stats.txPayloadBytes,
                                  first->cmdru.stats.rxPayloadBytes); 
#endif

   wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, total*sizeof(dutCmdResponse_t),
                 (BYTE *)first, (BYTE *)buff);

   pkLen = WFA_TLV_HDR_LEN + total*sizeof(dutCmdResponse_t); 

#if 0
   for(i = 0; i< pkLen; i++)
   DPRINT_INFO(WFA_OUT, "%x ", buff[i]);

   DPRINT_INFO(WFA_OUT, "\n");
#endif

   if(wfaCtrlSend(sock, (BYTE *)buff, pkLen) != pkLen)
   {
       DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
       // reSend one more time
       wfaCtrlSend(sock, (BYTE *)buff, pkLen);
   }
   DPRINT_INFO(WFA_OUT, "wfaSentStatsResp exit: gstream is %d\n",gStreams);
   return;
}

#ifdef WFA_WMM_PS_EXT
/*
 * sender(): This is a generic function to send a packed for the given dsc 
 *               (ac:VI/VO/BE/BK), before sending the packet the function
 *               puts the station into the PS mode indicated by psave and 
 *               sends the packet after sleeping for sllep_period
 */
int sender(char psave,int sleep_period,int dsc)
{
   int r;

   PRINTF("\nsleeping for %d",sleep_period);
   wfaSetDUTPwrMgmt(psave);
   usleep(sleep_period);
   PRINTF("\nAfter create sending %d\n",dsc);
   create_apts_msg(APTS_DEFAULT, psTxMsg,wmmps_info.my_sta_id);
   wfaTGSetPrio(psSockfd, dsc);
   PRINTF("\nAfter create");
   PRINTF("\nlock met");
   r = sendto(psSockfd, psTxMsg, msgsize, 0, (struct sockaddr *)&wmmps_info.psToAddr, sizeof(struct sockaddr));
   return r;
}

/*
 * wfaStaSndHello(): This function sends a Hello packet 
 *                and sleeps for sleep_period, the idea is
 *                to keep sending hello packets till the console
 *                responds, the function keeps a check on the MAX
 *                Hellos and if number of Hellos exceed that it quits
 */
int WfaStaSndHello(char psave,int sleep_period,int *state)
{
   int r;
   tgWMM_t *my_wmm = &wmm_thr[wmmps_info.ps_thread];

   if(!(num_hello++))
       create_apts_msg(APTS_HELLO, psTxMsg,0);
   r = sendto(psSockfd, psTxMsg, msgsize, 0, (struct sockaddr *)&wmmps_info.psToAddr, sizeof(struct sockaddr));

   usleep(sleep_period);

   pthread_mutex_lock(&my_wmm->thr_flag_mutex);
   if(my_wmm->thr_flag)
   {
       (*state)++;
       num_hello=0;
       my_wmm->thr_flag=0;
   }

   pthread_mutex_unlock(&my_wmm->thr_flag_mutex);
   if(num_hello > MAXHELLO)
   {
       DPRINT_ERR(WFA_ERR, "Too many Hellos sent\n");
       gtgWmmPS = 0;
       num_hello=0;
       close(psSockfd);
       psSockfd = -1;
       signal(SIGALRM, SIG_IGN);
   } 

   return 0;
}

/*
 * wfaStaSndConfirm(): This function sends the confirm packet
 *                which is sent after the console sends the
 *                test name to the station
 */
int WfaStaSndConfirm(char psave,int sleep_period,int *state)
{
   int r;
   static int num_hello=0;
   wfaSetDUTPwrMgmt(psave);
   if(!num_hello)
      create_apts_msg(APTS_CONFIRM, psTxMsg,0);
   r = sendto(psSockfd, psTxMsg, msgsize, 0, (struct sockaddr *)&wmmps_info.psToAddr, sizeof(struct sockaddr));
   (*state)++;

   return 0;
}

/*
 * WfaStaSndVO(): This function sends a AC_VO packet
 *                after the time specified by sleep_period
 *                and advances to the next state for the given test case
 */
int WfaStaSndVO(char psave,int sleep_period,int *state)
{
   int r;
   static int en=1;
   PRINTF("\r\nEnterring WfastasndVO %d",en++);
   if ((r=sender(psave,sleep_period,TG_WMM_AC_VO))>=0)
      (*state)++;
   else
      PRINTF("\r\nError\n");

   return 0;
}

/*
 * WfaStaSnd2VO(): This function sends two AC_VO packets
 *                after the time specified by sleep_period
 *                and advances to the next state for the given test case
 */
int WfaStaSnd2VO(char psave,int sleep_period,int *state)
{
   int r;
   static int en=1;

   PRINTF("\r\nEnterring WfastasndVO %d",en++);
   if ((r=sender(psave,sleep_period,TG_WMM_AC_VO))>=0)
   {
       r = sendto(psSockfd, psTxMsg, msgsize, 0, (struct sockaddr *)&wmmps_info.psToAddr, sizeof(struct sockaddr));
       mpx("STA msg",psTxMsg,64);
       (*state)++;
   }
   else
      PRINTF("\r\nError\n");

   return 0;
}

/*
 * WfaStaSndVI(): This function sends a AC_VI packet
 *                after the time specified by sleep_period
 *                and advances to the next state for the given test case
 */
int WfaStaSndVI(char psave,int sleep_period,int *state)
{
   int r;
   static int en=1;

   PRINTF("\r\nEnterring WfastasndVI %d",en++);
   if ((r=sender(psave,sleep_period,TG_WMM_AC_VI))>=0)
      (*state)++;

   return 0;
}

/*
 * WfaStaSndBE(): This function sends a AC_BE packet
 *                after the time specified by sleep_period
 *                and advances to the next state for the given test case
 */
int WfaStaSndBE(char psave,int sleep_period,int *state)
{
   int r;
   static int en=1;

   PRINTF("\r\nEnterring WfastasndBE %d",en++);
   if ((r=sender(psave,sleep_period,TG_WMM_AC_BE))>=0)
      (*state)++;

   return 0;
}
/*
 * WfaStaSndBK(): This function sends a AC_BK packet
 *                after the time specified by sleep_period
 *                and advances to the next state for the given test case
 */
int WfaStaSndBK(char psave,int sleep_period,int *state)
{
   int r;
   static int en=1;

   PRINTF("\r\nEnterring WfastasndBK %d",en++);
   if ((r=sender(psave,sleep_period,TG_WMM_AC_BK))>=0)
      (*state)++;

   return 0;
}

/*
 * WfaStaSndVOCyclic(): The function is the traffic generator for the L.1 test
 *                      caseThis function sends 3000 AC_VO packet
 *                      after the time specified by sleep_period (20ms)
 */
int WfaStaSndVOCyclic(char psave,int sleep_period,int *state)
{
   int i;
   static int en=1;

   for(i=0;i<3000;i++)
   {
       PRINTF("\r\nEnterring WfastasndVOCyclic %d",en++);
       sender(psave,sleep_period,TG_WMM_AC_VO);
       if(!(i%50))
       {
         PRINTF(".");
         fflush(stdout);
       }
   }

   (*state)++;

   return 0;
}

/*
 * WfaStaWaitStop(): This function sends the stop packet on behalf of the
 *                   station, the idea is to keep sending the Stop
 *                   till a stop is recd from the console,the functions
 *                   quits after stop threshold reaches.
 */
int WfaStaWaitStop(char psave,int sleep_period,int *state)
{
   int r;
   int myid=wmmps_info.ps_thread;
   PRINTF("\n Entering Sendwait");
   usleep(sleep_period);
   if(!num_stops)
   {
       wfaSetDUTPwrMgmt(psave);
       wfaTGSetPrio(psSockfd, TG_WMM_AC_BE);
   }

   num_stops++;
   create_apts_msg(APTS_STOP, psTxMsg,wmmps_info.my_sta_id);
   r = sendto(psSockfd, psTxMsg, msgsize, 0, (struct sockaddr *)&wmmps_info.psToAddr, sizeof(struct sockaddr));
   mpx("STA msg",psTxMsg,64);

   wmm_thr[myid].stop_flag = 1;
   pthread_mutex_lock(&wmm_thr[myid].thr_stop_mutex);
   pthread_cond_signal(&wmm_thr[myid].thr_stop_cond);
   pthread_mutex_unlock(&wmm_thr[myid].thr_stop_mutex);

   if(num_stops > MAX_STOPS)
   {
       DPRINT_ERR(WFA_ERR, "Too many stops sent\n");
       gtgWmmPS = 0;
       close(psSockfd);
       psSockfd = -1;
       signal(SIGALRM, SIG_IGN);
       //wfaSetDUTPwrMgmt(PS_OFF);
   }

   return 0;
}

#endif 

#ifdef _WINDOWS
DWORD WINAPI wfa_wmm_sleep_thread(void *thr_param)
{
 int sleep_prd = *(int *)thr_param;
 Sleep(sleep_prd);
    tmout_stop_send(0);
 return 0;
}
#endif

#ifdef _WINDOWS
DWORD WINAPI wfa_wmm_thread(void *thr_param)
#else
void * wfa_wmm_thread(void *thr_param)
#endif
{
    int myId = ((tgThrData_t *)thr_param)->tid;
    tgThrData_t *tdata =(tgThrData_t *) thr_param;
    tgWMM_t *my_wmm = &wmm_thr[myId];
    tgStream_t *myStream = NULL;
    int myStreamId;
    int mySock, status, respLen;
    tgProfile_t *myProfile;
    BYTE respBuf[WFA_BUFF_4K];
 int rdirect = DIRECT_SEND;
int resendcnt = 0;
#ifdef WFA_WMM_PS_EXT
    StationProcStatetbl_t  curr_state;
#endif
#ifndef _WINDOWS
    pthread_attr_t tattr;
   
    pthread_attr_init(&tattr);
    pthread_attr_setschedpolicy(&tattr, SCHED_RR);
#else
    DWORD thr_id;
    int timer_dur;
    int iOptVal;
    int iOptLen = sizeof(int);

#endif

    while(1)
    {
#ifdef _WINDOWS
       DPRINT_INFO(WFA_OUT, "Prestart %d ...\n",myId);
       fflush(stdout);
       while(!my_wmm->thr_flag)
       {
          WaitForSingleObject( my_wmm->thr_flag_mutex, INFINITE );
          Sleep(20);
       }

       ReleaseMutex(my_wmm->thr_flag_mutex);  
       myStreamId = my_wmm->thr_flag;
       my_wmm->thr_flag = 0;
       DPRINT_INFO(WFA_OUT, "lock met %d ...\n",myId);
#endif

       /* use the flag as a stream id to file the profile */ 
       myStream = findStreamProfile(myStreamId); 
       myProfile = &myStream->profile;

       if(myProfile == NULL)
       {
          status = STATUS_INVALID;
          wfaEncodeTLV(WFA_TRAFFIC_AGENT_SEND_RESP_TLV, 4, (BYTE *)&status, respBuf);
          respLen = WFA_TLV_HDR_LEN+4;
          /*
           * send it back to control agent.
           */
           continue;
       }

       DPRINT_INFO(WFA_OUT, "start new ...\n");
       switch(myProfile->direction)
       {
           case DIRECT_SEND:
           DPRINT_INFO(WFA_OUT, "creating send socket with port %d ...\n",myProfile->sport);
           mySock = wfaCreateUDPSock(myProfile->sipaddr, myProfile->sport);
           if(mySock < 0)
           {
               DPRINT_ERR(WFA_ERR, "can't creat socket\n");
               break;
           }

           wfaConnectUDPPeer(mySock, myProfile->dipaddr, myProfile->dport);
           /*
            * Set packet/socket priority TOS field
            */
           DPRINT_INFOL(WFA_OUT, "To Set QoS %i\n", myProfile->trafficClass);
           wfaTGSetPrio_Win7( mySock, myProfile->trafficClass, myProfile);
           /*
            * set a proper priority 
            */
#ifdef resolve
           wfaSetThreadPrio(myId, myProfile->trafficClass);
#endif
           /* if delay is too long, it must be something wrong */
           if(myProfile->startdelay > 0 && myProfile->startdelay<100)
           {
#ifdef _WINDOWS
               Sleep(1000 * myProfile->startdelay);
#else
               sleep(myProfile->startdelay);
#endif
           }

           /*
            * set timer fire up
            */
#ifdef WFA_WMM_EXT
#ifndef _WINDOWS
           signal(SIGALRM, tmout_stop_send);
           alarm(myProfile->duration);
#else
           DPRINT_INFO(WFA_OUT, "\r\n Thread %d Setting timer for %d ms\n",myId,1000*myProfile->duration);
           timer_dur = 1000*myProfile->duration;
           CreateThread(NULL, 0, wfa_wmm_sleep_thread, (PVOID)&timer_dur, 0, &thr_id);
#endif

#endif

           if (getsockopt(mySock, SOL_SOCKET, SO_SNDBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
           {
               DPRINT_INFO(WFA_OUT, "SO_SNDBUF Value: %ld\n", iOptVal);
           }

           DPRINT_INFO(WFA_OUT, "SO_SNDBUF Value: %ld\n", iOptVal);
           //iOptVal = iOptVal*40;
//            iOptVal = 104857600;  // 100 MB
           iOptVal = 128 * 1024;     // 128 k
           setsockopt(mySock, SOL_SOCKET, SO_SNDBUF, (char*)&iOptVal, iOptLen);
           DPRINT_INFO(WFA_OUT, "SO_SNDBUF Value: %ld\n", iOptVal);
           if (getsockopt(mySock, SOL_SOCKET, SO_SNDBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
           {
               DPRINT_INFO(WFA_OUT, "SO_SNDBUF Value: %ld\n", iOptVal);
           }

           wfaSendLongFile(mySock, myStreamId, respBuf, &respLen);
           memset(respBuf, 0, WFA_BUFF_1K);
#ifdef _WINDOWS
           DPRINT_INFO(WFA_OUT, "\r\n Closing socket for thread %d",myId);
           // reset the buffer size
           //iOptVal = 8192;
           //setsockopt(mySock, SOL_SOCKET, SO_SNDBUF, (char*)&iOptVal, iOptLen);

           closesocket(mySock);
           Sleep(1000);
#else
           sleep(1);
#endif

           /*
            * uses thread 0 to pack the items and ships it to CA.
            */
           if(myId == mainSendThread) 
           {
              wfaSentStatsResp(gxcSockfd, respBuf);
              newCmdOn = 0;
              resendcnt = 0;
              while(newCmdOn == 0 && resendcnt < 1)
              {
                 Sleep(3000);
                 wfaSentStatsResp(gxcSockfd, respBuf);
                 resendcnt++;
              }
              Sleep(3000);

              // !!!!! a hack !!!!!!
              
              if(hasRecv == 0)
              {
                  printf("hasRecv == %i\n", hasRecv);
                  exit(0);
              }
              DPRINT_INFO(WFA_OUT, "finish resendsn %i", resendcnt);
           }

           SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
           break;

           case DIRECT_RECV:
#ifdef WFA_WMM_PS_EXT
           /*
            * Test WMM-PS
            */
           if(myProfile->profile == PROF_UAPSD)
           {
              wmmps_info.sta_test = B_D;
              wmmps_info.ps_thread = myId;
              wmmps_info.rcv_state = 0;
              wmmps_info.tdata = tdata;
              wmmps_info.dscp = wfaTGSetPrio(psSockfd, TG_WMM_AC_BE);
              tdata->state_num=0;
              /*
               * default timer value
               */

              while(gtgWmmPS>0)
              {
                 if(resetsnd)
                 {
                    tdata->state_num = 0;
                    resetsnd = 0;
                 }
                 tdata->state =  stationProcStatetbl[wmmps_info.sta_test];
                 curr_state = tdata->state[tdata->state_num];
                 curr_state.statefunc(curr_state.pw_offon,curr_state.sleep_period,&(tdata->state_num));
              }
           }
           
#endif /* WFA_WMM_PS_EXT */
           if(myProfile->profile == PROF_IPTV || myProfile->profile == PROF_FILE_TX || myProfile->profile == PROF_MCAST)
           {
              int nbytes = 0;
              char recvBuf[MAX_RCV_BUF_LEN+1]; /* 32*1024 + 1 = 32K */
              int iOptVal, iOptLen;

#ifdef WFA_WMM_EXT
              struct timeval currtime;
              FILE *e2eoutp = NULL;
              char e2eResults[124];
              int le2eCnt = 0;
              tgE2EStats_t *e2esp = NULL;
              int totalE2Cnt = 6000;
#endif

              mySock = wfaCreateUDPSock(myProfile->sipaddr, myProfile->sport);
              tgSockfds[myStream->tblidx] = mySock;
#ifdef WFA_WMM_EXT
    

              if(myProfile->profile == PROF_IPTV)
              {
                 e2esp = (tgE2EStats_t *)malloc(totalE2Cnt * sizeof(tgE2EStats_t));
                 if(e2esp == NULL)
                 {
                    DPRINT_INFOL(WFA_OUT, "Failed to malloc e2esp\n");
                 }
              }
              myStream->e2ebuf = e2esp;
#endif
              if (getsockopt(mySock, SOL_SOCKET, SO_RCVBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
              {
                 DPRINT_INFO(WFA_OUT, "Current SO_RCVBUF Value: %ld\n", iOptVal);
              }

//              iOptVal = iOptVal*40;
//              iOptVal = 104857600;  // 100 MB 10485760 
//              iOptVal = 209715200;    //200
              iOptVal = 128 * 1024; // 128 K
              setsockopt(mySock, SOL_SOCKET, SO_RCVBUF, (char*)&iOptVal, iOptLen);

              if (getsockopt(mySock, SOL_SOCKET, SO_RCVBUF, (char*)&iOptVal, &iOptLen) != SOCKET_ERROR) 
              {
                 DPRINT_INFO(WFA_OUT, "set SO_RCVBUF Value: %ld\n", iOptVal);
              }
              else
                 DPRINT_INFO(WFA_OUT, "Can't set RCV buffer size\n");

              for (;;)
              {
                  nbytes = wfaRecvFile(mySock, myStreamId, (char  *)recvBuf);
                  if(nbytes== -1)
                  {
                     DPRINT_INFO(WFA_OUT, "Error packet recving\n");
                     break;
                  }
              } /* for */

              my_wmm->thr_flag = 0;

              if(myProfile->profile == PROF_IPTV)
              {
                 int j;

                 gettimeofday(&currtime, NULL);
#ifndef _WINDOWS
                 sprintf(e2eResults, "/tmp/e2e%u.txt", (unsigned int) currtime.tv_sec); 
#else
                 sprintf(e2eResults, "c:\\windows\\temp\\e2e%u.txt", (unsigned int) currtime.tv_sec); 
#endif
                 DPRINT_INFOL(WFA_OUT, "storage file %s to have cnt %i records\n", e2eResults, myStream->stats.rxFrames);
                 e2eoutp = fopen(e2eResults, "w+");
                 if(e2eoutp != NULL)
                 {
                    fprintf(e2eoutp, "roundtrip delay: %i\n", (int) (1000000*gtgPktRTDelay));

                    for(j = 0; j<totalE2Cnt && j < (int) myStream->stats.rxFrames; j++)
                    {
                       tgE2EStats_t *ep = e2esp+j;
                       fprintf(e2eoutp, "%i:%i:%i:%i:%i\n", ep->seqnum, ep->lsec, ep->lusec, ep->rsec, ep->rusec);
                    }
                    fclose(e2eoutp);
                 }

                 if(e2esp!= NULL)
                    free(e2esp);
              }
          }
          else if (myProfile->profile == PROF_TRANSC)
          {
              mySock = wfaCreateUDPSock(myProfile->sipaddr, myProfile->sport);
              if(mySock < 0)
              {
                  my_wmm->thr_flag = 0;
                  continue;
              }

              tgSockfds[myStream->tblidx] = mySock;
              totalTranPkts = 0xFFFFFFF0;
              gtgTransac = myStreamId;

              while(gtgTransac != 0)
              {
                 BYTE recvBuf[MAX_RCV_BUF_LEN+1];
                 int nbytes = 0, respLen = 0;
                 memset(recvBuf,0, sizeof(recvBuf));
                 if(mySock != -1)
                 {
                     int i = gtgTransac;

                     nbytes = wfaRecvFile(mySock, i, (char *)recvBuf);
                     if(nbytes <= 0)
                        break;

                 }
                 else
                 {
                    break;
                 }
                     
                 if(wfaSendShortFile(mySock, gtgTransac, recvBuf, nbytes, respBuf, &respLen) == -1)
                 {
                    if(wfaCtrlSend(gxcSockfd, (BYTE *)respBuf, respLen) != respLen)
                    {
                        DPRINT_WARNING(WFA_WNG, "wfaCtrlSend Error\n");
                    }
                 }
              }
          }
           
          break;
          default:
          DPRINT_ERR(WFA_ERR, "Unknown covered case\n");
       }

    }
}

#endif
