 
/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *  LICENSE
 *
 *  License is granted only to Wi-Fi Alliance members and designated
 *  contractors ($B!H(BAuthorized Licensees$B!I(B)..AN  Authorized Licensees are granted
 *  the non-exclusive, worldwide, limited right to use, copy, import, export
 *  and distribute this software:
 *  (i) solely for noncommercial applications and solely for testing Wi-Fi
 *  equipment; and
 *  (ii) solely for the purpose of embedding the software into Authorized
 *  Licensee$B!G(Bs proprietary equipment and software products for distribution to
 *  its customers under a license with at least the same restrictions as
 *  contained in this License, including, without limitation, the disclaimer of
 *  warranty and limitation of liability, below..AN  The distribution rights
 *  granted in clause
 *  (ii), above, include distribution to third party companies who will
 *  redistribute the Authorized Licensee$B!G(Bs product to their customers with or
 *  without such third party$B!G(Bs private label. Other than expressly granted
 *  herein, this License is not transferable or sublicensable, and it does not
 *  extend to and may not be used with non-Wi-Fi applications..AN  Wi-Fi Alliance
 *  reserves all rights not expressly granted herein..AN 
 *.AN 
 *  Except as specifically set forth above, commercial derivative works of
 *  this software or applications that use the Wi-Fi scripts generated by this
 *  software are NOT AUTHORIZED without specific prior written permission from
 *  Wi-Fi Alliance.
 *.AN 
 *  Non-Commercial derivative works of this software for internal use are
 *  authorized and are limited by the same restrictions; provided, however,
 *  that the Authorized Licensee shall provide Wi-Fi Alliance with a copy of
 *  such derivative works under a perpetual, payment-free license to use,
 *  modify, and distribute such derivative works for purposes of testing Wi-Fi
 *  equipment.
 *.AN 
 *  Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 *  or promote products that are derived from or that use this software without
 *  specific prior written permission from Wi-Fi Alliance.
 *
 *  THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A.AN PARTICULAR PURPOSE,
 *  ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 *  (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 *  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ******************************************************************************
 */

/* 
 *   File: wfa_cs.c -- configuration and setup
 *   This file contains all implementation for the dut setup and control 
 *   functions, such as network interfaces, ip address and wireless specific
 *   setup with its supplicant.
 *
 *   The current implementation is to show how these functions
 *   should be defined in order to support the Agent Control/Test Manager 
 *   control commands. To simplify the current work and avoid any GPL licenses,
 *   the functions mostly invoke shell commands by calling linux system call,
 *   system("<commands>"). 
 *
 *   It depends on the differnt device and platform, vendors can choice their
 *   own ways to interact its systems, supplicants and process these commands
 *   such as using the native APIs.
 *
 *   Revision History:
 *        2008/03/12 --  02.41 Bug #16, incorrect file descriptor used. Change 
 *                       the "tmpfile" to "tmpfd" and a few places. Make a macro
 *                       WFA_STAUT_IF in file "inc/wfa_cs.h" for WLAN interface
 *                       name in the function "wfaDeviceListIF()
 *                      
 *                       Not A Bug. Put back to the function from 
 *                       wfaSetEncryption1() to wfaSetEncryption() for 
 *                       supporting WEP. Porting could select which should be 
 *                       used according to WEP support or not.
 *        2009/06/18 -- WPA2 Test plan v1.8 Automation functionalities added by Chandra
 *        2009/09/30 -- WINv03.00.00. Support TGn Release, including WPA2 and WMM [QH].
 *                        
 *        
 */ 
#include "stdafx.h"
#include <stdio.h>
//#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#ifdef _WINDOWS
#include <winsock2.h>
#else
#ifdef _CYGWIN
#include <cygwin/types.h>
#include <cygwin/socket.h>
#else
#include <linux/types.h>
#include <linux/socket.h>
#endif
#include <arpa/inet.h>
#include <sys/socket.h>
#include <poll.h>
#endif
#include "wfa_debug.h"
#include "wfa_ver.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_ca.h"
#include "wfa_tlv.h"
#include "wfa_sock.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"
#include "wfa_rsp.h"
#include "wfa_miscs.h"
#ifdef WFA_WMM_EXT
#ifdef WFA_WMM_PS_EXT
#include "wfa_wmmps.h"
extern int wfaTGSetPrio(int sockfd, int tgClass);
#endif
#endif

#define FW(x,y) FindWindowEx(x, NULL, y, L"")

#define CERTIFICATES_PATH    "/etc/wpa_supplicant"

char *sigmaPath = "C:\\WFA";
char *sigmaTempPath = "C:\\WFA\\Temp";

/* Some device may only support UDP ECHO, activate this line */
//#define WFA_PING_UDP_ECHO_ONLY 1

extern unsigned short wfa_defined_debug;
extern char       gnetIf[WFA_BUFF_64];        /* specify the interface to use */


extern int geSupplicant; /* supplicant type */
extern char gStaSSID[WFA_SSID_NAME_LEN]; // for Marvell supplicant
extern int tgWMMTestEnable;              // used at function SET_WMM to instruct this in a WMM test mode which will help RECV function performance. Will be removed after the function got enhanced.

/* Since the two definitions are used all over the CA function */
char gCmdStr[WFA_CMD_STR_SZ];
dutCmdResponse_t gGenericResp;
/* Global variable for Channel width to support Intel MCS rate command*/
WORD g11nChnlWidth;
#ifdef _WINDOWS
int vend;
extern char WFA_CLI_VERSION[];
extern char intfname[];
extern char intfNetName[];

char *aINTERFACE = &intfname[0];
char *aINTERFACE_NAME=&intfNetName[0];
#endif

#ifdef WFA_WMM_EXT
extern char e2eResults[];
//extern char *e2eResults;
FILE *e2efp = NULL;
#endif

char *capstr[] = {"Disable", "Enable"};

char WFA_CLI_CMD_DIR[64] = "C:\\WFA\\CLIs\\Intel";

int wfaExecuteCLI(char *CLI);
int CiscoEAPConfigGenerateLowerPart(FILE *file,char *encrType,char *secuType);
int CiscoEAPConfigGenerateUpperPart(FILE *file, char *ssid);
int CiscoConfigGenerateLowerPart(FILE *file);
int CiscoConfigGenerateUpperPart(FILE *file);

int wfaGetEnvVal(char * ,char * ,int);
int wfaClearEnvVal(char *);

/*
 * agtCmdProcGetVersion(): response "ca_get_version" command to controller
 *  input:  cmd --- not used
 *          valLen -- not used
 *  output: parms -- a buffer to store the version info response.
 */
int agtCmdProcGetVersion(int len, BYTE *parms, int *respLen, BYTE *respBuf)
{
    dutCmdResponse_t *getverResp = &gGenericResp;

    DPRINT_INFO(WFA_OUT, "entering agtCmdProcGetVersion ...\n");

    getverResp->status = STATUS_COMPLETE;
    strncpy(getverResp->cmdru.version, WFA_SYSTEM_VER, WFA_VERSION_LEN-1);

    wfaEncodeTLV(WFA_GET_VERSION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getverResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

    DPRINT_INFOL(WFA_OUT, "Completing ...\n");

    return WFA_SUCCESS;
}

/*
 * wfaStaAssociate():
 *    The function is to force the station wireless I/F to re/associate 
 *    with the AP.
 */
int wfaStaAssociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *assoc = (dutCommand_t *)caCmdBuf;
   char *ifname = assoc->intf;
   char *ssid = assoc->cmdsu.ssid;
   dutCmdResponse_t *staAssocResp = &gGenericResp;

   DPRINT_INFOL(WFA_OUT, "Entering  ...\n");

   if (geSupplicant == eWindowsZeroConfig)
   {   
	   sprintf(gCmdStr, "netsh wlan connect name=%s ssid=%s", ssid,ssid);
       DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
	   system(gCmdStr);
   }  
   /*
    * Then report back to control PC for completion.
    * This does not have failed/error status. The result only tells
    * a completion.
    */
   staAssocResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_ASSOCIATE_RESP_TLV, 4, (BYTE *)staAssocResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");
   return WFA_SUCCESS;
}

/*
 * wfaStaIsConnected():
 *    The function is to check whether the station's wireless I/F has 
 *    already connected to an AP.
 */
int wfaStaIsConnected(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *connStat = (dutCommand_t *)caCmdBuf;
   FILE *tmpfile = NULL;
   char result[32],filename[256], intfile[256];
   dutCmdResponse_t *staConnectResp = &gGenericResp;
   char *ifname = connStat->intf;
   char string[64],Interfacename[64];

   DPRINT_INFO(WFA_OUT, "Entering ...\n"); 

   sprintf(gCmdStr, "del /F /Q %s\\Temp\\iscon.txt", sigmaPath);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);

   system(gCmdStr);
   if(geSupplicant == eWindowsZeroConfig)
   {
      sprintf(filename, "%s\\Temp\\iscon.txt", sigmaPath);
      sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", sigmaPath);
      tmpfile = fopen(intfile, "r");
	  if(tmpfile == NULL)
      {
          DPRINT_ERR(WFA_ERR, "\n Error opening the interface file \n");
          staConnectResp->status = STATUS_ERROR;
          wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, 4, (BYTE *)staConnectResp, respBuf);
          *respLen = WFA_TLV_HDR_LEN + 4;

          return WFA_FAILURE;
      }
	  else
      {
          for(;;)
		  {
		      if(fgets(string, 256, tmpfile) == NULL)
		         break; 
		  }
		  fclose(tmpfile);

		  if(strncmp(string, "IFNAME", 6) == 0)
		  {
		      char *str;
		      str = strtok(string, "\"");
		      str = strtok(NULL, "\"");
		      if(str != NULL)
		      {
		          strcpy(&Interfacename[0],str);
		      }
	      }
	  }
	  sprintf(gCmdStr, "del /F /Q %s\\Temp\\temp.txt",sigmaPath);
      DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
      system(gCmdStr);

	  sprintf(gCmdStr, "netsh wlan show  interface name=\"%s\" > %s\\Temp\\temp.txt",&Interfacename[0], sigmaPath);
      DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
	  system(gCmdStr);

	  sprintf(gCmdStr, "FOR /F \"tokens=2 delims=: \" %s IN ('findstr State %s\\Temp\\temp.txt') DO @echo %s > %s\\Temp\\iscon.txt","%i",sigmaPath, "%i", sigmaPath);
      DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);      
	  system(gCmdStr);
   }
   
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n",gCmdStr);
   system(gCmdStr);
   /*
    * the status is saved in a file.  Open the file and check it.
    */

   tmpfile = fopen(filename, "r+");
   if(tmpfile == NULL)
   {
      staConnectResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, 4, (BYTE *)staConnectResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");

      return WFA_FAILURE;
   }

   if(geSupplicant == eWindowsZeroConfig)
   {
	      fscanf(tmpfile, "%s", result); 
	      if(strncmp(result, "connected", 9) == 0)
		        staConnectResp->cmdru.connected = 1;
	      else
		        staConnectResp->cmdru.connected = 0;
   } 

   /*
    * Report back the status: Complete or Failed.
    */
   staConnectResp->status = STATUS_COMPLETE;   
   wfaEncodeTLV(WFA_STA_IS_CONNECTED_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)staConnectResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   if(tmpfile)
   	  fclose(tmpfile);

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

/*
 * wfaStaGetIpConfig():
 * This function is to retriev the ip info including
 *     1. dhcp enable
 *     2. ip address
 *     3. mask 
 *     4. primary-dns
 *     5. secondary-dns
 *
 *     The current implementation is to use a script to find these information
 *     and store them in a file. 
 */
int wfaStaGetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    int i = 0;
    dutCmdResponse_t *ipconfigResp = &gGenericResp; 
    caStaGetIpConfigResp_t *ifinfo = &ipconfigResp->cmdru.getIfconfig;

    dutCommand_t *getIpConf = (dutCommand_t *)caCmdBuf;
    char *ifname = getIpConf->intf;
    FILE *tmpfd;
    char string[256],Interfacename[64], intfile[256], confile[256];
    char *str;

    DPRINT_INFOL(WFA_OUT, "Entering ...\n");

    strcpy(ifinfo->dns[0], "0");
    strcpy(ifinfo->dns[1], "0");

    sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", sigmaPath);
    tmpfd = fopen(intfile, "r");
    if(tmpfd == NULL)
    {
       ipconfigResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       DPRINT_ERR(WFA_ERR, "%s open failed\n", intfile);
       return WFA_FAILURE;
    }
	else
	{
	   for(;;)
	   {
	       if(fgets(string, 256, tmpfd) == NULL)
	          break; 
	   }
	   fclose(tmpfd);

	   if(strncmp(string, "IFNAME", 6) == 0)
	   {
	      char *str;
          str = strtok(string, "\"");
          str = strtok(NULL, "\"");
          if(str != NULL)
          {
             strcpy(&Interfacename[0],str);
          }
       }
    }
    sprintf(gCmdStr, "netsh interface ip show addresses name=\"%s\"  > %s\\Temp\\getcon.txt",&Interfacename[0], sigmaPath);
    DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
    system(gCmdStr);

    sprintf(confile, "%s\\Temp\\getcon.txt", sigmaPath);
    tmpfd = fopen(confile, "r+");

    if(tmpfd == NULL)
    {
        ipconfigResp->status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, 4, (BYTE *)ipconfigResp, respBuf);
        *respLen = WFA_TLV_HDR_LEN + 4;

        DPRINT_ERR(WFA_ERR, "File open failed\n");
        return WFA_FAILURE;
    }

   for(;;)
   {
      if(fgets(string, 256, tmpfd) == NULL)
         break; 

      str = strtok(string, " ");

      /* check dhcp enabled */
      if(strncmp(str, "DHCP", 4) ==0)
      {
          str = strtok(NULL, " ");
          str = strtok(NULL, " ");
          if(strncmp(str, "Yes", 3) ==0)
              ifinfo->isDhcp = 1;
          else
              ifinfo->isDhcp = 0;
      }

      /* find out the ip address */
      if(strncmp(str, "IP", 2) ==0)
      {
         str = strtok(NULL, " ");
         str = strtok(NULL, " ");
         memset(ifinfo->ipaddr,'\0',16);
         if(str != NULL)
         {
			 DPRINT_INFO(WFA_OUT, "\nThe IP length %dEnd\n",strlen(str));
			 DPRINT_INFO(WFA_OUT, "\nThe IP  %sEnd\n",str);

             strncpy(ifinfo->ipaddr, str, 15);
             ifinfo->ipaddr[strlen(str)-1]='\0';
         }
         else
             strncpy(ifinfo->ipaddr, "none", 15);
      }

      /* check the mask */
      if(strncmp(str, "Subnet", 6) ==0)
      {
         str = strtok(NULL, " ");
         str = strtok(NULL, " ");
         if(str != NULL)
         {
           strcpy(ifinfo->mask, str);
         }
         else
           strcpy(ifinfo->mask, "none");
      }
   }

	  fclose(tmpfd);

   /*
    * Report back the results
    */
   ipconfigResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_IP_CONFIG_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)ipconfigResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   DPRINT_INFOL(WFA_OUT, "%i %i %s %s %s %s %i\n", ipconfigResp->status, 
      ifinfo->isDhcp, ifinfo->ipaddr, ifinfo->mask, 
      ifinfo->dns[0], ifinfo->dns[1], *respLen);

   fclose(tmpfd);

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

/*
 * wfaStaSetIpConfig():
 *   The function is to set the ip configuration to a wireless I/F.
 *   1. IP address
 *   2. Mac address
 *   3. default gateway
 *   4. dns nameserver (pri and sec).  
 */
int wfaStaSetIpConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *setIpConf = (dutCommand_t *)caCmdBuf;
   caStaSetIpConfig_t *ipconfig = &setIpConf->cmdsu.ipconfig;
   dutCmdResponse_t *staSetIpResp = &gGenericResp;
   
   char string[256],Interfacename[64], intfile[256];
   FILE *tmpfd;

   DPRINT_INFO(WFA_OUT, "Entering ..\n");

   Sleep(2000);
   sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", sigmaPath);
   tmpfd = fopen(intfile, "r");
   if(tmpfd == NULL)
   {
       DPRINT_ERR(WFA_ERR, "\n Error opening the interface file \n");
       staSetIpResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);   
       *respLen = WFA_TLV_HDR_LEN + 4;

       return WFA_FAILURE;
   }
  	else
  	{
	     for(;;)
	     {
	        if(fgets(string, 256, tmpfd) == NULL)
	           break; 
         }
		 fclose(tmpfd);

		 if(strncmp(string, "IFNAME", 6) == 0)
		 {
		     char *str;
		     str = strtok(string, "\"");
		     str = strtok(NULL, "\"");
		     if(str != NULL)
		     {
		         strcpy(&Interfacename[0],str);
		     }
		 }
 	 }
	
	 if(ipconfig->isDhcp == 1)
	 {
	    sprintf(gCmdStr, "netsh interface ip set address name=\"%s\" source=dhcp", &Interfacename[0]);
        DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
        system(gCmdStr);
	 }
	 else
 	 {
	    sprintf(gCmdStr, "netsh interface ip set address name=\"%s\" static %s %s ", &Interfacename[0],ipconfig->ipaddr,ipconfig->mask);
        DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
	    system(gCmdStr);
	    if(ipconfig->pri_dns[0])
	    {
	       sprintf(gCmdStr, "netsh interface ip set dns name=\"%s\" static addr=%s", &Interfacename[0],ipconfig->pri_dns);
           DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
	       system(gCmdStr);
	       if(ipconfig->sec_dns)
	       {
		        sprintf(gCmdStr, "netsh interface ip add dns name=\"%s\" addr=%s", &Interfacename[0],ipconfig->sec_dns);
                DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
	     		system(gCmdStr);
		   }
	    }
	 }

   /*
    * report status
    */
   staSetIpResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_IP_CONFIG_RESP_TLV, 4, (BYTE *)staSetIpResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

/*
 * wfaStaVerifyIpConnection():
 * The function is to verify if the station has IP connection with an AP by
 * send ICMP/pings to the AP.
 */ 
int wfaStaVerifyIpConnection(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *verip = (dutCommand_t *)caCmdBuf;
   dutCmdResponse_t *verifyIpResp = &gGenericResp;

#ifndef WFA_PING_UDP_ECHO_ONLY
   char strout[64], *pcnt;
   FILE *tmpfile;
   
   DPRINT_INFO(WFA_OUT, "Entering ...\n");

   /* set timeout value in case not set */
   if(verip->cmdsu.verifyIp.timeout <= 0)
   {
        verip->cmdsu.verifyIp.timeout = 10;
   }
   
   /* execute the ping command  and pipe the result to a tmp file */
   sprintf(gCmdStr, "ping %s -c 3 -W %u | grep loss | cut -f3 -d, 1>& /tmp/pingout.txt", verip->cmdsu.verifyIp.dipaddr, verip->cmdsu.verifyIp.timeout);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr); 

   /* scan/check the output */
   tmpfile = fopen("/tmp/pingout.txt", "r+");
   if(tmpfile == NULL)
   {
      verifyIpResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "File open failed\n");
      return WFA_FAILURE;
   }
   
   verifyIpResp->status = STATUS_COMPLETE;
   if(fscanf(tmpfile, "%s", strout) == EOF)
       verifyIpResp->cmdru.connected = 0;
   else
   {
       pcnt = strtok(strout, "%"); 
       
       /* if the loss rate is 100%, not able to connect */
       if(atoi(pcnt) == 100)
          verifyIpResp->cmdru.connected = 0;
       else
          verifyIpResp->cmdru.connected = 1;
   }

   fclose(tmpfile);
#else
   int btSockfd;
   struct pollfd fds[2];
   int timeout = 2000;
   char anyBuf[64];
   struct sockaddr_in toAddr;
   int done = 1, cnt = 0, ret, nbytes;

   verifyIpResp->status = STATUS_COMPLETE;
   verifyIpResp->cmdru.connected = 0;

   btSockfd = wfaCreateUDPSock("127.0.0.1", WFA_UDP_ECHO_PORT);

   if(btSockfd == -1)
   {
      verifyIpResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, 4, (BYTE *)verifyIpResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;
      return FALSE;;
   }

   toAddr.sin_family = AF_INET;
   toAddr.sin_addr.s_addr = inet_addr(verip->cmdsu.verifyIp.dipaddr);
   toAddr.sin_port = htons(WFA_UDP_ECHO_PORT);

   while(done)
   {
       wfaTrafficSendTo(btSockfd, (char *)anyBuf, 64, (struct sockaddr *)&toAddr);
       cnt++;

       fds[0].fd = btSockfd;
       fds[0].events = POLLIN | POLLOUT; 

       ret = poll(fds, 1, timeout);
       switch(ret)
       {
           case 0:
             /* it is time out, count a packet lost*/
           break;
           case -1:
             /* it is an error */
           default:
           {
              switch(fds[0].revents)
              {
                  case POLLIN:
                  case POLLPRI:
                  case POLLOUT:
                  nbytes = wfaTrafficRecv(btSockfd, (char *)anyBuf, (struct sockaddr *)&toAddr);
                  if(nbytes != 0)
                      verifyIpResp->cmdru.connected = 1;
                      done = 0;
                  break;
                  default:
                  /* errors but not care */
                   ;
              } 
           }
       } 
       if(cnt == 3)
       {
          done = 0;
       }
   }
       
#endif

   wfaEncodeTLV(WFA_STA_VERIFY_IP_CONNECTION_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)verifyIpResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   
   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

/*
 * wfaStaGetMacAddress()
 *    This function is to retrieve the MAC address of a wireless I/F.
 */
int wfaStaGetMacAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    dutCommand_t *getMac = (dutCommand_t *)caCmdBuf;
    dutCmdResponse_t *getmacResp = &gGenericResp;
    char *str;
    char *ifname = getMac->intf;
    FILE *tmpfd;
    char string[128],Interfacename[128], intfile[128];
    char filename[50];

    DPRINT_INFO(WFA_OUT, "Entering ...\n");

    sprintf(filename,"%s\\Temp\\ipconfig.txt", sigmaPath);
    sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", sigmaPath);
    DPRINT_INFOL(WFA_OUT, "filename %s intfile %s\n", filename, intfile);

    tmpfd = fopen(intfile, "r");
    if(tmpfile == NULL)
    {
        DPRINT_ERR(WFA_ERR, "\n Error opening the interface file \n");
        getmacResp->status = STATUS_ERROR;
        wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)getmacResp, respBuf);   
        *respLen = WFA_TLV_HDR_LEN + 4;

        return WFA_FAILURE;
    }
	else
    {
        for(;;)
        {
           if(fgets(string, 256, tmpfd) == NULL)
              break; 
        }
        fclose(tmpfd);

        if(strncmp(string, "IFNAME", 6) == 0)
        {
           char *str;
           str = strtok(string, "\"");
           str = strtok(NULL, "\"");
           if(str != NULL)
           {
               strcpy(&Interfacename[0],str);
            }
        }
    }
    sprintf(gCmdStr, "del /F /Q %s\\Temp\\temp.txt", sigmaPath);
    DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);

    sprintf(gCmdStr, "netsh wlan show  interface state name=\"%s\" > %s\\Temp\\temp.txt",&Interfacename[0], sigmaPath);
    DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
    system(gCmdStr);

	sprintf(gCmdStr, "FOR /F \"tokens=3,4,5,6,7,8 delims=: \" %s IN ('findstr Physical %s\\Temp\\temp.txt') DO @echo %s:%s:%s:%s:%s:%s > %s\\Temp\\ipconfig.txt","%i",sigmaPath, "%i","%j","%k","%l","%m","%n", sigmaPath);
    DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
	system(gCmdStr);

	Sleep(1000);

    tmpfd = fopen(filename, "r+");
    if(tmpfd == NULL)
    {
      getmacResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, 4, (BYTE *)getmacResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "file open failed\n");
      return WFA_FAILURE;
   }

   if(fgets(string, 256, tmpfd) == NULL)
   {
      getmacResp->status = STATUS_ERROR;
   }
   str = strtok(string, " ");

#ifdef _WINDOWS
   if(str)
   {
      //printf("\nThe MAC address is : %s",str);
      strcpy(getmacResp->cmdru.mac, str);
      getmacResp->status = STATUS_COMPLETE;
   }
   else
   {
      getmacResp->status = STATUS_ERROR;
   }
#else
   while(str && ((strcmp(str,"HWaddr")) != 0))
   {
      str = strtok(NULL, " ");
   }
         
   /* get mac */
   if(str)
   {
      str = strtok(NULL, " ");
      strcpy(getmacResp->cmdru.mac, str);
      getmacResp->status = STATUS_COMPLETE;
   }
 
#endif
 
   wfaEncodeTLV(WFA_STA_GET_MAC_ADDRESS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)getmacResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   fclose(tmpfd);

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

/*
 * wfaStaGetStats():
 * The function is to retrieve the statistics of the I/F's layer 2 txFrames, 
 * rxFrames, txMulticast, rxMulticast, fcsErrors/crc, and txRetries.
 * Currently there is not definition how to use these info. 
 */
int wfaStaGetStats(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *statsResp = &gGenericResp;

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");

#if 0  /* this is never used, you can skip this call */
   int s;
   struct ath_stats total;
   const char *ifname = ((dutCommand_t *)caCmdBuf)->intf;
   struct iwreq iwr;
   struct ifreq ifr;
   struct ieee80211req_sta_stats stats;
   const struct ieee80211_nodestats *ns = &stats.is_stats;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaGetStats ...\n");

   /*
    * open a DGRAM socket.
    */
   s = socket(AF_INET, SOCK_DGRAM, 0);
   if (s < 0)
   {
       DPRINT_ERR(WFA_ERR, "socket open");
       statsResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, 4, (BYTE *)statsResp, respBuf);   
       *respLen = WFA_TLV_HDR_LEN + 4;

       return FALSE;
   }

   /*
    * retrieve a HW address by the interface name
    */
   strncpy(ifr.ifr_name, "wifi0", sizeof (ifr.ifr_name));
   if(ioctl(s, SIOCGIFHWADDR, &ifr) < 0)
   {
       DPRINT_ERR(WFA_ERR, "interface not found\n");
       statsResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, 4, (BYTE *)statsResp, respBuf);   
       *respLen = WFA_TLV_HDR_LEN + 4;

       return FALSE;
   }
       
   /* retrive 802.11 hardware stats */ 
   (void) memset(&iwr, 0, sizeof(iwr));
   strncpy(iwr.ifr_name, ifname, sizeof (iwr.ifr_name));
   iwr.u.data.pointer = (void *) &stats;
   iwr.u.data.length = sizeof(stats);
   memcpy(stats.is_u.macaddr, ifr.ifr_hwaddr.sa_data, 8);

   if (ioctl(s, IEEE80211_IOCTL_STA_INFO, &iwr) < 0)
   {
       DPRINT_ERR(WFA_ERR, "unable to get station information");
       statsResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, 4, (BYTE *)statsResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       return FALSE;
   }

   /* retrieve atheros hw stats */
   ifr.ifr_data = (caddr_t) &total;
   if (ioctl(s, SIOCGATHSTATS, &ifr) < 0)
   {
       DPRINT_ERR(WFA_ERR, "error: %s\n", ifr.ifr_name);
       statsResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, 4, (BYTE *)statsResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       return FALSE;
   }

   statsResp->cmdru.ifStats.txFrames =  ns->ns_tx_ucast;
   statsResp->cmdru.ifStats.rxFrames = ns->ns_rx_ucast;
   statsResp->cmdru.ifStats.txMulticast = ns->ns_tx_mcast;
   statsResp->cmdru.ifStats.rxMulticast = ns->ns_rx_mcast;
   statsResp->cmdru.ifStats.txRetries = total.ast_tx_xretries;
   statsResp->cmdru.ifStats.fcsErrors = total.ast_rx_crcerr; 

#endif

   statsResp->status = STATUS_ERROR;
   wfaEncodeTLV(WFA_STA_GET_STATS_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)statsResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");
   return WFA_SUCCESS;
}

/*
 * wfaSetEncryption():
 *   The function is to set the wireless interface with WEP or none.
 *
 *   Since WEP is optional test, current function is only used for 
 *   resetting the Security to NONE/Plaintext (OPEN). To test WEP, 
 *   this function should be replaced by the next one (wfaSetEncryption1())
 *
 *   Input parameters: 
 *     1. I/F
 *     2. ssid
 *     3. encpType - wep or none
 *     Optional:
 *     4. key1
 *     5. key2
 *     6. key3
 *     7. key4
 *     8. activeKey Index
 *
 *   Not used for WIN7
 */

int wfaSetEncryption1(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   FILE *file;
#if !defined(_CYGWIN) && !defined(_WINDOWS)  
   
   /*
    * disable the network first
    */
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set SSID
    */    
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setEncryp->intf, setEncryp->ssid);
   system(gCmdStr);

   /*
    * Tell the supplicant for infrastructure mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 0", setEncryp->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setEncryp->intf);
   system(gCmdStr);

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setEncryp->intf);
   system(gCmdStr);
#else
   sprintf(gCmdStr, "wifi_config -limit %s -enable", gnetIf);
   system(gCmdStr);
#ifdef _CYGWIN
file = fopen("/tmp/tmp.xml", "w+");
#else
file = fopen("c:\\windows\\Temp\\tmp.xml", "w+");
#endif
  /* we create a file for reading and writing */

  if(file==NULL) 
  {
    printf("Error: can't create file.\n");
    return 1;
  }
  else 
  {
    sprintf(gCmdStr,"<?xml version=\"1.0\"?>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<name>%s</name>\n",setEncryp->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<name>%s</name>\n",setEncryp->ssid);
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</SSID>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</SSIDConfig>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionType>ESS</connectionType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t<MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t<security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<authEncryption>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<authentication>open</authentication>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t<encryption>none</encryption>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t <useOneX>false</useOneX>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t</authEncryption>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t</security>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t</MSM>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"</WLANProfile>\n");
    fputs(gCmdStr, file);
    /*sprintf(gCmdStr,"\t\t\t<sharedKey>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t<keyType>networkKey</keyType>\n");
    fputs(gCmdStr, file);
    sprintf(gCmdStr,"\t\t\t\t<protected>false</protected>\n");
    fputs(gCmdStr, file);*/
  }
  fclose(file);
#ifdef _CYGWIN
   sprintf(gCmdStr, "wifi_config -limit %s -add %s", setEncryp->intf,"c:\\\\cygwin\\\\tmp\\\\tmp.xml");
#else
   sprintf(gCmdStr, "wifi_config -limit %s -add %s", gnetIf,"c:\\\\windows\\\\temp\\\\tmp.xml");
#endif
   printf("Executing %s\n",gCmdStr);
   system(gCmdStr);
#endif
   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 *  Since WEP is optional, this function could be used to replace
 *  wfaSetEncryption() if necessary. 
 */
int wfaSetEncryptionZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;
   
   FILE *file,*tmpfd;
   char string[256],Interfacename[64], pfile[128], intfile[128];

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");
 
 
   sprintf(pfile, "%s\\Temp\\tmp.xml", sigmaPath);
   sprintf(gCmdStr, "del /F /Q %s", pfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);

   file = fopen(pfile, "w+");
   if(file==NULL) 
   {
       DPRINT_ERR(WFA_ERR, "Error: can't create file.\n");
       setEncrypResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       return WFA_FAILURE;
   }
   else 
   {
       sprintf(gCmdStr,"<?xml version=\"1.0\"?>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<name>%s</name>\n",setEncryp->ssid);
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<SSIDConfig>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t<SSID>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t<name>%s</name>\n",setEncryp->ssid);
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t</SSID>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t</SSIDConfig>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<connectionType>ESS</connectionType>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<MSM>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t<security>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t<authEncryption>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t<authentication>open</authentication>\n");
       fputs(gCmdStr, file);

       if(setEncryp->encpType == 1)
          sprintf(gCmdStr,"\t\t\t<encryption>WEP</encryption>\n");
       else
          sprintf(gCmdStr,"\t\t\t<encryption>none</encryption>\n");
    
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t <useOneX>false</useOneX>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t</authEncryption>\n");
       fputs(gCmdStr, file);

       if(setEncryp->encpType == 1)
       {
          sprintf(gCmdStr,"\t\t\t\t<sharedKey>\n");
          fputs(gCmdStr, file);
          sprintf(gCmdStr,"\t\t\t\t\t<keyType>networkKey</keyType>\n");
          fputs(gCmdStr, file);
          sprintf(gCmdStr,"\t\t\t\t\t<protected>false</protected>\n");
          fputs(gCmdStr, file);
          sprintf(gCmdStr,"\t\t\t\t\t<keyMaterial>%s</keyMaterial>\n",setEncryp->keys[0]);
          fputs(gCmdStr, file);
          sprintf(gCmdStr,"\t\t\t\t</sharedKey>\n");
          fputs(gCmdStr, file);
       }

       sprintf(gCmdStr,"\t\t</security>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t</MSM>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"</WLANProfile>\n");
       fputs(gCmdStr, file);
   }
   fclose(file);

   sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", sigmaPath);
   tmpfd = fopen(intfile, "r");
   if(tmpfd == NULL)
   {
	     	DPRINT_ERR(WFA_ERR, "Error opening the interface file \n");
       setEncrypResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;
 
       return WFA_FAILURE;
   }
   else
   {
      for(;;)
	  {
	     if(fgets(string, 256, tmpfd) == NULL)
	        break; 
	  }
	  fclose(tmpfd);

	  if(strncmp(string, "IFNAME", 6) == 0)
	  {
	     char *str;
	     str = strtok(string, "\"");
	     str = strtok(NULL, "\"");
	     if(str != NULL)
	     {
	         strcpy(&Interfacename[0],str);
	     }
	  }
   }

   sprintf(gCmdStr, "netsh wlan add profile filename=\"%s\" interface=\"%s\" user=all", pfile,&Interfacename[0]);

   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);

   setEncrypResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");
   return WFA_SUCCESS;
}


int wfaSetEncryption(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEncryption_t *setEncryp = (caStaSetEncryption_t *)caCmdBuf;
   dutCmdResponse_t *setEncrypResp = &gGenericResp;

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");

   switch(geSupplicant)
   {
	     case eWindowsZeroConfig:
		    wfaSetEncryptionZeroConfig(len,caCmdBuf,respLen,respBuf);			
		    break;

	     default:
		    setEncrypResp->status = STATUS_INVALID;
		    wfaEncodeTLV(WFA_STA_SET_ENCRYPTION_RESP_TLV, 4, (BYTE *)setEncrypResp, respBuf);   
		    *respLen = WFA_TLV_HDR_LEN + 4;
		    break;
   }

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}


/*
 * wfaStaSetEapTLSZeroConfig(): For ZeroConfig
 *   This is to set
 *   1. ssid
 *   2. encrypType - tkip or aes-ccmp
 *   3. keyManagementType - wpa or wpa2
 *   4. trustedRootCA
 *   5. clientCertificate
 *  The path for the certificate thumbprint file is c:\WFA\Sigma\Certificates\<username>.txt
 */
int wfaStaSetEapTLSZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
   char *ifname = setTLS->intf;
   dutCmdResponse_t *setEapTlsResp = &gGenericResp;

   FILE *file,*tmpfd;
   char string[256],Interfacename[64], pfile[128], intfile[128];

   DPRINT_INFO(WFA_OUT, "Entering ...\n");

   sprintf(pfile, "%s\\Temp\\tmp.xml", sigmaPath);
   sprintf(gCmdStr, "del /F /Q %s", pfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);

   file = fopen(pfile, "w+");
   if(file==NULL) 
   {
       DPRINT_ERR(WFA_ERR, "Can't create file.\n");
       setEapTlsResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       return WFA_FAILURE;
   }
   else 
   {
       sprintf(gCmdStr,"<?xml version=\"1.0\"?>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<name>%s</name>\n",setTLS->ssid);
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<SSIDConfig>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t<SSID>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t<name>%s</name>\n",setTLS->ssid);
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t</SSID>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t<nonBroadcast>false</nonBroadcast>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t</SSIDConfig>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<connectionType>ESS</connectionType>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t<MSM>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t<security>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t<authEncryption>\n");
       fputs(gCmdStr, file);

	   if((strcmp(setTLS->keyMgmtType, "WPA2") == 0) || (strcmp(setTLS->keyMgmtType, "wpa2") == 0))
       {
          sprintf(gCmdStr,"\t\t\t\t<authentication>WPA2</authentication>\n");
          fputs(gCmdStr, file);
          sprintf(gCmdStr,"\t\t\t\t<encryption>AES</encryption>\n");
          fputs(gCmdStr, file);
	   }
       else if((strcmp(setTLS->keyMgmtType, "WPA") == 0) || (strcmp(setTLS->keyMgmtType, "wpa") == 0))
       {
          sprintf(gCmdStr,"\t\t\t\t<authentication>WPA</authentication>\n");
          fputs(gCmdStr, file);
          sprintf(gCmdStr,"\t\t\t\t<encryption>TKIP</encryption>\n");
          fputs(gCmdStr, file);
       }

       sprintf(gCmdStr,"\t\t\t\t<useOneX>true</useOneX>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t</authEncryption>\n");
       fputs(gCmdStr, file);

       sprintf(gCmdStr,"\t\t\t<OneX xmlns=\"http://www.microsoft.com/networking/OneX/v1\">\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t\t<EAPConfig>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t\t\t<EapHostConfig xmlns=\"http://www.microsoft.com/provisioning/EapHostConfig\">\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t\t\t\t<EapMethod>\n");
       fputs(gCmdStr, file);

       sprintf(gCmdStr,"\t\t\t\t\t\t\t<Type xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">13</Type>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t\t\t\t\t<VendorId xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</VendorId>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t\t\t\t\t<VendorType xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</VendorType>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t\t\t\t\t<AuthorId xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</AuthorId>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t\t\t\t</EapMethod>\n");
       fputs(gCmdStr, file);

       sprintf(gCmdStr,"\t\t\t\t\t\t<ConfigBlob>020000002A00000007000000000000000000000000000000000000000000000000000000000000000000</ConfigBlob>\n");
	   fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t\t\t</EapHostConfig>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t\t</EAPConfig>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t\t</OneX>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t\t</security>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"\t</MSM>\n");
       fputs(gCmdStr, file);
       sprintf(gCmdStr,"</WLANProfile>\n");
       fputs(gCmdStr, file);
    }
    fclose(file);

    sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", sigmaPath);
    tmpfd = fopen(intfile, "r");
    if(tmpfd == NULL)
    {
       DPRINT_ERR(WFA_ERR, "Error opening the interface file \n");
       setEapTlsResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;

       return WFA_FAILURE;
    }
  	else
    {
	   for(;;)
	   {
	       if(fgets(string, 256, tmpfd) == NULL)
	          break; 
	   }
	   fclose(tmpfd);

	   if(strncmp(string, "IFNAME", 6) == 0)
	   {
	       char *str;
	       str = strtok(string, "\"");
	       str = strtok(NULL, "\"");
	       if(str != NULL)
	       {
	           strcpy(&Interfacename[0],str);
	       }
	   }
  	}

    sprintf(gCmdStr, "netsh wlan add profile filename=\"%s\" interface=\"%s\" user=all",pfile, &Interfacename[0]);

    DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
    system(gCmdStr);


    setEapTlsResp->status = STATUS_COMPLETE;
    wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    DPRINT_INFOL(WFA_OUT, "Completing ...\n");

    return WFA_SUCCESS;
}

/*
 * wfaStaSetEapTLS():
 *   This is to set
 *   1. ssid
 *   2. encrypType - tkip or aes-ccmp
 *   3. keyManagementType - wpa or wpa2
 *   4. trustedRootCA
 *   5. clientCertificate
 */
int wfaStaSetEapTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTLS_t *setTLS = (caStaSetEapTLS_t *)caCmdBuf;
   char *ifname = setTLS->intf;
   dutCmdResponse_t *setEapTlsResp = &gGenericResp;

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");

   switch(geSupplicant)
   {
	     case eWindowsZeroConfig:
		    wfaStaSetEapTLSZeroConfig(len,caCmdBuf,respLen,respBuf);			
		    break;
	   
	     default:
		    setEapTlsResp->status = STATUS_INVALID;
		    wfaEncodeTLV(WFA_STA_SET_EAPTLS_RESP_TLV, 4, (BYTE *)setEapTlsResp, respBuf);   
		    *respLen = WFA_TLV_HDR_LEN + 4;
		    break;
   }

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

/*
 * The function is to set 
 *   1. ssid
 *   2. passPhrase
 *   3. keyMangementType - wpa/wpa2
 *   4. encrypType - tkip or aes-ccmp
 * Using Windows WpaSupplicant supplicant  
 * 
 */


/*
 * The function is to set 
 *   1. ssid
 *   2. passPhrase
 *   3. keyMangementType - wpa/wpa2
 *   4. encrypType - tkip or aes-ccmp
 */
int wfaStaSetPSKZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
   dutCmdResponse_t *setPskResp = &gGenericResp;

   FILE *file,*tmpfd;
   char string[256],Interfacename[64], pfile[128], intfile[128];

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");

   sprintf(pfile, "%s\\Temp\\tmp.xlm", sigmaPath);
   sprintf(gCmdStr, "del /F /Q %s", pfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);


   file = fopen(pfile, "w+");

   /* we create a file for reading and writing */

   if(file==NULL) 
   {
      DPRINT_ERR(WFA_ERR, "Can't create file.\n");
      setPskResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;
      
      return WFA_FAILURE;
   }
   else 
   {
      sprintf(gCmdStr,"<?xml version=\"1.0\"?>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<name>%s</name>\n",setPSK->ssid);
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<SSIDConfig>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t<SSID>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t<name>%s</name>\n",setPSK->ssid);
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t</SSID>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t</SSIDConfig>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<connectionType>ESS</connectionType>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<MSM>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t<security>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t<authEncryption>\n");
      fputs(gCmdStr, file);
      if(setPSK->encpType == ENCRYPT_TKIP)
      {
    	    sprintf(gCmdStr,"\t\t\t<authentication>WPAPSK</authentication>\n");
    	    fputs(gCmdStr, file);
    	    sprintf(gCmdStr,"\t\t\t<encryption>TKIP</encryption>\n");
    	    fputs(gCmdStr, file);
      }
      else if(setPSK->encpType == ENCRYPT_AESCCMP)
      {
    	    sprintf(gCmdStr,"\t\t\t<authentication>WPA2PSK</authentication>\n");
    	    fputs(gCmdStr, file);
    	    sprintf(gCmdStr,"\t\t\t<encryption>AES</encryption>\n");
    	    fputs(gCmdStr, file);
      }
      sprintf(gCmdStr,"\t\t\t <useOneX>false</useOneX>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t</authEncryption>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t<sharedKey>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t<keyType>passPhrase</keyType>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t<protected>false</protected>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t<keyMaterial>%s</keyMaterial>\n",setPSK->passphrase);
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t</sharedKey>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t</security>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t</MSM>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"</WLANProfile>\n");
      fputs(gCmdStr, file);
   }
   fclose(file);


   sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", sigmaPath);
   tmpfd = fopen(intfile, "r");
   if(tmpfd == NULL)
   {
		     DPRINT_ERR(WFA_ERR, "Error opening the interface file \n");
       setPskResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
       *respLen = WFA_TLV_HDR_LEN + 4;

       return WFA_FAILURE;
   }
   else
   {
      for(;;)
      {
         if(fgets(string, 256, tmpfd) == NULL)
            break; 
      }
      fclose(tmpfd);

	  if(strncmp(string, "IFNAME", 6) == 0)
	  {
         char *str;
		 str = strtok(string, "\"");
		 str = strtok(NULL, "\"");
		 if(str != NULL)
		 {
		    strcpy(&Interfacename[0],str);
		 }
      }
   }

   sprintf(gCmdStr, "netsh wlan add profile filename=\"%s\" interface=\"%s\" user=all",pfile,&Interfacename[0]);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);

   setPskResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS; 
}

int wfaStaSetPSK(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetPSK_t *setPSK = (caStaSetPSK_t *)caCmdBuf;
   dutCmdResponse_t *setPskResp = &gGenericResp;
      
   DPRINT_INFOL(WFA_OUT, "Entering ...\n");

   switch(geSupplicant)
   {
	     case eWindowsZeroConfig:
		    wfaStaSetPSKZeroConfig(len,caCmdBuf,respLen,respBuf);			
		    break;
	   
	     default:
		    setPskResp->status = STATUS_INVALID;
		    wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setPskResp, respBuf);   
		    *respLen = WFA_TLV_HDR_LEN + 4;
		    break;
   }


   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS; 
}


/*
 * wfaStaGetInfo(): 
 * Get vendor specific information in name/value pair by a wireless I/F.
 */
int wfaStaGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf;

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");

   /*
    * Normally this is called to retrieve the vendor information
    * from a interface, no implement yet
    */
   sprintf(infoResp.cmdru.info, "interface,%s,vendor,XXX,cardtype,802.11", getInfo->intf);
   
   infoResp.status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

int wfaStaGetTestData(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
//    dutCmdResponse_t dataResp;
//    dutCommand_t *testData = (dutCommand_t *)caCmdBuf;

    /*
     * This is to trasfer the test log (file) back to console
     * It has not decided to use in-band or out of band. Will be updated
     * in a new release soon.
     */

    return WFA_SUCCESS;
}


/*
 * wfaStaSetEapTTLS():
 *   This is to set
 *   1. ssid
 *   2. username
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyManagementType - wpa or wpa2
 *   6. trustedRootCA
 */
int wfaStaSetEapTTLS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapTTLS_t *setTTLS = (caStaSetEapTTLS_t *)caCmdBuf;
   char *ifname = setTTLS->intf;
   dutCmdResponse_t *setEapTtlsResp = &gGenericResp;

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");

   switch(geSupplicant)
   {
	     case eWindowsZeroConfig:
		    setEapTtlsResp->status = STATUS_INVALID;
		    wfaEncodeTLV(WFA_STA_SET_EAPTTLS_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);   
		    *respLen = WFA_TLV_HDR_LEN + 4;			
		    break;
	 
	     default:
		    setEapTtlsResp->status = STATUS_INVALID;
		    wfaEncodeTLV(WFA_STA_SET_PSK_RESP_TLV, 4, (BYTE *)setEapTtlsResp, respBuf);   
		    *respLen = WFA_TLV_HDR_LEN + 4;
		    break;
   }

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}


/*
 * wfaStaSetEapSIM():
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encrypType - tkip or aes-ccmp
 *   5. keyMangementType - wpa or wpa2
 */
int wfaStaSetEapSIM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapSIM_t *setSIM = (caStaSetEapSIM_t *)caCmdBuf;
   char *ifname = setSIM->intf;
   dutCmdResponse_t *setEapSimResp = &gGenericResp;

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");

   switch(geSupplicant)
   {
	     case eWindowsZeroConfig:
		    setEapSimResp->status = STATUS_INVALID;
		    wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);   
		    *respLen = WFA_TLV_HDR_LEN + 4;			
		    break;
	   
	     default:
		    setEapSimResp->status = STATUS_INVALID;
		    wfaEncodeTLV(WFA_STA_SET_EAPSIM_RESP_TLV, 4, (BYTE *)setEapSimResp, respBuf);   
		    *respLen = WFA_TLV_HDR_LEN + 4;
		    break;
   }

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

/*
 * wfaStaSetPEAP(): For ZeroConfig
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encryType - tkip or aes-ccmp
 *   5. keyMgmtType - wpa or wpa2
 *   6. trustedRootCA
 *   7. innerEAP
 *   8. peapVersion
 */
int wfaStaSetPEAPZeroConfig(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
   char *ifname = setPEAP->intf;
   dutCmdResponse_t *setPeapResp = &gGenericResp;

   FILE *file,*tmpfd;
   char string[256],Interfacename[64], pfile[128], intfile[128];

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");

   sprintf(pfile, "%s\\Temp\\tmp.xml", sigmaPath);
   sprintf(gCmdStr, "del /F /Q %s", pfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);

	  file = fopen(pfile, "w+");

   /* we create a file for reading and writing */
   if(file==NULL) 
   {
      DPRINT_ERR(WFA_ERR, "Can't create file.\n");
      setPeapResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
      *respLen = WFA_TLV_HDR_LEN + 4;

      return WFA_FAILURE;
   }
   else 
   {
      sprintf(gCmdStr,"<?xml version=\"1.0\"?>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"<WLANProfile xmlns=\"http://www.microsoft.com/networking/WLAN/profile/v1\">\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<name>%s</name>\n",setPEAP->ssid);
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<SSIDConfig>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t<SSID>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t<name>%s</name>\n",setPEAP->ssid);
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t</SSID>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t<nonBroadcast>false</nonBroadcast>\n");
      fputs(gCmdStr, file);	
      sprintf(gCmdStr,"\t</SSIDConfig>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<connectionType>ESS</connectionType>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<connectionMode>auto</connectionMode>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<autoSwitch>true</autoSwitch>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t<MSM>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t<security>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t<authEncryption>\n");
      fputs(gCmdStr, file);

      if((strcmp(setPEAP->keyMgmtType, "WPA2") == 0) || (strcmp(setPEAP->keyMgmtType, "wpa2") == 0))
      {
          sprintf(gCmdStr,"\t\t\t\t<authentication>WPA2</authentication>\n");
          fputs(gCmdStr, file);
          sprintf(gCmdStr,"\t\t\t\t<encryption>AES</encryption>\n");
          fputs(gCmdStr, file);
      }
      else if((strcmp(setPEAP->keyMgmtType, "WPA") == 0) || (strcmp(setPEAP->keyMgmtType, "wpa") == 0))
      {
          sprintf(gCmdStr,"\t\t\t\t<authentication>WPA</authentication>\n");
          fputs(gCmdStr, file);
          sprintf(gCmdStr,"\t\t\t\t<encryption>TKIP</encryption>\n");
          fputs(gCmdStr, file);
	  }

	
      sprintf(gCmdStr,"\t\t\t\t<useOneX>true</useOneX>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t</authEncryption>\n");
      fputs(gCmdStr, file);

      sprintf(gCmdStr,"\t\t\t<OneX xmlns=\"http://www.microsoft.com/networking/OneX/v1\">\n");
      fputs(gCmdStr, file);

      sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<cacheUserData>true</cacheUserData>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<authMode>machineOrUser</authMode>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<singleSignOn>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<type>preLogon</type>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<maxDelay>10</maxDelay>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<allowAdditionalDialogs>true</allowAdditionalDialogs>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<userBasedVirtualLan>false</userBasedVirtualLan>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</singleSignOn>\n");
      fputs(gCmdStr, file);

	     sprintf(gCmdStr,"\t\t\t\t<EAPConfig>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t<EapHostConfig xmlns=\"http://www.microsoft.com/provisioning/EapHostConfig\">\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t\t<EapMethod>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t<Type xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">25</Type>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t\t\t<VendorId xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</VendorId>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t\t\t<VendorType xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</VendorType>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t\t\t<AuthorId xmlns=\"http://www.microsoft.com/provisioning/EapCommon\">0</AuthorId>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t\t\t</EapMethod>\n");
      fputs(gCmdStr, file);
    
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<Config xmlns=\"http://www.microsoft.com/provisioning/EapHostConfig\">\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<Eap xmlns=\"http://www.microsoft.com/provisioning/BaseEapConnectionPropertiesV1\">\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<Type>25</Type>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<EapType xmlns=\"http://www.microsoft.com/provisioning/MsPeapConnectionPropertiesV1\">\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<ServerValidation>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<DisableUserPromptForServerValidation>false</DisableUserPromptForServerValidation>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<ServerNames></ServerNames>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</ServerValidation>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<FastReconnect>false</FastReconnect>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<InnerEapOptional>false</InnerEapOptional>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<Eap xmlns=\"http://www.microsoft.com/provisioning/BaseEapConnectionPropertiesV1\">\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<Type>26</Type>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<EapType xmlns=\"http://www.microsoft.com/provisioning/MsChapV2ConnectionPropertiesV1\">\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<UseWinLogonCredentials>false</UseWinLogonCredentials>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</EapType>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</Eap>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<EnableQuarantineChecks>false</EnableQuarantineChecks>\n");
      fputs(gCmdStr, file);
     	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<RequireCryptoBinding>false</RequireCryptoBinding>\n");
      fputs(gCmdStr, file);
     	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<PeapExtensions>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<PerformServerValidation xmlns=\"http://www.microsoft.com/provisioning/MsPeapConnectionPropertiesV2\">false</PerformServerValidation>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t<AcceptServerName xmlns=\"http://www.microsoft.com/provisioning/MsPeapConnectionPropertiesV2\">false</AcceptServerName>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</PeapExtensions>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</EapType>\n");
      fputs(gCmdStr, file);
     	sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</Eap>\n");
      fputs(gCmdStr, file);
	     sprintf(gCmdStr,"\t\t\t\t\t\t\t\t</Config>\n");
      fputs(gCmdStr, file);
												
	     sprintf(gCmdStr,"\t\t\t\t\t</EapHostConfig>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t\t\t</EAPConfig>\n");
      fputs(gCmdStr, file);
     	sprintf(gCmdStr,"\t\t\t</OneX>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t\t</security>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"\t</MSM>\n");
      fputs(gCmdStr, file);
      sprintf(gCmdStr,"</WLANProfile>\n");
      fputs(gCmdStr, file);
  }
  fclose(file);

  sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", sigmaPath);
  tmpfd = fopen(intfile, "r");
  if(tmpfd == NULL)
  {
	   	DPRINT_ERR(WFA_ERR, "Error opening the interface file \n");
     setPeapResp->status = STATUS_ERROR;
     wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
     *respLen = WFA_TLV_HDR_LEN + 4;

     return WFA_FAILURE;
  }
  else
  {
     for(;;)
     {
        if(fgets(string, 256, tmpfd) == NULL)
            break; 
     }
	 fclose(tmpfd);

	 if(strncmp(string, "IFNAME", 6) == 0)
	 {
	    char *str;
	    str = strtok(string, "\"");
	    str = strtok(NULL, "\"");
	    if(str != NULL)
	    {
	        strcpy(&Interfacename[0],str);
	    }
     }
  }

  sprintf(gCmdStr, "netsh wlan add profile filename=\"%s\" interface=\"%s\" user=all",pfile,&Interfacename[0]);
  DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
  system(gCmdStr);


  setPeapResp->status = STATUS_COMPLETE;
  wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);
  *respLen = WFA_TLV_HDR_LEN + 4;

  DPRINT_INFOL(WFA_OUT, "Completing ...\n");

  return WFA_SUCCESS;
}


/*
 * wfaStaSetPEAP()
 *   This is to set
 *   1. ssid
 *   2. user name
 *   3. passwd
 *   4. encryType - tkip or aes-ccmp
 *   5. keyMgmtType - wpa or wpa2
 *   6. trustedRootCA
 *   7. innerEAP
 *   8. peapVersion
 */
int wfaStaSetPEAP(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetEapPEAP_t *setPEAP = (caStaSetEapPEAP_t *)caCmdBuf;
   char *ifname = setPEAP->intf;
   dutCmdResponse_t *setPeapResp = &gGenericResp;

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");


   switch(geSupplicant)
   {
	     case eWindowsZeroConfig:
		    wfaStaSetPEAPZeroConfig(len,caCmdBuf,respLen,respBuf);
		    break;
	   
	     default:
		    setPeapResp->status = STATUS_INVALID;
		    wfaEncodeTLV(WFA_STA_SET_PEAP_RESP_TLV, 4, (BYTE *)setPeapResp, respBuf);   
		    *respLen = WFA_TLV_HDR_LEN + 4;
		    break;
   }

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

/*
 * wfaStaSetUAPSD()
 *    This is to set
 *    1. acBE
 *    2. acBK
 *    3. acVI
 *    4. acVO
 */
int wfaStaSetUAPSD(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetUAPSD_t *setUAPSD = (caStaSetUAPSD_t *)caCmdBuf;
   char *ifname = setUAPSD->intf;
   char tmpStr[10];
   char *pathl="/etc/Wireless/RT61STA";   // Need to change to fix the path hardcode
   dutCmdResponse_t *setUAPSDResp = &gGenericResp;
   BYTE acBE=1;
   BYTE acBK=1;
   BYTE acVO=1;
   BYTE acVI=1;
   BYTE APSDCapable;

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");
   /*
    * A series of setting need to be done before doing WMM-PS
    * Additional steps of configuration may be needed.
    */

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",ifname);

   /*
    * Unload the Driver
    */
   sprintf(gCmdStr, "rmmod rt61");

   if(setUAPSD->acBE != 1)
     acBE=setUAPSD->acBE = 0;
   if(setUAPSD->acBK != 1)
     acBK=setUAPSD->acBK = 0;
   if(setUAPSD->acVO != 1)
     acVO=setUAPSD->acVO = 0;
   if(setUAPSD->acVI != 1)
     acVI=setUAPSD->acVI = 0;

   APSDCapable = acBE||acBK||acVO||acVI;
   /*
    * set other AC parameters
    */

   sprintf(tmpStr,"%d;%d;%d;%d",setUAPSD->acBE,setUAPSD->acBK,setUAPSD->acVI,setUAPSD->acVO);
   sprintf(gCmdStr, "sed -e \"s/APSDCapable=.*/APSDCapable=%d/g\" -e \"s/APSDAC=.*/APSDAC=%s/g\" %s/rt61sta.dat >/tmp/wfa_tmp",APSDCapable,tmpStr,pathl);


   setUAPSDResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_UAPSD_RESP_TLV, 4, (BYTE *)setUAPSDResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

int wfaDeviceGetInfo(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *infoResp = &gGenericResp;
   FILE *tmpfile;
   /*a vendor can fill in the proper info or anything non-disclosure */
   caDeviceGetInfoResp_t dinfo;
   int i;
   char string[512];
   char tfile[128], resfile[128];
   char *str;

   DPRINT_INFOL(WFA_OUT, "Entering wfaDeviceGetInfo() ...\n");

   sprintf(tfile, "%s\\Temp\\temp.txt", sigmaPath);
   sprintf(resfile, "%s\\Temp\\result.txt", sigmaPath);

   sprintf(gCmdStr, "del /F /Q %s",tfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);
   sprintf(gCmdStr, "del /F /Q %s",resfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);

   sprintf(gCmdStr, "netsh wlan show  drivers > %s", tfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);

   sprintf(gCmdStr, "FOR /F \"tokens=2 delims=:\" %s IN ('findstr Vendor %s') DO @echo %s > %s","%i",tfile, "%i", resfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);

   tmpfile = fopen(resfile, "r");
   if(tmpfile == NULL)
   {
      DPRINT_ERR(WFA_ERR, "Error opening the result.txt file \n");
      infoResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

      return WFA_FAILURE;
   }
   else
   {
      for(;;)
	  {
	     if(fgets(string, 256, tmpfile) == NULL)
	       	break; 
	  }
	  fclose(tmpfile);
	  i=strlen(string);
	  string[i]='\0';
   }

   str = strtok(string, " ");
   if(str != NULL)
   {
       strncpy(dinfo.vendor, str,16);		
	   DPRINT_INFO(WFA_OUT, "The Vendor %s", str);
   }


   sprintf(gCmdStr, "FOR /F \"tokens=2 delims=:\" %s IN ('findstr Version %s') DO @echo %s > %s","%i",tfile, "%i", resfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);


   tmpfile = fopen(resfile, "r");
   if(tmpfile == NULL)
   {
      DPRINT_ERR(WFA_ERR, "Error opening the result.txt file \n");
      infoResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

      return WFA_FAILURE;
   }
   else
   {
      for(;;)
      {
	      if(fgets(string, 256, tmpfile) == NULL)
	        break; 
      }
	  fclose(tmpfile);
	  i=strlen(string);
	  string[i]='\0';
   }
   strncpy(dinfo.version, string,16);		
   DPRINT_INFO(WFA_OUT, "The Version %s", string);

   strncpy(dinfo.model, WFA_CLI_VERSION,16);		
   DPRINT_INFO(WFA_OUT, "The model %s", string);

   memcpy(&infoResp->cmdru.devInfo, &dinfo, sizeof(caDeviceGetInfoResp_t));

   infoResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_DEVICE_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

/*
 * This funciton is to retrieve a list of interfaces and return
 * the list back to Agent control.
 * ********************************************************************
 * Note: We intend to make this WLAN interface name as a hardcode name.
 * Therefore, for a particular device, you should know and change the name
 * for that device while doing porting. The MACRO "WFA_STAUT_IF" is defined in 
 * the file "inc/wfa_ca.h". If the device OS is not linux-like, this most 
 * likely is hardcoded just for CAPI command responses.
 * *******************************************************************
 * 
 */
int wfaDeviceListIF(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *infoResp = &gGenericResp;
   dutCommand_t *ifList = (dutCommand_t *)caCmdBuf;
   caDeviceListIFResp_t *ifListResp = &infoResp->cmdru.ifList;

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");
   switch(ifList->cmdsu.iftype)
   {
      case IF_80211:
      infoResp->status = STATUS_COMPLETE;
      ifListResp->iftype = IF_80211; 
      strcpy(ifListResp->ifs[0], aINTERFACE);
      strcpy(ifListResp->ifs[1], "NULL");
      strcpy(ifListResp->ifs[2], "NULL");
      break;

      case IF_ETH:
      infoResp->status = STATUS_COMPLETE;
      ifListResp->iftype = IF_ETH; 
      strcpy(ifListResp->ifs[0], "eth0");
      strcpy(ifListResp->ifs[1], "NULL");
      strcpy(ifListResp->ifs[2], "NULL");
      break;

      default:
      {
         infoResp->status = STATUS_ERROR;
      }
   }
   
   wfaEncodeTLV(WFA_DEVICE_LIST_IF_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}

int wfaStaDebugSet(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t *debugResp = &gGenericResp;
   dutCommand_t *debugSet = (dutCommand_t *)caCmdBuf;

   DPRINT_INFOL(WFA_OUT, "Entering  ...\n");

   if(debugSet->cmdsu.dbg.state == 1) /* enable */
      wfa_defined_debug |= debugSet->cmdsu.dbg.level;
   else
      wfa_defined_debug = (~debugSet->cmdsu.dbg.level & wfa_defined_debug);

   debugResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_GET_INFO_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)debugResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");

   return WFA_SUCCESS;
}


/*
 *   wfaStaGetBSSID():
 *     This function is to retrieve BSSID of a specific wireless I/F.
 */ 
int wfaStaGetBSSID(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   char string[64],Interfacename[64];
   FILE *tmpfd;
   dutCmdResponse_t *bssidResp = &gGenericResp;
   dutCommand_t *getbssid= (dutCommand_t *)caCmdBuf;
   char *ifname = getbssid->intf;
   char bfile[128], intfile[128], tfile[128];

   DPRINT_INFOL(WFA_OUT, "Entering ...\n");
   /* retrieve the BSSID */

   sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", sigmaPath);
   sprintf(bfile, "%s\\Temp\\bssid.txt", sigmaPath);
   sprintf(gCmdStr, "del /F /Q %s", bfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);
   if(geSupplicant == eWindowsZeroConfig)
   {
		    tmpfd = fopen(intfile, "r");
		    if(tmpfd == NULL)
		    {
			      printf("\n Error opening the interface file \n");
	    	}
	    	else
	   	 {
		     	for(;;)
		     	{
			       	if(fgets(string, 256, tmpfd) == NULL)
			         		break; 
			     }
			     fclose(tmpfd);

		     	if(strncmp(string, "IFNAME", 6) == 0)
		  	   {
		      		 char *str;
			      	 str = strtok(string, "\"");
			      	 str = strtok(NULL, "\"");
			      	 if(str != NULL)
	     	 		 {
		        			 strcpy(&Interfacename[0],str);
		     		  }
			     }
	   	}
     sprintf(tfile, "%s\\Temp\\temp.txt", sigmaPath);
		   sprintf(gCmdStr, "del /F /Q %s",tfile);
		   sprintf(gCmdStr, "netsh wlan show  interface name=\"%s\" > %s",&Interfacename[0], tfile);
     DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
	 	  system(gCmdStr);

	   	sprintf(gCmdStr, "FOR /F \"tokens=2,3,4,5,6,7 delims=:\" %s IN ('findstr BSSID %s') DO @echo %s:%s:%s:%s:%s:%s > %s","%i",tfile, "%i","%j","%k","%l","%m","%n", bfile);
     DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
	 	  system(gCmdStr);

   }

   system(gCmdStr);

   tmpfd = fopen(bfile, "r+");
   if(tmpfd == NULL)
   {
      bssidResp->status = STATUS_ERROR;
      wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, 4, (BYTE *)bssidResp, respBuf);   
      *respLen = WFA_TLV_HDR_LEN + 4;

      DPRINT_ERR(WFA_ERR, "File open failed\n");
      return WFA_FAILURE;
   }

   if(geSupplicant == eWindowsZeroConfig)
   {
      if(fscanf(tmpfd, "%s", string) == EOF)
      {
         bssidResp->status = STATUS_COMPLETE; 
         strcpy(bssidResp->cmdru.bssid, "00:00:00:00:00:00");
      }
      else
      {
            strcpy(bssidResp->cmdru.bssid, string);
            bssidResp->status = STATUS_COMPLETE;
      }
   }  

   wfaEncodeTLV(WFA_STA_GET_BSSID_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)bssidResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);

   fclose(tmpfd);

   DPRINT_INFOL(WFA_OUT, "Completing ...\n");
   return WFA_SUCCESS;
}

/*
 * wfaStaSetIBSS()
 *    This is to set
 *    1. ssid
 *    2. channel
 *    3. encrypType - none or wep
 *    optional
 *    4. key1
 *    5. key2
 *    6. key3
 *    7. key4
 *    8. activeIndex - 1, 2, 3, or 4
 */
int wfaStaSetIBSS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetIBSS_t *setIBSS = (caStaSetIBSS_t *)caCmdBuf;
   dutCmdResponse_t *setIbssResp = &gGenericResp;
   int i;

   /*
    * disable the network first
    */ 
   sprintf(gCmdStr, "wpa_cli -i %s disable_network 0", setIBSS->intf); 
   system(gCmdStr);

   /*
    * set SSID
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 ssid '\"%s\"'", setIBSS->intf, setIBSS->ssid);

   system(gCmdStr);

   /*
    * Set channel for IBSS
    */
   sprintf(gCmdStr, "iwconfig %s channel %i", setIBSS->intf, setIBSS->channel);
   system(gCmdStr);

   /*
    * Tell the supplicant for IBSS mode (1)
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 mode 1", setIBSS->intf);
   system(gCmdStr);

   /*
    * set Key management to NONE (NO WPA) for plaintext or WEP
    */
   sprintf(gCmdStr, "wpa_cli -i %s set_network 0 key_mgmt NONE", setIBSS->intf);
   system(gCmdStr);

   if(setIBSS->encpType == 1)
   {
      for(i=0; i<4; i++)
      {
         if((int)strlen(setIBSS->keys[i]) ==5 || (int)strlen(setIBSS->keys[i]) == 13)
         {
             sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_key%i \"%s\"", 
                setIBSS->intf, i, setIBSS->keys[i]);
             system(gCmdStr);
         }
      } 

      i = setIBSS->activeKeyIdx;
      if((int)strlen(setIBSS->keys[i]) ==5 || (int)strlen(setIBSS->keys[i]) == 13)
      {
         sprintf(gCmdStr, "wpa_cli -i %s set_network 0 wep_tx_keyidx %i", 
            setIBSS->intf, setIBSS->activeKeyIdx);
         system(gCmdStr);
      }
   }

   sprintf(gCmdStr, "wpa_cli -i %s enable_network 0", setIBSS->intf);
   system(gCmdStr);

   setIbssResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_IBSS_RESP_TLV, 4, (BYTE *)setIbssResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}

/*
 *  wfaSetMode():
 *  The function is to set the wireless interface with a given mode (possible 
 *  adhoc)
 *  Input parameters:
 *    1. I/F
 *    2. ssid
 *    3. mode adhoc or managed
 *    4. encType
 *    5. channel
 *    6. key(s)
 *    7. active  key
 */ 
int wfaStaSetMode(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetMode_t *setmode = (caStaSetMode_t *)caCmdBuf;
   dutCmdResponse_t *SetModeResp = &gGenericResp;
   int i;

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",setmode->intf);
   system(gCmdStr);

   /*
    * distroy the interface
    */
   sprintf(gCmdStr, "wlanconfig %s destroy",setmode->intf);
   system(gCmdStr);


   /*
    * re-create the interface with the given mode
    */
   if(setmode->mode == 1)
        sprintf(gCmdStr, "wlanconfig %s create wlandev wifi0 wlanmode adhoc",setmode->intf);
   else
        sprintf(gCmdStr, "wlanconfig %s create wlandev wifi0 wlanmode managed",setmode->intf);

   system(gCmdStr);
   if(setmode->encpType == ENCRYPT_WEP)
    {
      int j = setmode->activeKeyIdx;
      for(i=0; i<4; i++)
      {
         if(setmode->keys[i][0] != '\0')
         {
             sprintf(gCmdStr, "iwconfig  %s key  s:%s",
                   setmode->intf, setmode->keys[i]);
             system(gCmdStr);
         }
      /* set active key */
         if(setmode->keys[j][0] != '\0')
             sprintf(gCmdStr, "iwconfig  %s key  s:%s",
                   setmode->intf, setmode->keys[j]);
         system(gCmdStr);
      }

    }
   /*
    * Set channel for IBSS
    */
    if(setmode->channel)
    {
      sprintf(gCmdStr, "iwconfig %s channel %i", setmode->intf, setmode->channel);
      system(gCmdStr);
    }


   /*
    * set SSID
    */
   sprintf(gCmdStr, "iwconfig %s essid %s", setmode->intf, setmode->ssid);
   system(gCmdStr);

   /*
    * bring up the interface
    */
   sprintf(gCmdStr, "ifconfig %s up",setmode->intf);
   system(gCmdStr);

   SetModeResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_MODE_RESP_TLV, 4, (BYTE *)SetModeResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return TRUE;
}


int wfaStaUpload(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaUpload_t *upload = &((dutCommand_t *)caCmdBuf)->cmdsu.upload;
   dutCmdResponse_t *upLoadResp = &gGenericResp;
#ifdef WFA_WMM_EXT
   caStaUploadResp_t *upld = &upLoadResp->cmdru.uld;
#endif
   
   if(upload->type == WFA_UPLOAD_VHSO_RPT)
   {
#ifdef WFA_WMM_EXT
       int rbytes;
       /*
        * if asked for the first packet, always to open the file
        */
       if(upload->next == 1)
       {
          if(e2efp != NULL)
          {
              fclose(e2efp);
              e2efp = NULL;
          }

          e2efp = fopen(e2eResults, "r");
       }

       if(e2efp == NULL)
       {
           upLoadResp->status = STATUS_ERROR;
           wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
           *respLen = WFA_TLV_HDR_LEN + 4;
           return FALSE;
       }
        
       rbytes = fread(upld->bytes, 1, 256, e2efp); 

       if(rbytes < 256)  
       {
           /* 
            * this means no more bytes after this read
            */
           upld->seqnum = 0;
       }
       else
       { 
           upld->seqnum = upload->next;
       }
		fclose(e2efp);
        e2efp=NULL;

       upld->nbytes = rbytes;

       upLoadResp->status = STATUS_COMPLETE;
#else
       printf("The command not supported\n");
       upLoadResp->status = STATUS_ERROR;
#endif
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
   }
   else
   {
       upLoadResp->status = STATUS_ERROR;
       wfaEncodeTLV(WFA_STA_UPLOAD_RESP_TLV, 4, (BYTE *)upLoadResp, respBuf);
       *respLen = WFA_TLV_HDR_LEN + 4;
   }

   return TRUE;
}
/*
 * wfaStaSetWMM()
 *  TO be ported on a specific plaform for the DUT
 *  This is to set the WMM related parameters at the DUT.
 *  Currently the function is used for GROUPS WMM-AC and WMM general configuration for setting RTS Threshhold, Fragmentation threshold and wmm (ON/OFF)
 *  It is expected that this function will set all the WMM related parametrs for a particular GROUP .
 */
int wfaStaSetWMM(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetWMM_t *setwmm = (caStaSetWMM_t *)caCmdBuf;
   char *ifname = setwmm->intf;
   dutCmdResponse_t *setwmmResp = &gGenericResp;
#ifdef _WINDOWS
  char string[256],filename[256];
  FILE *tmpfd;
  int length;
#else

   /*
    * A series of setting need to be done before doing WMM test 
    * Additional steps of configuration may be needed.
    */

   /*
    * bring down the interface
    */
   sprintf(gCmdStr, "ifconfig %s down",ifname);
   system(gCmdStr);
#endif
   switch(setwmm->group)
   {
#ifdef WFA_WMM_AC
      case GROUP_WMMAC:
            if(setwmm->action == WMMAC_ADDTS)
			{
			    //wmmacadd_t *addts= &(setwmm->actions.addts);

      			/* This needs to be ported to the specific platform with these TSPEC details*/
		         
			    printf("ADDTS AC PARAMS: dialog id: %d, TID: %d, DIRECTION: %d, PSB: %d, UP: %d,\
			    Fixed %d, MSDU Size: %d, Max MSDU Size %d, MIN SERVICE INTERVAL: %d, MAX SERVICE INTERVAL: %d\
                         ,INACTIVITY: %d,SUSPENSION %d,SERVICE START TIME: %d,MIN DATARATE: %d,MEAN DATA RATE: %d\
                         , PEAK DATA RATE: %d,BURSTSIZE: %d,DELAY BOUND: %d,PHYRATE: %d, SPLUSBW: %f,MEDIUM TIME: %d, ACCESSCAT: %d\n"\
                         ,setwmm->actions.addts.dialog_token,setwmm->actions.addts.tspec.tsinfo.TID\
			             ,setwmm->actions.addts.tspec.tsinfo.direction,setwmm->actions.addts.tspec.tsinfo.PSB,setwmm->actions.addts.tspec.tsinfo.UP\
                         ,setwmm->actions.addts.tspec.Fixed,setwmm->actions.addts.tspec.size, setwmm->actions.addts.tspec.maxsize,\
                         setwmm->actions.addts.tspec.min_srvc,\
                         setwmm->actions.addts.tspec.max_srvc,setwmm->actions.addts.tspec.inactivity,setwmm->actions.addts.tspec.suspension,\
                         setwmm->actions.addts.tspec.srvc_strt_tim,setwmm->actions.addts.tspec.mindatarate,setwmm->actions.addts.tspec.meandatarate\
                         ,setwmm->actions.addts.tspec.peakdatarate,setwmm->actions.addts.tspec.burstsize,\
                         setwmm->actions.addts.tspec.delaybound,setwmm->actions.addts.tspec.PHYrate,setwmm->actions.addts.tspec.sba,\
			             setwmm->actions.addts.tspec.medium_time,setwmm->actions.addts.accesscat);
                         
			    sprintf(gCmdStr, "iwpriv %s acm %d 1 1",ifname,setwmm->actions.addts.accesscat);
			    printf("cmd is  %s\n",gCmdStr);
				system(gCmdStr);
				if(setwmm->send_trig)
				{
					int Sockfd;
	    				struct sockaddr_in psToAddr;
					int TxMsg[512];
	         			Sockfd = wfaCreateUDPSock(setwmm->dipaddr, 12346);
					memset(&psToAddr, 0, sizeof(psToAddr));
					psToAddr.sin_family = AF_INET;
					psToAddr.sin_addr.s_addr = inet_addr(setwmm->dipaddr);
					psToAddr.sin_port = htons(12346);
					usleep(becon_int);
	   				wfaTGSetPrio(Sockfd, setwmm->trig_ac);
					printf("\r\nSending dummy Hello to %s\n",setwmm->dipaddr);
	       				create_apts_msg(APTS_HELLO, TxMsg,0);
	   				sendto(Sockfd, TxMsg, 256, 0, (struct sockaddr *)&psToAddr, sizeof(struct sockaddr));
					close(Sockfd);
				}
                         //system(gCmdStr);
			}
			else
		         printf("DELTS AC PARAMS: TID: %d\n",setwmm->actions.delts);

            setwmmResp->status = STATUS_COMPLETE;
            break;
#endif
      case GROUP_WMMCONF:
#if !defined(_CYGWIN) && !defined(_WINDOWS)
            sprintf(gCmdStr, "iwconfig %s rts_thr %d",ifname,setwmm->actions.config.rts_thr);
            system(gCmdStr);
            sprintf(gCmdStr, "iwconfig %s frag_thr %d",ifname,setwmm->actions.config.frag_thr);
            system(gCmdStr);
            sprintf(gCmdStr, "iwpriv %s wmm %d",ifname,setwmm->actions.config.wmm);
            //system(gCmdStr);
#else
		    switch(vend)
			{
				case WMM_BROADCOMM: 
	                if(!(setwmm->actions.config.wmm))
				        sprintf(gCmdStr, "wl wme 0");
				    else
					    sprintf(gCmdStr, "wl wme 1");
					system(gCmdStr);
				break;

				case WMM_INTEL: 
					sprintf(gCmdStr, "IntDis.bat");
					printf("Executing %s\n",gCmdStr);
					system(gCmdStr);
					strcpy(filename,"intel.txt");
					tmpfd = fopen(filename, "r+");
					if(tmpfd == NULL)
					{
						sprintf(gCmdStr, "IntGet.bat  1>%s 2>c:\\windows\\temp\\mynull",filename);
						printf("Executing %s\n",gCmdStr);
						system(gCmdStr);
							
						tmpfd = fopen(filename, "r+");
						if(tmpfd == NULL)
						{
							setwmmResp->status = STATUS_ERROR;
							wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);   
							*respLen = WFA_TLV_HDR_LEN + 4;

							DPRINT_ERR(WFA_ERR, "file open failed\n");
							return FALSE;
						}
					}
					fgets(string, 256, tmpfd);
					fclose(tmpfd);
					length=strlen(string);
					while(string[length -1] == '\n')
					{
						string[length-1]=0;
						length--;
					}
						
					if(!(setwmm->actions.config.wmm))
						sprintf(gCmdStr, "reg add %s /v TGeEnableBits /t REG_DWORD /d 0 /f",string);
					else
						sprintf(gCmdStr, "reg add %s /v TGeEnableBits /t REG_DWORD /d 1 /f",string);
					printf("Executing %s\n",gCmdStr);
					system(gCmdStr);

					sprintf(gCmdStr, "IntEn.bat");
					printf("Executing %s\n",gCmdStr);
					system(gCmdStr);
				break;

			    case WMM_ATHEROS: 
					sprintf(gCmdStr, "AthDis.bat");
					printf("Executing %s\n",gCmdStr);
					system(gCmdStr);
					strcpy(filename,"Ath.txt");
					tmpfd = fopen(filename, "r+");
					if(tmpfd == NULL)
					{
						sprintf(gCmdStr, "AthGet.bat 1>%s 2>c:\\windows\\temp\\mynull",filename);
						printf("Executing %s\n",gCmdStr);
						system(gCmdStr);
							
						tmpfd = fopen(filename, "r+");
						if(tmpfd == NULL)
						{
							setwmmResp->status = STATUS_ERROR;
							wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);   
							*respLen = WFA_TLV_HDR_LEN + 4;

							DPRINT_ERR(WFA_ERR, "file open failed\n");
							return FALSE;
						}
					}
					fgets(string, 256, tmpfd);
					fclose(tmpfd);
											
					length=strlen(string);
					while(string[length -1] == '\n')
					{
						string[length-1]=0;
						length--;
					}
					if(!(setwmm->actions.config.wmm))
						sprintf(gCmdStr, "reg add %s /v WmeEnabled /t REG_DWORD /d 0 /f",string);
					else
						sprintf(gCmdStr, "reg add %s /v WmeEnabled /t REG_DWORD /d 1 /f",string);
					printf("Executing %s\n",gCmdStr);
				    system(gCmdStr);
											
				    sprintf(gCmdStr, "AthEn.bat");
					printf("Executing %s\n",gCmdStr);
					system(gCmdStr);
				break;
				default:
				    printf("Unknown station %d\n",vend);
				break;
			}  /* switch (vend) */
#endif
            setwmmResp->status = STATUS_COMPLETE;
            break; /* case GROUP_WMMCONF */

	        default:
                 DPRINT_ERR(WFA_ERR, "The group %d is not supported\n",setwmm->group);
                 setwmmResp->status = STATUS_ERROR;
            break;

   }
#if !defined(_CYGWIN) && !defined(_WINDOWS)
   /*
    * bring up the interface
    */
   sprintf(gCmdStr, "ifconfig %s up",ifname);
   system(gCmdStr);
#endif

   wfaEncodeTLV(WFA_STA_SET_WMM_RESP_TLV, 4, (BYTE *)setwmmResp, respBuf);
   printf("tag is %d\n",WFA_STA_SET_WMM_RESP_TLV);
   *respLen = WFA_TLV_HDR_LEN + 4;
   return TRUE;
}


int GetIntelDeviceID(char * apDeviceID)
{
    FILE *file;
    char prv3Line[96];
  	char prv2Line[96];
  	char prv1Line[96];
  	char prvLine[128];
    char crntLine[128];
  	char deviceID[16];
    char * str;

    DPRINT_INFOL(WFA_OUT, "Entering ...\n");	

  	// get the Device ID
    sprintf(gCmdStr, "devcon hwids \"*\" > c:\\windows\\temp\\devid.txt");
    system(gCmdStr);
    DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
    Sleep(3000);
	  // open the file and read for
    file = fopen("c:\\windows\\temp\\devid.txt","r+");
    if(file == NULL)
    {
 	    //error opening the registry and print error
	    printf("\nError opening c:\\windows\\temp\\devid.txt - Device ID dump ");
    }
    else
    {
        for(;;)
	    {
	      	if(fscanf(file, "%127s", crntLine) == EOF)
		   	{
	   			DPRINT_ERR(WFA_ERR, "EOF reached, Device ID not found\n");
        		fclose(file);
        		return WFA_SUCCESS;
		    }

            if(strncmp(crntLine, "3945ABG", 14) == 0)
	        {
	        	break;
	         }
	         strncpy(prv3Line,prv2Line,95);
	      	 strncpy(prv2Line,prv1Line,95);
		     strncpy(prv1Line,prvLine,95);
		     strcpy(prvLine,crntLine);
	 	}
		fclose(file);
		printf("Current line is: %s",crntLine);
	    printf("PrivLine line is: %s",prvLine);
	    printf("Priv1Line line is: %s",prv1Line);
	    printf("Priv2Line line is: %s",prv2Line);
		printf("Priv3Line line is: %s",prv3Line);	

		str = strtok(prv3Line,"&");
		str = strtok(NULL,"&");
	    strcpy(deviceID,str);		
	   	printf("\n The Device ID is -  : %s",deviceID);
	    strcpy(apDeviceID,deviceID);
    }
}

int GetIntelRegistryID(char * apRegistryID)
{	
	FILE *file;
  	char prvLine[128];
  	char crntLine[128];

    sprintf(gCmdStr, "reg query HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class /s > c:\\windows\\temp\\test.txt");
  	system(gCmdStr);
    DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
    Sleep(3000);

	  // open the file and read for
  	file = fopen("c:\\windows\\temp\\test.txt","r+");
    if(file == NULL)
    {
       //error opening the registry and print error
       printf("\nError opening c:\\windows\\temp\\test.txt - registry dump ");
    }
    else
    {
       for(;;)
	   {
	       if(fscanf(file, "%127s", crntLine) == EOF)
	       {
		      DPRINT_ERR(WFA_ERR, "EOF reached, Requested mode not set\n");
		      fclose(file);
		      return WFA_SUCCESS;
		   }

    	   if(strncmp(crntLine, "ModulationType", 14) == 0)
           {
		      break;
		   }
		   strcpy(prvLine,crntLine);
	   }
	   fclose(file);
       printf("Current line is: %s",crntLine);
       printf("PrivLine line is: %s",prvLine);

       strcpy(apRegistryID,prvLine);
    }

 	return WFA_SUCCESS;
}

int setIntelMode( int aMode )
{
	  char registyID[128];
	  char deviceID[16];

	  DPRINT_INFO(WFA_OUT, "Inside setIntelmode function ...\n");	


	  // get the Device ID
	  GetIntelDeviceID(deviceID);
	  GetIntelRegistryID(registyID);
	  if(aMode == eModeB)
	  {
		     sprintf(gCmdStr, "reg add %s /v ModulationType /t REG_SZ /d 0 /f",registyID);
		     system(gCmdStr);
	     	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	     	Sleep(1000);
	     	sprintf(gCmdStr, "reg add %s /v BandType /t REG_DWORD /d 0x0 /f",registyID);
	     	system(gCmdStr);
	     	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	     	Sleep(1000);
	  }
	  else if(aMode == eModeABG)
	  {
		     sprintf(gCmdStr, "reg add %s /v ModulationType /t REG_SZ /d 2 /f",registyID);
		     system(gCmdStr);
	     	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	     	Sleep(1000);
	     	sprintf(gCmdStr, "reg add %s /v BandType /t REG_DWORD /d 0x2 /f",registyID);
		     system(gCmdStr);
		     DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		     Sleep(1000);
	  }

	  sprintf(gCmdStr, "devcon disable *%s*",deviceID);
	  system(gCmdStr);
	  DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	  Sleep(2000);
	  sprintf(gCmdStr, "devcon enable *%s*",deviceID);
	  system(gCmdStr);
	  DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	  Sleep(2000);

	  return TRUE;
}

int setIntelPowerSave( BYTE aPowerSave)
{
//	FILE *file;
//	char prvLine[128];
	char registyID[128];
	char deviceID[16];
//	char *str;

	DPRINT_INFO(WFA_OUT, "Inside setIntelPowerSave function ...\n");	

	// get the Device ID
	GetIntelDeviceID(deviceID);

	// Get the Registry ID
	GetIntelRegistryID(registyID);

	if(aPowerSave == 1)
	{
		sprintf(gCmdStr, "reg add %s /v PowerIndex /t REG_SZ /d 5 /f",registyID);
		system(gCmdStr);
		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		Sleep(1000);
	}
	else 
	{
		sprintf(gCmdStr, "reg add %s /v PowerIndex /t REG_SZ /d 0 /f",registyID);
		system(gCmdStr);
		DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		Sleep(1000);
	}

	sprintf(gCmdStr, "devcon disable *%s*",deviceID);
	system(gCmdStr);
	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	Sleep(2000);
	sprintf(gCmdStr, "devcon enable *%s*",deviceID);
	system(gCmdStr);
	DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	Sleep(2000);

	return WFA_SUCCESS;
}

int wfaStaPresetParameters(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaPresetParameters_t *presetParams = (caStaPresetParameters_t *)caCmdBuf;
   dutCmdResponse_t *PresetParamsResp = &gGenericResp;
   char *intfname = presetParams->intf;
   BYTE presetDone=0;
   int st = 0;

   DPRINT_INFO(WFA_OUT, "Inside wfaStaPresetParameters function ...\n");
   DPRINT_INFO(WFA_OUT,"\nCurrent Supplicant value: %d\n",geSupplicant);
   DPRINT_INFO(WFA_OUT,"\nReceived Supplicant value: %d\n",presetParams->supplicant);
  
   // For Win 7 - DUT the supplicant is always ZeroConfig and preset =1
   if (presetParams->supplicant)
   {
		   presetDone = 1;
   }


#if defined(_CYGWIN) || defined(_WINDOWS)
#ifndef TGN_TB_STATION
	if(presetParams->modeFlag)
	{
		if( vend == WMM_INTEL )
			setIntelMode(presetParams->wirelessMode);
		else
			printf("Not an Intel Sta for setting wirelessmode");
	}
#else

   	if(presetParams->reset != 0)
	{
		switch(presetParams->reset)
		{
		case eResetProg11n:
			sprintf(gCmdStr, "cd %s & reset_default /interface %s /set 11n", WFA_CLI_CMD_DIR, aINTERFACE);	        
			break;
		default:
			printf("The program not supported.\n");
		}

        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}
    if(presetParams->fragFlag == 1)
	{
		sprintf(gCmdStr, "cd %s & SET_FRAG /interface %s /value %d", WFA_CLI_CMD_DIR, aINTERFACE,presetParams->fragThreshold);
        printf("%s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}

	if(presetParams->rtsFlag == 1)
	{

		sprintf(gCmdStr, "cd %s & SET_RTS /interface %s /value %d", WFA_CLI_CMD_DIR, aINTERFACE,presetParams->rtsThreshold);
        printf("%s\n", gCmdStr);

        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}

	if(presetParams->preambleFlag == 1)
	{
		if(presetParams->preamble == eLong)
			sprintf(gCmdStr, "cd %s & STA_SET_PREAMBLE /interface %s /value long", WFA_CLI_CMD_DIR, aINTERFACE);
		else
			sprintf(gCmdStr, "cd %s & STA_SET_PREAMBLE /interface %s /value short", WFA_CLI_CMD_DIR, aINTERFACE);

		printf("%s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}


    if(presetParams->wmmFlag)
	{
		if(presetParams->wmmState == 1)
		{
			sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action on", WFA_CLI_CMD_DIR, aINTERFACE);
	        printf("%s\n", gCmdStr);
		}
		else
		{
			sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action off", WFA_CLI_CMD_DIR, aINTERFACE);
	        printf("%s\n", gCmdStr);
		}

        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}

	if(presetParams->ht == 1)
	{
        //sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action on", WFA_CLI_CMD_DIR, aINTERFACE);
	    //printf("%s\n", gCmdStr);
        tgWMMTestEnable = 0;
	}
	else
	{
		//sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action off", WFA_CLI_CMD_DIR, aINTERFACE);
	    //printf("%s\n", gCmdStr);
        tgWMMTestEnable = 1;
	}

	if(presetParams->modeFlag != 0)
	{
		switch(presetParams->wirelessMode)
		{
		case eModeB:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode BO",WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		case eModeBG:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode BG", WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		case eModeA:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode AO", WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		case eModeAN:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode NA", WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		case eModeGN:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode NG", WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		case eModeNL:
			sprintf(gCmdStr, "cd %s & sta_set_mode /interface %s /mode NL", WFA_CLI_CMD_DIR, aINTERFACE);
			printf("%s\n", gCmdStr);
			break;
		default:
			printf("other mode does not need to support\n");
        }

        st = wfaExecuteCLI(gCmdStr);
        switch(st)
	    {
	    case 0:
	    presetDone = 1;
	    break;
	    case 1:
		presetDone = 0;
		break;
	    case 2:
		presetDone = 0;
		break;
	    }
	}

#endif

#ifndef TGN_TB_STATION
	
	if(presetParams->psFlag)
	{
		if( vend == WMM_INTEL )
			setIntelPowerSave(presetParams->legacyPowerSave  );
		else if(vend == WMM_BROADCOMM)
		{
			if(presetParams->legacyPowerSave)
			{
				// call wl utility to execute the powersave mode.
				sprintf(gCmdStr, "wl PM 1");
				system(gCmdStr);
				Sleep(1000);
			}
			else
			{
				// call wl utility to execute the powersave mode.
				sprintf(gCmdStr, "wl PM 0");
				system(gCmdStr);
				Sleep(1000);
			}
		}
		else
			printf("Not an Intel /Broadcom Sta for setting powersave ");
	}
#else

#if 0
    if(presetParams->wmmFlag)
	{
		    if(presetParams->wmmState == 1)
		    {
			    sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action on", WFA_CLI_CMD_DIR, aINTERFACE);
				printf("%s\n", gCmdStr);
			    system(gCmdStr);
                tgWMMTestEnable = 1;
		    }
		    else
		    {
			    sprintf(gCmdStr, "cd %s & STA_SET_WMM /interface %s /action off", WFA_CLI_CMD_DIR, aINTERFACE);
				printf("%s\n", gCmdStr);
			    system(gCmdStr);
                tgWMMTestEnable = 0;
		    }
	}
#endif

    if(presetParams->psFlag)
	{
		if(presetParams->legacyPowerSave == 1)
		    sprintf(gCmdStr, "cd %s & sta_set_power_save /interface %s /powersave pspoll", WFA_CLI_CMD_DIR, aINTERFACE);
		else if(presetParams->legacyPowerSave == 2)
			sprintf(gCmdStr, "cd %s & sta_set_power_save /interface %s /powersave fast", WFA_CLI_CMD_DIR, aINTERFACE);
		else if(presetParams->legacyPowerSave == 3)
			sprintf(gCmdStr, "cd %s & sta_set_power_save /interface %s /powersave psnonpoll ", WFA_CLI_CMD_DIR, aINTERFACE);
		else
            sprintf(gCmdStr, "cd %s & sta_set_power_save /interface %s /powersave off", WFA_CLI_CMD_DIR, aINTERFACE);

		printf("%s\n", gCmdStr);
        //system(gCmdStr);
        st = wfaExecuteCLI(gCmdStr);

	    switch(st)
		{
			case 0:
			   presetDone = 1;
			   break;
			case 1:
			    presetDone = 0;
				PresetParamsResp->status = STATUS_ERROR;
				break;
			case 2:
			    presetDone = 0;
				PresetParamsResp->status = STATUS_INVALID;
				break;
		}
		

	}
#endif

	if(presetParams->noack_be != 0 || presetParams->noack_bk != 0 || presetParams->noack_vi != 0 || presetParams->noack_vo != 0)
	{
		sprintf(gCmdStr, "cd %s & set_noack /interface %s /mode %x %x %x %x",WFA_CLI_CMD_DIR,aINTERFACE,presetParams->noack_be-1,presetParams->noack_bk-1,presetParams->noack_vi-1,presetParams->noack_vo-1);
        printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);

	}

    if (presetDone)
    {
		PresetParamsResp->status = STATUS_COMPLETE;
		wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + 4;
    }
    else
    {
		PresetParamsResp->status = STATUS_INVALID;
		wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);   
		*respLen = WFA_TLV_HDR_LEN + 4;
    }


#else
   setPskResp->status = STATUS_INVALID;
   wfaEncodeTLV(WFA_STA_PRESET_PARAMETERS_RESP_TLV, 4, (BYTE *)PresetParamsResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + 4;
#endif
	return WFA_SUCCESS;
}


int wfaStaSetEapFAST(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEapFAST_t *setFAST= (caStaSetEapFAST_t *)caCmdBuf;
	char *ifname = setFAST->intf;
	dutCmdResponse_t *setEapFastResp = &gGenericResp;


   switch(geSupplicant)
   {
	   case eWindowsZeroConfig:
		   setEapFastResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;			
		   break;
	   
	   default:
		   setEapFastResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPFAST_RESP_TLV, 4, (BYTE *)setEapFastResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;	
		   break;
   }

	return WFA_SUCCESS;
}

int wfaStaSetEapAKA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	caStaSetEapAKA_t *setAKA= (caStaSetEapAKA_t *)caCmdBuf;
	char *ifname = setAKA->intf;
	dutCmdResponse_t *setEapAkaResp = &gGenericResp;

   switch(geSupplicant)
   {
	   case eWindowsZeroConfig:
		   setEapAkaResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;			
		   break;
	   
	   default:
		   setEapAkaResp->status = STATUS_INVALID;
		   wfaEncodeTLV(WFA_STA_SET_EAPAKA_RESP_TLV, 4, (BYTE *)setEapAkaResp, respBuf);   
		   *respLen = WFA_TLV_HDR_LEN + 4;	
		   break;
   }

	return WFA_SUCCESS;
}


int wfaStaSetSystime(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   caStaSetSystime_t *systime = (caStaSetSystime_t *)caCmdBuf;
   dutCmdResponse_t *setSystimeResp = &gGenericResp;

   DPRINT_INFO(WFA_OUT, "Entering wfaStaSetSystime ...\n"); 

   sprintf(gCmdStr, "date %d-%d-%d",systime->month,systime->date,systime->year);
   system(gCmdStr);

   sprintf(gCmdStr, "time %d:%d:%d", systime->hours,systime->minutes,systime->seconds);
   system(gCmdStr);

   setSystimeResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_SET_SYSTIME_RESP_TLV, 4, (BYTE *)setSystimeResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

   return WFA_SUCCESS;
}


void RefreshTaskbarNotificationArea()
{
    HWND hNotificationArea;
    RECT r;
	   LONG x ;
	   LONG y ;
    GetClientRect(hNotificationArea = FindWindowEx(FW(FW(FW(NULL, L"Shell_TrayWnd"), L"TrayNotifyWnd"), L"SysPager"),NULL,L"ToolbarWindow32",L"Notification Area"),&r);
;    
    for ( x = 0; x < r.right; x += 5)
        for ( y = 0; y < r.bottom; y += 5)
            SendMessage(
                hNotificationArea,
                WM_MOUSEMOVE,
                0,
                (y << 16) + x);
} 

int wfaStaSet11n(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf) 
{
	
	caSta11n_t * v11nParams = (caSta11n_t *)caCmdBuf;
	dutCmdResponse_t *v11nParamsResp = &gGenericResp;
#ifndef _WINDOWS
	char *intf = v11nParams->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st=0, status = STATUS_ERROR;

	DPRINT_INFO(WFA_OUT, "START - wfaStaSet11n at interface %s\n", intf); 
	//TODO

	if(v11nParams->addba_reject != 0xFF && v11nParams->addba_reject < 2)
	{
        //sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_ADDBA_REJECT", intf, capstr[v11nParams->addba_reject]);
        sprintf(gCmdStr, "cd %s & set_addba_reject /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->addba_reject]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_addba_reject failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}
	
    if(v11nParams->ampdu != 0xFF && v11nParams->ampdu < 2)
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_AMPDU", intf, capstr[v11nParams->ampdu]);
        sprintf(gCmdStr, "cd %s & set_ampdu /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->ampdu]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_ampdu failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}
	
    if(v11nParams->amsdu != 0xFF && v11nParams->amsdu < 2)
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_AMSDU", intf, capstr[v11nParams->amsdu]);
        sprintf(gCmdStr, "cd %s & set_amsdu /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->amsdu]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_amsdu failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

    if(v11nParams->greenfield != 0xFF && v11nParams->greenfield < 2)
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_GREENFIELD", intf, capstr[v11nParams->greenfield]);
        sprintf(gCmdStr, "cd %s & set_greenfield /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->greenfield]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "_set_greenfield failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

    if(v11nParams->mcs32!= 0xFF && v11nParams->mcs32 < 2 && v11nParams->mcs_fixedrate[0] != '\0')
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /mcs32 %s", WFA_CLI_CMD_DIR, "SET_MCS", intf, capstr[v11nParams->mcs32]);
        sprintf(gCmdStr, "cd %s & set_mcs /interface %s /fixedRate %s /mcs32 %s /BW %d", WFA_CLI_CMD_DIR, intf, v11nParams->mcs_fixedrate, capstr[v11nParams->mcs32],g11nChnlWidth);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_mcs failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	} 
	else if (v11nParams->mcs32!= 0xFF && v11nParams->mcs32 < 2 && v11nParams->mcs_fixedrate[0] == '\0')
	{
        //sprintf(gCmdStr, "%s\%s /interface %s /mcs32 %s", WFA_CLI_CMD_DIR, "SET_MCS", intf, v11nParams->mcs_supported);
        sprintf(gCmdStr, "cd %s & set_mcs /interface %s  /fixedRate null /mcs32 %s /BW %d", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->mcs32],g11nChnlWidth);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_mcs32 failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}

	} 
	else if (v11nParams->mcs32 == 0xFF && v11nParams->mcs_fixedrate[0] != '\0')
	{
		sprintf(gCmdStr, "cd %s & set_mcs /interface %s /fixedRate %s /mcs32 disable /BW %d", WFA_CLI_CMD_DIR, intf, v11nParams->mcs_fixedrate,g11nChnlWidth);
	}

    if(v11nParams->rifs_test != 0xFF && v11nParams->rifs_test < 2)
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_RIFS_TEST", intf, capstr[v11nParams->rifs_test]);
        sprintf(gCmdStr, "cd %s & set_rifs_test /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->rifs_test]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_rifs_test failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

    if(v11nParams->sgi20 != 0xFF && v11nParams->sgi20 < 2)
	{
		//sprintf(gCmdStr, "%s\%s /interface %s /action %s", WFA_CLI_CMD_DIR, "SET_SGI20", intf, capstr[v11nParams->sgi20]);
        sprintf(gCmdStr, "cd %s & set_sgi20 /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->sgi20]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_sgi20 failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	if(v11nParams->smps != 0xFFFF)
	{
	    if(v11nParams->smps == 0)
	    {
            sprintf(gCmdStr, "cd %s & set_smps /interface %s /mode dynamic",WFA_CLI_CMD_DIR, intf);
	    }
	    else if(v11nParams->smps == 1)
	    {
            sprintf(gCmdStr, "cd %s & set_smps /interface %s /mode static", WFA_CLI_CMD_DIR, intf);
	    }
	    else if(v11nParams->smps == 2)
		{
            sprintf(gCmdStr, "cd %s & set_smps /interface %s /mode nolimit", WFA_CLI_CMD_DIR, intf);
	    }
        printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_smps failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	if(v11nParams->stbc_rx != 0xFFFF)
	{
		sprintf(gCmdStr, "cd %s & set_stbc_rx /interface %s /streams %i", WFA_CLI_CMD_DIR, intf, v11nParams->stbc_rx);
		printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_stbc_rx failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}
	
	if(v11nParams->width[0] != '\0')
	{
		sprintf(gCmdStr, "cd %s & set_11n_channel_width /interface %s /width %s", WFA_CLI_CMD_DIR, intf, v11nParams->width);
		printf("RUN: %s\n", gCmdStr);
		g11nChnlWidth = atoi(v11nParams->width);
        st = wfaExecuteCLI(gCmdStr);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_11n_channel_width failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}

	}
	
    if(v11nParams->_40_intolerant != 0xFF && v11nParams->_40_intolerant < 2)
	{
		sprintf(gCmdStr, "cd %s & set_40_intolerant /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[v11nParams->_40_intolerant]);
		printf("RUN: %s\n", gCmdStr);
		st = wfaExecuteCLI(gCmdStr);
		printf("st %i\n", st);
		if(st != 0)
		{
            v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_40_intolerant failed");
	        wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
	        *respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}

	}

	if(v11nParams->txsp_stream != 0 && v11nParams->txsp_stream <4)
	{
		sprintf(gCmdStr, "cd %s & set_txsp_stream /interface %s /value %u", WFA_CLI_CMD_DIR, intf, v11nParams->txsp_stream);
		printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);
		printf("st %i\n", st);
		if(st != 0)
		{
			v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_txsp_stream failed");
			wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}

	}

	if(v11nParams->rxsp_stream != 0 && v11nParams->rxsp_stream < 4)
	{
        sprintf(gCmdStr, "cd %s & set_rxsp_stream /interface %s /value %u", WFA_CLI_CMD_DIR, intf, v11nParams->rxsp_stream);
		printf("RUN: %s\n", gCmdStr);
        st = wfaExecuteCLI(gCmdStr);

		if(st != 0)
		{
			v11nParamsResp->status = STATUS_ERROR;
			strcpy(v11nParamsResp->cmdru.info, "set_rxsp_stream failed");
			wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, sizeof(dutCmdResponse_t), (BYTE *)v11nParamsResp, respBuf);
			*respLen = WFA_TLV_HDR_LEN + sizeof(dutCmdResponse_t);
			return FALSE;
		}
	}

	v11nParamsResp->status = STATUS_COMPLETE;
	wfaEncodeTLV(WFA_STA_SET_11N_RESP_TLV, 4, (BYTE *)v11nParamsResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;
	return TRUE;
}

int wfaStaSetWireless(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf){
	
	  caStaSetWireless_t * staWirelessParams = (caStaSetWireless_t *)caCmdBuf;
	  dutCmdResponse_t *staWirelessResp = &gGenericResp;
#ifndef _WINDOWS
	  char *intf = staWirelessParams->intf;
#else
	  char *intf = aINTERFACE;
#endif
	  int st = 0;
	
	  DPRINT_INFO(WFA_OUT, "START - wfaStaSetWireless \n");
	  if((staWirelessParams->noAck[NOACK_BE] == 0 || staWirelessParams->noAck[NOACK_BE] == 1) && 
		    (staWirelessParams->noAck[NOACK_BK] == 0 ||  staWirelessParams->noAck[NOACK_BK] == 1) &&
		    (staWirelessParams->noAck[NOACK_VI] == 0 || staWirelessParams->noAck[NOACK_VI] == 1) &&
		    (staWirelessParams->noAck[NOACK_VO] == 0 || staWirelessParams->noAck[NOACK_VO] == 0) )
	 {
		    sprintf(gCmdStr, "cd %s & set_noack /interface %s /mode %x %x %x %x", staWirelessParams->noAck[NOACK_BE], staWirelessParams->noAck[NOACK_BK], staWirelessParams->noAck[NOACK_VI], staWirelessParams->noAck[NOACK_VO]);
      st = wfaExecuteCLI(gCmdStr);
		    if(st != 0)
		    {
			      staWirelessResp->status = STATUS_ERROR;
		      	strcpy(staWirelessResp->cmdru.info, "set_noack failed");
	     }
	 }

	 staWirelessResp->status = STATUS_COMPLETE;
	 wfaEncodeTLV(WFA_STA_SET_WIRELESS_RESP_TLV, 4, (BYTE *)staWirelessResp, respBuf);
 	*respLen = WFA_TLV_HDR_LEN + 4;

 	return WFA_SUCCESS;
}

int wfaStaSendADDBA(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf){
	  caStaSetSendADDBA_t *staSendADDBA = (caStaSetSendADDBA_t *)caCmdBuf;
  	dutCmdResponse_t *staSendADDBAResp = &gGenericResp;
#ifndef _WINDOWS
	  char *intf = caStaSetSendADDBA->intf;
#else
	  char *intf = aINTERFACE;
#endif
	  int st;

	  DPRINT_INFO(WFA_OUT, "START - wfaStaSendADDBA \n"); 

	  sprintf(gCmdStr, "cd %s & send_addba /interface %s /tid %i", WFA_CLI_CMD_DIR, intf, staSendADDBA->tid);
  	st = wfaExecuteCLI(gCmdStr);

  	switch(st)
  	{
	      case 0:
	      staSendADDBAResp->status = STATUS_COMPLETE;
	      break;
	      case 1:
	     	staSendADDBAResp->status = STATUS_ERROR;
	     	break;
	      case 2:
	     	staSendADDBAResp->status = STATUS_INVALID;
		     break;
  	}

  	wfaEncodeTLV(WFA_STA_SET_SEND_ADDBA_RESP_TLV, 4, (BYTE *)staSendADDBAResp, respBuf);
  	*respLen = WFA_TLV_HDR_LEN + 4;

  	return WFA_SUCCESS;
}

int wfaStaSetRIFS(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	   caStaSetRIFS_t *setRIFS = (caStaSetRIFS_t *)caCmdBuf;
#ifndef _WINDOWS
	   char *intf = setRIFS->intf;
#else
	   char *intf = aINTERFACE;
#endif

    dutCmdResponse_t *staSetRIFSResp = &gGenericResp;
	   int st;
	
	   sprintf(gCmdStr, "cd %s & set_rifs_test /interface %s /action %s", WFA_CLI_CMD_DIR, intf, capstr[setRIFS->action]);
	   st = wfaExecuteCLI(gCmdStr);

	   switch(st)
	   {
	       case 0:
	       staSetRIFSResp->status = STATUS_COMPLETE;
	       break;
	       case 1:
	      	staSetRIFSResp->status = STATUS_ERROR;
		      break;
	       case 2:
	      	staSetRIFSResp->status = STATUS_INVALID;
	      	break;
   	}

	   wfaEncodeTLV(WFA_STA_SET_RIFS_TEST_RESP_TLV, 4, (BYTE *)staSetRIFSResp, respBuf);
	   *respLen = WFA_TLV_HDR_LEN + 4;

	   return WFA_SUCCESS;
}

int wfaStaSendCoExistMGMT(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	    caStaSendCoExistMGMT_t *sendMGMT = (caStaSendCoExistMGMT_t *)caCmdBuf;
#ifndef _WINDOWS
	    char *intf = sendMGMT->intf;
#else
	    char *intf = aINTERFACE;
#endif
     dutCmdResponse_t *staSendMGMTResp = &gGenericResp;
	    int st = 0;
	
	    sprintf(gCmdStr, "cd %s & send_coexist_mgmt /interface %s /type %s /value %s", WFA_CLI_CMD_DIR, intf, sendMGMT->type, sendMGMT->value);
	    st = wfaExecuteCLI(gCmdStr);

    	switch(st)
	    {
	        case 0:
	        staSendMGMTResp->status = STATUS_COMPLETE;
	        break;
	        case 1:
	       	staSendMGMTResp->status = STATUS_ERROR;
	       	break;
        	case 2:
		       staSendMGMTResp->status = STATUS_INVALID;
	       	break;
	    }
	    wfaEncodeTLV(WFA_STA_SEND_COEXIST_MGMT_RESP_TLV, 4, (BYTE *)staSendMGMTResp, respBuf);
	    *respLen = WFA_TLV_HDR_LEN + 4;

	    return WFA_SUCCESS;
}

extern int progSet;

void _setProg(char *progname)
{
     if(strcmp(progname, "VHT") ==0)
         progSet = eDEF_VHT;
     else if(strcmp(progname, "11n") ==0)
         progSet = eDEF_11N;
     else
         progSet = 0;
}

int wfaStaResetDefault(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaResetDefault_t *reset = (caStaResetDefault_t *)caCmdBuf;
   	char *intf = aINTERFACE;
    char *prog = reset->set;
    dutCmdResponse_t *staResetResp = &gGenericResp;
    int st;

    DPRINT_INFOL(WFA_OUT, "Entering ...\n");
    sprintf(gCmdStr, "cd %s & reset_default /interface %s /set %s", WFA_CLI_CMD_DIR, intf, prog);
    DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
    st = wfaExecuteCLI(gCmdStr);

    DPRINT_INFOL(WFA_OUT, "Program Name-> %s\n", prog);

    _setProg(prog);

	DPRINT_INFOL(WFA_OUT, " After setProg - Program Name-> %i\n", progSet);

	progSet = eDEF_VHT;

	DPRINT_INFOL(WFA_OUT, "Final Program Name-> %i\n", progSet);

    switch(st)
    {
       case 0:
       staResetResp->status = STATUS_COMPLETE;
       break;
       case 1:
       staResetResp->status = STATUS_ERROR;
       break;
       case 2:
       staResetResp->status = STATUS_INVALID;
	   break;
    }

    wfaEncodeTLV(WFA_STA_RESET_DEFAULT_RESP_TLV, 4, (BYTE *)staResetResp, respBuf);
    *respLen = WFA_TLV_HDR_LEN + 4;

    DPRINT_INFOL(WFA_OUT, "Completing ...\n");
    return WFA_SUCCESS;
}

int wfaStaDisconnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCommand_t *disc = (dutCommand_t *)caCmdBuf;
   char *intf = disc->intf;
   dutCmdResponse_t *staDiscResp = &gGenericResp;
   FILE *tmpfile = NULL;
   char string[64],Interfacename[64], intfile[128], tfile[128];

   DPRINT_INFOL(WFA_OUT, "Entering wfaStaDisconnect ...\n");
	
   sprintf(intfile, "%s\\WfaEndpoint\\Interface.txt", sigmaPath);
   switch(geSupplicant)
   {
      case  eWindowsZeroConfig :
      tmpfile = fopen(intfile, "r");
      if(tmpfile == NULL)
      {
          DPRINT_ERR(WFA_ERR, "\n Error opening the interface file \n");
      }
	  else
	  {
	      for(;;)
	      {
	          if(fgets(string, 256, tmpfile) == NULL)
	           	break; 
	      }
	      fclose(tmpfile);

          if(strncmp(string, "IFNAME", 6) == 0)
          {
              char *str;
              str = strtok(string, "\"");
              str = strtok(NULL, "\"");
              if(str != NULL)
              {
	              strcpy(&Interfacename[0],str);
              }
	   	  }
	  }
	  sprintf(gCmdStr, "del /F /Q %s", tfile);

	  //sprintf(gCmdStr, "netsh wlan delete profile name=\"*\" interface=\"%s\"",&Interfacename[0]);
      sprintf(gCmdStr, "netsh wlan delete profile name=\"*\"");
	  system(gCmdStr);

	  DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
	  //ret = system(gCmdStr);
	  break;
	
	  default :
	  DPRINT_ERR(WFA_ERR, " \n Unknown Supplicant in Disconnect function");
   }

   staDiscResp->status = STATUS_COMPLETE;
   wfaEncodeTLV(WFA_STA_DISCONNECT_RESP_TLV, 4, (BYTE *)staDiscResp, respBuf);
   *respLen = WFA_TLV_HDR_LEN + 4;

    DPRINT_INFOL(WFA_OUT, "Completing ...\n");
    return WFA_SUCCESS;
}


/* Execute CLI, read the status from Environment variable */
int wfaExecuteCLI(char *CLI)
{
   int st = 0;
   char *retstr;

   system(CLI);

   Sleep(1000);

   retstr = getenv("WFA_CLI_STATUS");
   DPRINT_INFOL(WFA_OUT, "cli status %s\n", retstr);
   return atoi(retstr);
}

int wfaStaReassociate(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
    caStaReAssoc_t *reassoc = (caStaReAssoc_t *)caCmdBuf;
#ifndef _WINDOWS
	char *intf = reassoc->intf;
#else
	char *intf = aINTERFACE;
#endif
	char *bssid = reassoc->bssid;
    dutCmdResponse_t *staReAssocResp = &gGenericResp;
	int st;

	sprintf(gCmdStr, "cd %s & sta_send_reassoc /interface %s /bssid %s", WFA_CLI_CMD_DIR, intf, bssid);
	st = wfaExecuteCLI(gCmdStr);

    switch(st)
	{
	case 0:
	   staReAssocResp->status = STATUS_COMPLETE;
	   break;
	case 1:
		staReAssocResp->status = STATUS_ERROR;
		break;
	case 2:
		staReAssocResp->status = STATUS_INVALID;
		break;
	}

    wfaEncodeTLV(WFA_STA_REASSOCIATE_RESP_TLV, 4, (BYTE *)staReAssocResp, respBuf);
	*respLen = WFA_TLV_HDR_LEN + 4;

	return WFA_SUCCESS;
}

int wfaStaCliCommand(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
	char cmdName[32];
  	char * pcmdStr,*str;
  	int st;
  	char CmdStr[WFA_CMD_STR_SZ];
	FILE *wfaCliFd=NULL;
	char wfaCliBuff[64];
	char retstr[32], clfile[128];
	int CmdReturnFlag;
    int ret = 0;

	caStaCliCmdResp_t infoResp;

	DPRINT_INFOL(WFA_OUT, "\nEntry wfaStaCliCommand... \n");

	DPRINT_INFOL(WFA_OUT, "\nThe command Received: %s\n",caCmdBuf);

	memcpy(cmdName, strtok_r((char *)caCmdBuf, ",", (char **)&pcmdStr), 32);
	sprintf(CmdStr, "%s",cmdName);

    sprintf(clfile, "%s\\WfaEndpoint\\wfa_cli.txt", sigmaPath);

    DPRINT_INFOL(WFA_OUT, "===================cli file %s ==========================\n", clfile);

    for(;;)
    {
        str = strtok_r(NULL, ",", &pcmdStr);
	    if(str == NULL || str[0] == '\0')
        {
           DPRINT_INFOL(WFA_OUT, "No more string\n");
		   break;
        }
		else
		{
		    sprintf(CmdStr, "%s /%s",CmdStr,str);
		    str = strtok_r(NULL, ",", &pcmdStr);
		    sprintf(CmdStr, "%s %s",CmdStr,str);
		}
	}

    DPRINT_INFO(WFA_OUT, "CMDSTR ===========  %s ==================\n", CmdStr);
    // try
    Sleep(3000);

	CmdReturnFlag =0;
	// check the return process
	wfaCliFd=fopen(clfile,"r");
	if(wfaCliFd!= NULL)
	{
       DPRINT_INFOL(WFA_OUT, "Searching CLI Command %s\n", cmdName);
	   while(fgets(wfaCliBuff, 64, wfaCliFd) != NULL)
	   {
	       if(ferror(wfaCliFd))
	          break;

	       str=strtok(wfaCliBuff,"-");
	       if(strcmp(str,cmdName) == 0)
	       {
	           str=strtok(NULL,",");
			   if(strcmp(str,"TRUE") == 0)
               {
                    DPRINT_INFOL(WFA_OUT, "Found supported CLI Command %s\n",cmdName); 
                    CmdReturnFlag =1;
			        break;
			   }
		   }
	     
	   }
       fclose(wfaCliFd);
   }

   st = 1;

   wfaClearEnvVal("WFA_CLI_STATUS");
   wfaClearEnvVal("WFA_CLI_RETURN");

   sprintf(gCmdStr, "cd %s & echo CLI: %s & %s", WFA_CLI_CMD_DIR, CmdStr, CmdStr);
   ret = system(gCmdStr);
   DPRINT_INFOL(WFA_OUT, "\nRUN-> %s with status %i\n", gCmdStr, ret);

   Sleep(3000);
	
   memset(&retstr[0],'\0',32);
   int ckcnt = 1;
   while(retstr[0] =='\0' && ckcnt > 0)
   {
       wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
       ckcnt--;
       Sleep(1000);
   }
    
   DPRINT_INFOL(WFA_OUT, "\nCLI CmdStr %s status %s\n", CmdStr, retstr);
   if(strlen(retstr) > 0)
      st = atoi(retstr);

   DPRINT_INFOL(WFA_OUT, "\nBefore deciding the rertun status\n");
   DPRINT_INFOL(WFA_OUT, "CLI status %d\n",st);

   infoResp.resFlag=CmdReturnFlag;

   switch(st)
   {
       case 0:
       infoResp.status = STATUS_COMPLETE;
       if (CmdReturnFlag)
       {
           memset(&retstr[0],'\0',32);
           DPRINT_INFOL(WFA_OUT, "cli status beforoe %s**** len%d**** \n", retstr,strlen(retstr));
           wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
           DPRINT_INFOL(WFA_OUT, "cli status %s**** len%d**** \n", retstr,strlen(retstr));
           memset(&infoResp.result[0],'\0',WFA_CLI_CMD_RESP_LEN);
           if(retstr != NULL)
           {
               strncpy(&infoResp.result[0], retstr,(strlen(retstr) < WFA_CLI_CMD_RESP_LEN ) ? strlen(retstr) : (WFA_CLI_CMD_RESP_LEN-1) );
               DPRINT_INFOL(WFA_OUT, "Return CLI result to CA: %s****\n", &infoResp.result[0]);			
           }
           else
               strcpy(&infoResp.result[0], "ENV_VAR_NOT_DEFINED");
	   }
       break;

	   case 1:
	   infoResp.status = STATUS_ERROR;
       DPRINT_INFOL(WFA_OUT, "CLI STATUS ERROR\n");
	   break;
	   case 2:
	   infoResp.status = STATUS_INVALID;
       DPRINT_INFOL(WFA_OUT, "CLI STATUS INVALID\n");
	   break;
   }

   wfaEncodeTLV(WFA_STA_CLI_CMD_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return WFA_SUCCESS;
}




int wfaClearEnvVal(char * in_value)
{
    sprintf(gCmdStr, "reg delete HKEY_CURRENT_USER\\Environment /v %s /f",in_value);
    DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
    system(gCmdStr);
    //printf("CLI Command %s\n", gCmdStr);

	return WFA_SUCCESS;
}

int wfaGetEnvVal(char * in_value,char * out_value,int size)
{
   FILE *file_hd;
   char *str;
   char tfile[128], envfile[128];

   DPRINT_INFOL(WFA_OUT, "\nEntry wfaGetEnvVal.. ");

   sprintf(tfile, "%s\\Temp\\temp.txt", sigmaPath);
   sprintf(envfile, "%s\\Temp\\env_val.txt", sigmaPath);
   // get the status
   sprintf(gCmdStr, "del /F /Q %s && del /F /Q %s", tfile, envfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);


   sprintf(gCmdStr, "reg query HKEY_CURRENT_USER\\Environment /v %s > %s",in_value, tfile);
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);
   // printf("CLI Command %s\n", gCmdStr);

   sprintf(gCmdStr, "FOR /F \"tokens=3,* delims= \" %s in ('findstr \"%s\" %s') do @echo %s %s > %s","%i",in_value,tfile, "%i","%j", envfile );
   DPRINT_INFOL(WFA_OUT, "RUN-> %s\n", gCmdStr);
   system(gCmdStr);
    //printf("CLI Command %s\n", gCmdStr);

	  // get the status
   file_hd = fopen(envfile,"r");
   if(file_hd != NULL && !ferror(file_hd))
   {
      fgets(gCmdStr,WFA_CMD_STR_SZ,file_hd);
      str=strtok(gCmdStr," ");
      strcpy(out_value,str);
      DPRINT_INFOL(WFA_OUT, "In GetEnv token %s*** The return value:%s***\n",str,out_value);
      str=strtok(NULL," ");
      if(strlen(str) >2)
	      sprintf(&out_value[strlen(out_value)]," %s",str);

      DPRINT_INFOL(WFA_OUT, "In GetEnv token %s**** The return value:%s***\n",str,out_value);
      fclose(file_hd);
  	}
    else
    {
	    out_value = NULL;
    }

	  DPRINT_INFOL(WFA_OUT, "Completing ... ");
	  return WFA_SUCCESS;
}


#ifdef WFA_P2P
/*
 * wfaStaGetP2pDevAddress(): 
 */
int wfaStaGetP2pDevAddress(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getInfo = (dutCommand_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	st = 1;

	printf("\n Entry wfaStaGetP2pDevAddress... ");

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_get_p2p_dev_address /interface %s", WFA_CLI_CMD_DIR, intf);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
   	if(retstr !=NULL)
	    st = atoi(retstr);


	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;

	    wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
	    printf("cli status %s\n", retstr);
		memset(&infoResp.cmdru.devid[0],0,WFA_P2P_DEVID_LEN);
		if(retstr != NULL)
		{
			strncpy(&infoResp.cmdru.devid[0], retstr,(strlen(retstr) < WFA_P2P_DEVID_LEN ) ? strlen(retstr) : (WFA_P2P_DEVID_LEN-1) );
			printf("Device ID : %s\n", &infoResp.cmdru.devid[0]);			
		}
		else
			strcpy(&infoResp.cmdru.devid[0], "ENV_VAR_NOT_DEFINED");
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}
	
   wfaEncodeTLV(WFA_STA_GET_P2P_DEV_ADDRESS_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

/*
 * wfaStaSetP2p(): 
 */
int wfaStaSetP2p(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaSetP2p_t *getStaSetP2p = (caStaSetP2p_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getStaSetP2p->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
	char cmd[512];
   char retstr[128];

   
	printf("\n Entry wfaStaSetP2p... ");

	memset(cmd,0,512);
	
	if(getStaSetP2p->oper_chn_flag == 1)
		sprintf(cmd+strlen(cmd)," /oper_chn %d",getStaSetP2p->oper_chn);
	if(getStaSetP2p->intent_val_flag == 1)
		sprintf(cmd+strlen(cmd)," /intent_val %d",getStaSetP2p->intent_val);
	if(getStaSetP2p->listen_chn_flag == 1)
		sprintf(cmd+strlen(cmd)," /listen_chn %d",getStaSetP2p->listen_chn);
	if(getStaSetP2p->p2p_mode_flag == 1)
		sprintf(cmd+strlen(cmd)," /p2p_mode %s",getStaSetP2p->p2p_mode);
	if(getStaSetP2p->ssid_flag == 1)
		sprintf(cmd+strlen(cmd)," /ssid %s",getStaSetP2p->ssid);
	if(getStaSetP2p->presistent_flag == 1)
		sprintf(cmd+strlen(cmd)," /presistent %d",getStaSetP2p->presistent);
	if(getStaSetP2p->intra_bss_flag == 1)
		sprintf(cmd+strlen(cmd)," /intra_bss %d",getStaSetP2p->intra_bss);
	if(getStaSetP2p->noa_duration_flag == 1)
		sprintf(cmd+strlen(cmd)," /noa_duration %d",getStaSetP2p->noa_duration);
	if(getStaSetP2p->noa_interval_flag == 1)
		sprintf(cmd+strlen(cmd)," /noa_interval %d",getStaSetP2p->noa_interval);
	if(getStaSetP2p->noa_count_flag == 1)
		sprintf(cmd+strlen(cmd)," /noa_count %d",getStaSetP2p->noa_count);

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_set_p2p /interface %s %s", WFA_CLI_CMD_DIR, intf, cmd);
	st = wfaExecuteCLI(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

	// Implement the function and this does not return any thing back.
   
   wfaEncodeTLV(WFA_STA_SET_P2P_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}
/*
 * wfaStaP2pConnect(): 
 */
int wfaStaP2pConnect(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaP2pConnect_t *getStaP2pConnect = (caStaP2pConnect_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

   
	printf("\n Entry wfaStaP2pConnect... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_p2p_connect /interface %s /p2pdevid %s", WFA_CLI_CMD_DIR, intf,getStaP2pConnect->devId);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;

	    wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
	    printf("cli status %s\n", retstr);
		memset(&infoResp.cmdru.grpid[0],0,WFA_P2P_GRP_ID_LEN);
		if(retstr != NULL)
		{
			strncpy(&infoResp.cmdru.grpid[0], retstr,(strlen(retstr) < WFA_P2P_GRP_ID_LEN ) ? strlen(retstr) : (WFA_P2P_GRP_ID_LEN-1) );
			printf("Device ID : %s\n", &infoResp.cmdru.grpid[0]);			
		}
		else
			strcpy(&infoResp.cmdru.grpid[0], "ENV_VAR_NOT_DEFINED");
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}
	
	// Implement the function and this  return the grpid.
   wfaEncodeTLV(WFA_STA_P2P_CONNECT_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

/*
 * wfaStaP2pJoin(): 
 */
int wfaStaP2pJoin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaP2pJoin_t *getStaP2pJoin = (caStaP2pJoin_t *)caCmdBuf;


	#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

   
	printf("\n Entry wfaStaP2pJoin... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");


	sprintf(gCmdStr, "cd %s & sta_p2p_join /interface %s /p2pdevid %s /ssid %s", WFA_CLI_CMD_DIR, intf,getStaP2pJoin->devId,getStaP2pJoin->ssid);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}


	// Implement the function and this does not return any thing back.
   wfaEncodeTLV(WFA_STA_P2P_JOIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaP2pStartGrpFormation(): 
 */
int wfaStaP2pStartGrpFormation(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaP2pStartGrpForm_t *getStaP2pStartGrpForm = (caStaP2pStartGrpForm_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];


	printf("\n Entry wfaStaP2pStartGrpFormation... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_p2p_start_group_formation /interface %s /p2pdevid %s /intent_val %d", WFA_CLI_CMD_DIR, intf,getStaP2pStartGrpForm->devId,getStaP2pStartGrpForm->intent_val);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;

	    wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
	    printf("cli status %s\n", retstr);
		memset(&infoResp.cmdru.grpid[0],0,WFA_P2P_GRP_ID_LEN);
		if(retstr != NULL)
		{
			strncpy(&infoResp.cmdru.p2presult[0], retstr,(strlen(retstr) < WFA_P2P_GRP_ID_LEN ) ? strlen(retstr) : (WFA_P2P_GRP_ID_LEN-1) );
			printf("Device ID : %s\n", &infoResp.cmdru.grpid[0]);			
		}
		else
			strcpy(&infoResp.cmdru.grpid[0], "ENV_VAR_NOT_DEFINED");
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

	wfaEncodeTLV(WFA_STA_P2P_START_GRP_FORM_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaP2pDissolve(): 
 */
int wfaStaP2pDissolve(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaP2pDissolve_t *getStap2pDissolve= (caStaP2pDissolve_t *)caCmdBuf;
	
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaP2pDissolve... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");


	sprintf(gCmdStr, "cd %s & sta_p2p_dissolve /interface %s /groupid %s", WFA_CLI_CMD_DIR, intf,getStap2pDissolve->grpId);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

   wfaEncodeTLV(WFA_STA_P2P_DISSOLVE_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

/*
 * wfaStaSendP2pInvReq(): 
 */
int wfaStaSendP2pInvReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaSendP2pInvReq_t *getStaP2pInvReq= (caStaSendP2pInvReq_t *)caCmdBuf;
	
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaSendP2pInvReq... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	if(getStaP2pInvReq->grpId_flag == 1)
		sprintf(gCmdStr, "cd %s & sta_send_p2p_invitation_req /interface %s /p2pdevid %s /groupid %s", WFA_CLI_CMD_DIR, intf,getStaP2pInvReq->devId,getStaP2pInvReq->grpId);
	else
		sprintf(gCmdStr, "cd %s & sta_send_p2p_invitation_req /interface %s /p2pdevid %s", WFA_CLI_CMD_DIR, intf,getStaP2pInvReq->devId);

	system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);

	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

	
   wfaEncodeTLV(WFA_STA_SEND_P2P_INV_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaAcceptP2pReq(): 
 */
int wfaStaAcceptP2pReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaSendP2pInvReq_t *getStaP2pInvReq= (caStaSendP2pInvReq_t *)caCmdBuf;
	
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaAcceptP2pReq... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	if(getStaP2pInvReq->grpId_flag == 1)
		sprintf(gCmdStr, "cd %s & sta_accept_p2p_invitation_req /interface %s /p2pdevid %s /groupid %s", WFA_CLI_CMD_DIR, intf,getStaP2pInvReq->devId,getStaP2pInvReq->grpId);
	else
		sprintf(gCmdStr, "cd %s & sta_accept_p2p_invitation_req /interface %s /p2pdevid %s", WFA_CLI_CMD_DIR, intf,getStaP2pInvReq->devId);

	system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

   wfaEncodeTLV(WFA_STA_ACCEPT_P2P_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaSendP2pProvDisReq(): 
 */
int wfaStaSendP2pProvDisReq(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaSendP2pProvDisReq_t *getStaP2pProvDisReq= (caStaSendP2pProvDisReq_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaSendP2pProvDisReq... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_send_p2p_provision_dis_req /interface %s /configmethod %s /p2pdevid %s", WFA_CLI_CMD_DIR, intf,getStaP2pProvDisReq->confMethod,getStaP2pProvDisReq->devId);
	system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);

	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

	wfaEncodeTLV(WFA_STA_SEND_P2P_PROV_DIS_REQ_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

/*
 * wfaStaSetWpsPbc(): 
 */
int wfaStaSetWpsPbc(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getStaSetWpsPbc= (dutCommand_t *)caCmdBuf;

#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaSetWpsPbc... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_set_wps_pbc /interface %s", WFA_CLI_CMD_DIR, intf);
	system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);

	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}
   wfaEncodeTLV(WFA_STA_SET_WPS_PBC_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

/*
 * wfaStaWpsReadPin(): 
 */
int wfaStaWpsReadPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getStaWpsReadPin= (dutCommand_t *)caCmdBuf;
	
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[WFA_WPS_PIN_LEN];


	printf("\n Entry wfaStaWpsReadPin... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_wps_read_pin /interface %s", WFA_CLI_CMD_DIR, intf);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);

	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;

	    wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
	    printf("cli status %s\n", retstr);
		memset(&infoResp.cmdru.wpsPin[0],0,WFA_WPS_PIN_LEN);
		if(retstr != NULL)
		{
			strncpy(&infoResp.cmdru.wpsPin[0], retstr,(strlen(retstr) < WFA_WPS_PIN_LEN ) ? strlen(retstr) : (WFA_WPS_PIN_LEN-1) );
			printf("Device ID : %s\n", &infoResp.cmdru.wpsPin[0]);			
		}
		else
			strcpy(&infoResp.cmdru.grpid[0], "ENV_VAR_NOT_DEFINED");
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}
		
   wfaEncodeTLV(WFA_STA_WPS_READ_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaWpsEnterPin(): 
 */
int wfaStaWpsEnterPin(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   caStaWpsEnterPin_t *getStaWpsEnterPin= (caStaWpsEnterPin_t *)caCmdBuf;
   
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[128];

	printf("\n Entry wfaStaWpsEnterPin... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_wps_enter_pin /interface %s /pin ", WFA_CLI_CMD_DIR, intf,getStaWpsEnterPin->wpsPin);
	system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);

	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

   wfaEncodeTLV(WFA_STA_WPS_ENTER_PIN_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}


/*
 * wfaStaGetPsk(): 
 */
int wfaStaGetPsk(int len, BYTE *caCmdBuf, int *respLen, BYTE *respBuf)
{
   dutCmdResponse_t infoResp;
   dutCommand_t *getStaGetPsk= (dutCommand_t *)caCmdBuf;
   	
#ifndef _WINDOWS
	char *intf = getInfo->intf;
#else
	char *intf = aINTERFACE;
#endif
	int st;
   char retstr[WFA_WPS_PIN_LEN];
      
   printf("\n Entry wfaStaGetPsk... ");

	st = 1;

	wfaClearEnvVal("WFA_CLI_STATUS");
	wfaClearEnvVal("WFA_CLI_RETURN");

	sprintf(gCmdStr, "cd %s & sta_get_psk /interface %s", WFA_CLI_CMD_DIR, intf);
    system(gCmdStr);
    printf("CLI Command %s\n", gCmdStr);

    wfaGetEnvVal("WFA_CLI_STATUS",&retstr[0],sizeof(retstr));
    printf("cli status %s\n", retstr);
	if(retstr !=NULL)
	    st = atoi(retstr);

	switch(st)
	{
	case 0:
	   infoResp.status = STATUS_COMPLETE;

	    wfaGetEnvVal("WFA_CLI_RETURN",&retstr[0],sizeof(retstr));
	    printf("cli status %s\n", retstr);
		memset(&infoResp.cmdru.pskInfo.passPhrase[0],0,WFA_WPS_PIN_LEN);
		if(retstr != NULL)
		{
			strncpy(&infoResp.cmdru.pskInfo.passPhrase[0], retstr,(strlen(retstr) < WFA_WPS_PIN_LEN ) ? strlen(retstr) : (WFA_WPS_PIN_LEN-1) );
			printf("Device ID : %s\n", &infoResp.cmdru.pskInfo.passPhrase[0]);			
		}
		else
			strcpy(&infoResp.cmdru.grpid[0], "ENV_VAR_NOT_DEFINED");
	   break;
	case 1:
		infoResp.status = STATUS_ERROR;
		break;
	case 2:
		infoResp.status = STATUS_INVALID;
		break;
	}

   wfaEncodeTLV(WFA_STA_GET_PSK_RESP_TLV, sizeof(infoResp), (BYTE *)&infoResp, respBuf);   
   *respLen = WFA_TLV_HDR_LEN + sizeof(infoResp);

   return TRUE;
}

#endif
