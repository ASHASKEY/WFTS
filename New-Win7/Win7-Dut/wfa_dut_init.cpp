/****************************************************************************
 *  (c) Copyright 2007 Wi-Fi Alliance.  All Rights Reserved
 *
 *  Author: Sandeep Mohan Bharadwaj	Email:sbharadwaj@wi-fi.org
 *
 *  LICENSE
 *
 * License is granted only to Wi-Fi Alliance members and designated
 * contractors ($B!H(BAuthorized Licensees$B!I(B)..AN  Authorized Licensees are granted
 * the non-exclusive, worldwide, limited right to use, copy, import, export
 * and distribute this software:
 * (i) solely for noncommercial applications and solely for testing Wi-Fi
 * equipment; and
 * (ii) solely for the purpose of embedding the software into Authorized
 * Licensee$B!G(Bs proprietary equipment and software products for distribution to
 * its customers under a license with at least the same restrictions as
 * contained in this License, including, without limitation, the disclaimer of
 * warranty and limitation of liability, below..AN  The distribution rights
 * granted in clause (ii), above, include distribution to third party
 * companies who will redistribute the Authorized Licensee$B!G(Bs product to their
 * customers with or without such third party$B!G(Bs private label. Other than
 * expressly granted herein, this License is not transferable or sublicensable,
 * and it does not extend to and may not be used with non-Wi-Fi applications..AN 
 * Wi-Fi Alliance reserves all rights not expressly granted herein..AN 
 *
 * Except as specifically set forth above, commercial derivative works of
 * this software or applications that use the Wi-Fi scripts generated by this
 * software are NOT AUTHORIZED without specific prior written permission from
 * Wi-Fi Alliance..AN Non-Commercial derivative works of this software for
 * internal use are authorized and are limited by the same restrictions;
 * provided, however, that the Authorized Licensee shall provide Wi-Fi Alliance
 * with a copy of such derivative works under a perpetual, payment-free license
 * to use, modify, and distribute such derivative works for purposes of testing
 * Wi-Fi equipment.
 * Neither the name of the author nor "Wi-Fi Alliance" may be used to endorse
 * or promote products that are derived from or that use this software without
 * specific prior written permission from Wi-Fi Alliance.
 *
 * THIS SOFTWARE IS PROVIDED BY WI-FI ALLIANCE "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A.AN PARTICULAR PURPOSE,
 * ARE DISCLAIMED. IN NO EVENT SHALL WI-FI ALLIANCE BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, THE COST OF PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ****************************************************************************
 *
 *  Revision History:
 *       2007/10/10 --  02.20 Voice SOHO beta -- qhu
 *       2007/11/07 --  02.30 Voice HSO -- qhu
 *       2009/08/04 --  add new dedicated thread to handle receiving traffic for windows code -- qhu
 *
 */
#include "stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#ifndef _WINDOWS
#include <pthread.h>
#endif
#include <time.h>

#include "wfa_debug.h"
#include "wfa_main.h"
#include "wfa_types.h"
#include "wfa_dut.h"
#include "wfa_sock.h"
#include "wfa_tg.h"
#include "wfa_cmds.h"

extern tgStream_t *gStreams;
extern tgE2EStats_t *e2eStats;
extern char       gnetIf[WFA_BUFF_32];
extern char gCmdStr[WFA_CMD_STR_SZ];
extern int vend;
extern int geSupplicant; /* supplicant type */
extern unsigned short wfa_defined_debug;
#ifdef _WINDOWS
extern int        tgSockfds[];
extern char WFA_CLI_CMD_DIR[];

char WFA_CLI_VERSION[32];
char intfname[64];
char intfNetName[128];
#endif

#ifdef WFA_WMM_EXT
extern tgWMM_t wmm_thr[];
extern void *wfa_wmm_thread(void *thr_param);
#ifndef _WINDOWS
void init_thr_flag()
{
    int i = 0;
    for(i=0; i< WFA_THREADS_NUM; i++)
    {
        pthread_mutex_init(&wmm_thr[i].thr_flag_mutex, NULL);
        pthread_cond_init(&wmm_thr[i].thr_flag_cond, NULL);
	pthread_mutex_init(&wmm_thr[i].thr_flag_mutex, NULL);
        pthread_cond_init(&wmm_thr[i].thr_flag_cond, NULL);
        wmm_thr[i].thr_flag = 0;
        wmm_thr[i].stop_flag = 0;
	
    }
}
#endif
#endif /* WFA_WMM_EXT */


void wfa_dut_init(BYTE **tBuf, BYTE **rBuf, BYTE **paBuf, BYTE **cBuf, struct timeval **timerp)
{
#ifdef _WINDOWS
	char filename[256];
	char string[256];
	FILE *tmpfd;
	int ret;
#endif
	int ncnt = 0;
    /* allocate the traffic stream table */
   // gStreams = (tgStream_t *) malloc(WFA_MAX_TRAFFIC_STREAMS*sizeof(tgStream_t));
    //if(gStreams == NULL)
    //{
      //  DPRINT_ERR(WFA_ERR, "Failed to malloc theStreams\n");
        //exit(1);
    //}

    for( ncnt = 0; ncnt < WFA_MAX_WMM_STREAMS; ncnt++)
    {
        tgSockfds[ncnt] = -1;
    }
   
	/* a buffer used to carry receive and send test traffic */
    *tBuf = (BYTE *) malloc(MAX_UDP_LEN+1); /* alloc a traffic buffer */
    if(*tBuf == NULL)
    {
        DPRINT_ERR(WFA_ERR, "Failed to malloc traffic buffer\n");
        exit(1);
    }

    /* a buffer used for response of control command */
    *rBuf = (BYTE *)malloc(WFA_BUFF_512);
    if(*rBuf == NULL)
    {
        DPRINT_ERR(WFA_ERR, "Failed to malloc response buffer\n");
        exit(1);
    }

    /* timer used in select call */
    *timerp = (timeval *) malloc(sizeof(struct timeval));
    if(*timerp == NULL)
    {
        DPRINT_ERR(WFA_ERR, "Failed to malloc timer val\n");
        exit(1);
    }

    /* control command buf */
    *cBuf = (BYTE *) malloc(WFA_BUFF_1K);
    if(*cBuf == NULL)
    {
        DPRINT_ERR(WFA_ERR, "Failed to malloc control command buf\n");
        exit(1);
    }

    /* parameters buff */
    *paBuf = (BYTE *)malloc(MAX_PARMS_BUFF);
    if(*paBuf == NULL)
    {
        DPRINT_ERR(WFA_ERR, "Failed to malloc parms value buff\n");
        exit(1);
    }

#ifdef WFA_WMM_EXT
    /* allocate for End2End stats */
    e2eStats = (tgE2EStats_t *) malloc(6144*sizeof(tgE2EStats_t));
    if(e2eStats == NULL)
    {
       DPRINT_ERR(WFA_ERR, "Failed to malloc e2eStats\n");
       exit(1);
    }
#ifdef _WINDOWS
#ifndef WIN_7
	// Set ZeroConfig as the running supplicant
	
		   // Cisco Secure client supplicant
			DisableCiscoSupplicant();

		   // stop the other supplicants and start ZeroConfig
			// WpaSupplicant supplicant
		   sprintf(gCmdStr, "sc stop WFA_WpaSupplicant_Service");
	       DPRINT_INFO(WFA_OUT, "Executing %s\n",gCmdStr);
		   ret = system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Retun value: %d\n",ret);

		   // stop the Marvell supplicant
   			sprintf(gCmdStr, "Taskkill /T /F /IM Mrv8000x.exe");
			system(gCmdStr);
			Sleep(1000);


		   sprintf(gCmdStr, "sc start wzcsvc");
		   DPRINT_INFO(WFA_OUT,"Executing %s\n",gCmdStr);
		   ret = system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Retun value: %d\n",ret);
		   Sleep(500);
		   sprintf(gCmdStr, "wifi_config -limit %s -enable", gnetIf);
		   system(gCmdStr);
		   DPRINT_INFO(WFA_OUT,"Executing %s\n",gCmdStr);

		   geSupplicant = eWindowsZeroConfig;
#else
		   geSupplicant = eWindowsZeroConfig;
#endif
		   DPRINT_INFO(WFA_OUT,"New Supplicant value: %d\n",geSupplicant);

		// End of setting ZeroConfig



#ifndef WIN_7
   strncpy(filename,"c:\\WINDOWS\\TEMP\\ipconfig.txt",40);
   sprintf(gCmdStr, "wifi_config -limit %s -mac > %s ", gnetIf,filename); 
   system(gCmdStr);
   tmpfd = fopen(filename, "r+");
   if(tmpfd == NULL)
	{
	  
	  DPRINT_ERR(WFA_ERR, "file open failed\n");
	  return ;
	}

		fgets(string, 256, tmpfd);
		fclose(tmpfd);

		string[8]='\0';
   sprintf(gCmdStr, "GetVendor  %s > c:\\windows\\temp\\vend.txt", string);
	strcpy(filename,"c:\\windows\\temp\\vend.txt");
   printf("Executing %s\n",gCmdStr);
   system(gCmdStr);
	tmpfd = fopen(filename, "r+");
	if(tmpfd == NULL)
	{
	  
	  DPRINT_ERR(WFA_ERR, "file open failed\n");
	  return ;
	}

		fgets(string, 256, tmpfd);
		fclose(tmpfd);

		if(!_stricmp(string,"Broadcomm"))
			vend= WMM_BROADCOMM;
		else if(!_stricmp(string,"Intel"))
			vend= WMM_INTEL;
		else if(!_stricmp(string,"Marvell"))
			vend= WMM_MARVELL;
		else if(!_stricmp(string,"Atheros"))
			vend= WMM_ATHEROS;

#else
		vend= WMM_BROADCOMM;
#endif

#endif
#endif /* WFA_WMM_EXT   */

}

#ifdef _WINDOWS
void wfa_set_envs()
{
	char *name, *dest;
	FILE *envfile = NULL;
	char line[129];

	envfile = fopen("sigma_settings.txt", "r");

	if(envfile == NULL)
	{
		printf("can't open setting file, exiting ...\n");
		exit(1);
	}


	memset(WFA_CLI_CMD_DIR, 0, 64);

	
	while(fgets(line, 128, envfile) != NULL)
	{
		if(*line == '#' || *line == 'a')
		{
            memset(line, 0, 129);
			continue;
		}

        name = (char *)strtok(line, "=");
		dest = (char *)strtok(NULL, "=");

		if(strcmp(name, "WFA_CLI_STA_DEVICE") == 0)
		{
			dest[strlen(dest)-1] = '\0';
			printf("value %s\n", dest);
			strcpy(WFA_CLI_CMD_DIR, dest);
			printf(" %s is %s\n", name, WFA_CLI_CMD_DIR);
		}
		else if(strcmp(name, "DEVICE") == 0)
		{
            dest[strlen(dest)-1] = '\0';
			strcpy(intfname, dest);
			printf("%s is %s\n", name, intfname);
		}
		else if(strcmp(name, "VERSION") == 0)
		{
            dest[strlen(dest)-1] = '\0';
			strcpy(WFA_CLI_VERSION, dest);
			printf("%s is %s\n", name, WFA_CLI_VERSION);
		}

		memset(line, 0, 129);
	}

#if 0
	strcpy(WFA_CLI_CMD_DIR, getenv("WFA_CLI_STA_DEVICE"));

	printf("CLI path is %s\n", WFA_CLI_CMD_DIR);
#endif

	// Get the interface name


	//reset the env variable status
	putenv("WFA_CLI_STATUS=0");

}
#endif